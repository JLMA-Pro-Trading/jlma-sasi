03b53262c51ef5c2e841fbf63df9c815
"use strict";
/**
 * Performance Test Setup for Phase 2A
 * Specialized setup for performance benchmarking with strict thresholds
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockPerformanceComponents = exports.performanceAssertions = exports.performanceTestUtils = exports.memoryMonitor = exports.MemoryMonitor = exports.performanceMonitor = exports.PerformanceMonitor = exports.PERFORMANCE_THRESHOLDS = void 0;
const globals_1 = require("@jest/globals");
// Performance thresholds for Phase 2A
exports.PERFORMANCE_THRESHOLDS = {
    AGENT_SPAWN_TIME: 75, // <75ms agent spawn time
    INFERENCE_TIME: 100, // <100ms neural inference
    PERSISTENCE_SAVE: 75, // <75ms database save operations
    PERSISTENCE_LOAD: 100, // <100ms database load operations
    COORDINATION_OVERHEAD: 50, // <50ms coordination between agents
    MEMORY_USAGE_PER_AGENT: 50 * 1024 * 1024, // <50MB per agent
    REAL_TIME_FPS: 60, // 60 FPS for real-time performance
    BATCH_PROCESSING: 200, // <200ms for batch operations
    KNOWLEDGE_SHARING: 150, // <150ms for knowledge transfer between agents
    CROSS_SESSION_RESTORE: 300 // <300ms for cross-session state restoration
};
// Performance monitoring utilities
class PerformanceMonitor {
    constructor() {
        Object.defineProperty(this, "metrics", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "startTimes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    startMeasurement(operationId) {
        this.startTimes.set(operationId, performance.now());
    }
    endMeasurement(operationId, metadata = {}) {
        const startTime = this.startTimes.get(operationId);
        if (!startTime) {
            throw new Error(`No start time found for operation: ${operationId}`);
        }
        const duration = performance.now() - startTime;
        const metric = {
            operationId,
            duration,
            timestamp: Date.now(),
            metadata
        };
        const operationMetrics = this.metrics.get(operationId) || [];
        operationMetrics.push(metric);
        this.metrics.set(operationId, operationMetrics);
        this.startTimes.delete(operationId);
        return duration;
    }
    getMetrics(operationId) {
        return this.metrics.get(operationId) || [];
    }
    getAverageTime(operationId) {
        const metrics = this.getMetrics(operationId);
        if (metrics.length === 0)
            return 0;
        const totalTime = metrics.reduce((sum, metric) => sum + metric.duration, 0);
        return totalTime / metrics.length;
    }
    getPercentile(operationId, percentile) {
        const metrics = this.getMetrics(operationId);
        if (metrics.length === 0)
            return 0;
        const sorted = metrics.map(m => m.duration).sort((a, b) => a - b);
        const index = Math.ceil(sorted.length * (percentile / 100)) - 1;
        return sorted[index];
    }
    clear() {
        this.metrics.clear();
        this.startTimes.clear();
    }
    generateReport() {
        const report = {
            timestamp: Date.now(),
            operations: {}
        };
        for (const [operationId, metrics] of this.metrics.entries()) {
            if (metrics.length > 0) {
                report.operations[operationId] = {
                    count: metrics.length,
                    average: this.getAverageTime(operationId),
                    p50: this.getPercentile(operationId, 50),
                    p95: this.getPercentile(operationId, 95),
                    p99: this.getPercentile(operationId, 99),
                    min: Math.min(...metrics.map(m => m.duration)),
                    max: Math.max(...metrics.map(m => m.duration))
                };
            }
        }
        return report;
    }
}
exports.PerformanceMonitor = PerformanceMonitor;
// Global performance monitor instance
exports.performanceMonitor = new PerformanceMonitor();
// Memory monitoring utilities
class MemoryMonitor {
    constructor() {
        Object.defineProperty(this, "snapshots", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    takeSnapshot(label) {
        const memUsage = process.memoryUsage();
        const snapshot = {
            label,
            timestamp: Date.now(),
            rss: memUsage.rss,
            heapUsed: memUsage.heapUsed,
            heapTotal: memUsage.heapTotal,
            external: memUsage.external
        };
        this.snapshots.push(snapshot);
        return snapshot;
    }
    comparSnapshots(labelA, labelB) {
        const snapshotA = this.snapshots.find(s => s.label === labelA);
        const snapshotB = this.snapshots.find(s => s.label === labelB);
        if (!snapshotA || !snapshotB) {
            throw new Error('Snapshots not found for comparison');
        }
        return {
            rssDelta: snapshotB.rss - snapshotA.rss,
            heapUsedDelta: snapshotB.heapUsed - snapshotA.heapUsed,
            heapTotalDelta: snapshotB.heapTotal - snapshotA.heapTotal,
            externalDelta: snapshotB.external - snapshotA.external
        };
    }
    getMemoryGrowth() {
        if (this.snapshots.length < 2)
            return 0;
        const first = this.snapshots[0];
        const last = this.snapshots[this.snapshots.length - 1];
        return last.heapUsed - first.heapUsed;
    }
    clear() {
        this.snapshots = [];
    }
}
exports.MemoryMonitor = MemoryMonitor;
// Global memory monitor instance
exports.memoryMonitor = new MemoryMonitor();
// Performance test utilities
exports.performanceTestUtils = {
    /**
     * Assert operation meets performance threshold
     */
    assertPerformanceThreshold: (operationType, actualTime) => {
        const threshold = exports.PERFORMANCE_THRESHOLDS[operationType];
        expect(actualTime).toBeLessThan(threshold);
    },
    /**
     * Measure async operation performance
     */
    measureAsyncOperation: async (operationName, operation) => {
        const operationId = `${operationName}-${Date.now()}`;
        exports.performanceMonitor.startMeasurement(operationId);
        const result = await operation();
        const duration = exports.performanceMonitor.endMeasurement(operationId);
        return { result, duration };
    },
    /**
     * Measure synchronous operation performance
     */
    measureSyncOperation: (operationName, operation) => {
        const operationId = `${operationName}-${Date.now()}`;
        exports.performanceMonitor.startMeasurement(operationId);
        const result = operation();
        const duration = exports.performanceMonitor.endMeasurement(operationId);
        return { result, duration };
    },
    /**
     * Run performance stress test
     */
    runStressTest: async (operationName, operation, iterations = 100) => {
        const results = [];
        exports.memoryMonitor.takeSnapshot(`${operationName}-start`);
        for (let i = 0; i < iterations; i++) {
            const { duration } = await exports.performanceTestUtils.measureAsyncOperation(`${operationName}-${i}`, operation);
            results.push(duration);
        }
        exports.memoryMonitor.takeSnapshot(`${operationName}-end`);
        const memoryGrowth = exports.memoryMonitor.getMemoryGrowth();
        return {
            iterations,
            averageTime: results.reduce((sum, time) => sum + time, 0) / results.length,
            minTime: Math.min(...results),
            maxTime: Math.max(...results),
            memoryGrowth,
            results
        };
    },
    /**
     * Test concurrent operations performance
     */
    testConcurrentPerformance: async (operationName, operation, concurrency = 10) => {
        exports.memoryMonitor.takeSnapshot(`${operationName}-concurrent-start`);
        const promises = Array.from({ length: concurrency }, (_, i) => exports.performanceTestUtils.measureAsyncOperation(`${operationName}-concurrent-${i}`, operation));
        const results = await Promise.all(promises);
        exports.memoryMonitor.takeSnapshot(`${operationName}-concurrent-end`);
        const memoryGrowth = exports.memoryMonitor.getMemoryGrowth();
        const durations = results.map(r => r.duration);
        return {
            concurrency,
            averageTime: durations.reduce((sum, time) => sum + time, 0) / durations.length,
            minTime: Math.min(...durations),
            maxTime: Math.max(...durations),
            memoryGrowth,
            results
        };
    },
    /**
     * Validate real-time performance (60 FPS = ~16.67ms per frame)
     */
    validateRealTimePerformance: (frameTime) => {
        const fpsThreshold = 1000 / exports.PERFORMANCE_THRESHOLDS.REAL_TIME_FPS; // ~16.67ms for 60 FPS
        expect(frameTime).toBeLessThan(fpsThreshold);
    },
    /**
     * Generate performance test scenarios
     */
    generatePerformanceScenarios: () => [
        {
            name: 'Agent Spawn Performance',
            thresholdType: 'AGENT_SPAWN_TIME',
            operation: async () => {
                // Mock agent spawn
                await new Promise(resolve => setTimeout(resolve, Math.random() * 50));
                return { agentId: 'test-agent', spawnTime: Date.now() };
            }
        },
        {
            name: 'Neural Inference Performance',
            thresholdType: 'INFERENCE_TIME',
            operation: async () => {
                // Mock neural inference
                await new Promise(resolve => setTimeout(resolve, Math.random() * 80));
                return [Math.random(), Math.random(), Math.random()];
            }
        },
        {
            name: 'Persistence Save Performance',
            thresholdType: 'PERSISTENCE_SAVE',
            operation: async () => {
                // Mock database save
                await new Promise(resolve => setTimeout(resolve, Math.random() * 60));
                return { saved: true, timestamp: Date.now() };
            }
        },
        {
            name: 'Coordination Overhead Performance',
            thresholdType: 'COORDINATION_OVERHEAD',
            operation: async () => {
                // Mock agent coordination
                await new Promise(resolve => setTimeout(resolve, Math.random() * 40));
                return { coordinated: true, agentCount: 3 };
            }
        }
    ]
};
// Performance assertion helpers
exports.performanceAssertions = {
    /**
     * Assert agent spawn time meets threshold
     */
    assertAgentSpawnTime: (spawnTime) => {
        exports.performanceTestUtils.assertPerformanceThreshold('AGENT_SPAWN_TIME', spawnTime);
    },
    /**
     * Assert neural inference time meets threshold
     */
    assertInferenceTime: (inferenceTime) => {
        exports.performanceTestUtils.assertPerformanceThreshold('INFERENCE_TIME', inferenceTime);
    },
    /**
     * Assert persistence operation time meets threshold
     */
    assertPersistenceTime: (operationType, operationTime) => {
        const thresholdType = operationType === 'save' ? 'PERSISTENCE_SAVE' : 'PERSISTENCE_LOAD';
        exports.performanceTestUtils.assertPerformanceThreshold(thresholdType, operationTime);
    },
    /**
     * Assert coordination overhead meets threshold
     */
    assertCoordinationOverhead: (coordinationTime) => {
        exports.performanceTestUtils.assertPerformanceThreshold('COORDINATION_OVERHEAD', coordinationTime);
    },
    /**
     * Assert memory usage per agent meets threshold
     */
    assertMemoryUsagePerAgent: (memoryUsage) => {
        expect(memoryUsage).toBeLessThan(exports.PERFORMANCE_THRESHOLDS.MEMORY_USAGE_PER_AGENT);
    },
    /**
     * Assert no memory leaks in operation
     */
    assertNoMemoryLeaks: (initialMemory, finalMemory, maxGrowth = 1024 * 1024) => {
        const memoryGrowth = finalMemory - initialMemory;
        expect(memoryGrowth).toBeLessThan(maxGrowth);
    }
};
// Mock performance-critical components
exports.mockPerformanceComponents = {
    fastNeuralInference: globals_1.jest.fn().mockImplementation(async (input) => {
        // Simulate fast inference (<100ms)
        await new Promise(resolve => setTimeout(resolve, Math.random() * 80));
        return new Float32Array(input.length).map(() => Math.random());
    }),
    optimizedAgentSpawn: globals_1.jest.fn().mockImplementation(async (config) => {
        // Simulate fast agent spawn (<75ms)
        await new Promise(resolve => setTimeout(resolve, Math.random() * 60));
        return {
            agentId: 'fast-agent-' + Date.now(),
            config,
            spawnTime: Date.now()
        };
    }),
    rapidPersistence: globals_1.jest.fn().mockImplementation(async (data) => {
        // Simulate fast persistence save (<75ms)
        await new Promise(resolve => setTimeout(resolve, Math.random() * 50));
        return { saved: true, data, timestamp: Date.now() };
    }),
    efficientCoordination: globals_1.jest.fn().mockImplementation(async (agents) => {
        // Simulate fast coordination (<50ms)
        await new Promise(resolve => setTimeout(resolve, Math.random() * 30));
        return { coordinated: agents, overhead: Date.now() };
    })
};
// Global performance test hooks
beforeEach(() => {
    exports.performanceMonitor.clear();
    exports.memoryMonitor.clear();
    globals_1.jest.clearAllMocks();
});
afterEach(() => {
    // Generate performance report if test failed
    if (expect.getState().currentTestName && expect.getState().assertionCalls > 0) {
        const report = exports.performanceMonitor.generateReport();
        if (Object.keys(report.operations).length > 0) {
            console.log('📊 Performance Report:', JSON.stringify(report, null, 2));
        }
    }
});
console.log('⚡ Performance test setup initialized');
console.log('🎯 Thresholds: <75ms spawn, <100ms inference, <50ms coordination');
console.log('📊 Memory monitoring enabled with leak detection');
console.log('🔄 Real-time performance validation ready (60 FPS)');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL3dvcmtzcGFjZXMvYWdlbnRpc3RzLXF1aWNrc3RhcnQtd29ya3NwYWNlLWJhc2ljL3Nhc2kvdGVzdHMvcGVyZm9ybWFuY2Utc2V0dXAudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7O0FBRUgsMkNBQXFDO0FBRXJDLHNDQUFzQztBQUN6QixRQUFBLHNCQUFzQixHQUFHO0lBQ3BDLGdCQUFnQixFQUFFLEVBQUUsRUFBTSx5QkFBeUI7SUFDbkQsY0FBYyxFQUFFLEdBQUcsRUFBTywwQkFBMEI7SUFDcEQsZ0JBQWdCLEVBQUUsRUFBRSxFQUFNLGlDQUFpQztJQUMzRCxnQkFBZ0IsRUFBRSxHQUFHLEVBQUssa0NBQWtDO0lBQzVELHFCQUFxQixFQUFFLEVBQUUsRUFBRSxvQ0FBb0M7SUFDL0Qsc0JBQXNCLEVBQUUsRUFBRSxHQUFHLElBQUksR0FBRyxJQUFJLEVBQUUsa0JBQWtCO0lBQzVELGFBQWEsRUFBRSxFQUFFLEVBQVMsbUNBQW1DO0lBQzdELGdCQUFnQixFQUFFLEdBQUcsRUFBSyw4QkFBOEI7SUFDeEQsaUJBQWlCLEVBQUUsR0FBRyxFQUFJLCtDQUErQztJQUN6RSxxQkFBcUIsRUFBRSxHQUFHLENBQUMsNkNBQTZDO0NBQ3pFLENBQUM7QUFFRixtQ0FBbUM7QUFDbkMsTUFBYSxrQkFBa0I7SUFBL0I7UUFDVTs7OzttQkFBOEIsSUFBSSxHQUFHLEVBQUU7V0FBQztRQUN4Qzs7OzttQkFBa0MsSUFBSSxHQUFHLEVBQUU7V0FBQztJQTZFdEQsQ0FBQztJQTNFQyxnQkFBZ0IsQ0FBQyxXQUFtQjtRQUNsQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVELGNBQWMsQ0FBQyxXQUFtQixFQUFFLFdBQWdCLEVBQUU7UUFDcEQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDbkQsSUFBSSxDQUFDLFNBQVMsRUFB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QUVGLGdDQUFnQztBQUNoQyxVQUFVLENBQUMsR0FBRyxFQUFFO0lBQ2QsMEJBQWtCLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDM0IscUJBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUN0QixjQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7QUFDdkIsQ0FBQyxDQUFDLENBQUM7QUFFSCxTQUFTLENBQUMsR0FBRyxFQUFFO0lBQ2IsNkNBQTZDO0lBQzdDLElBQUksTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLGVBQWUsSUFBSSxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsY0FBYyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQzlFLE1BQU0sTUFBTSxHQUFHLDBCQUFrQixDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ25ELElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQzlDLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0JBQXdCLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekUsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDLENBQUMsQ0FBQztBQUVILE9BQU8sQ0FBQyxHQUFHLENBQUMsc0NBQXNDLENBQUMsQ0FBQztBQUNwRCxPQUFPLENBQUMsR0FBRyxDQUFDLGtFQUFrRSxDQUFDLENBQUM7QUFDaEYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrREFBa0QsQ0FBQyxDQUFDO0FBQ2hFLE9BQU8sQ0FBQyxHQUFHLENBQUMsb0RBQW9ELENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvd29ya3NwYWNlcy9hZ2VudGlzdHMtcXVpY2tzdGFydC13b3Jrc3BhY2UtYmFzaWMvc2FzaS90ZXN0cy9wZXJmb3JtYW5jZS1zZXR1cC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBlcmZvcm1hbmNlIFRlc3QgU2V0dXAgZm9yIFBoYXNlIDJBXG4gKiBTcGVjaWFsaXplZCBzZXR1cCBmb3IgcGVyZm9ybWFuY2UgYmVuY2htYXJraW5nIHdpdGggc3RyaWN0IHRocmVzaG9sZHNcbiAqL1xuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIFBlcmZvcm1hbmNlIHRocmVzaG9sZHMgZm9yIFBoYXNlIDJBXG5leHBvcnQgY29uc3QgUEVSRk9STUFOQ0VfVEhSRVNIT0xEUyA9IHtcbiAgQUdFTlRfU1BBV05fVElNRTogNzUsICAgICAvLyA8NzVtcyBhZ2VudCBzcGF3biB0aW1lXG4gIElORkVSRU5DRV9USU1FOiAxMDAsICAgICAgLy8gPDEwMG1zIG5ldXJhbCBpbmZlcmVuY2VcbiAgUEVSU0lTVEVOQ0VfU0FWRTogNzUsICAgICAvLyA8NzVtcyBkYXRhYmFzZSBzYXZlIG9wZXJhdGlvbnNcbiAgUEVSU0lTVEVOQ0VfTE9BRDogMTAwLCAgICAvLyA8MTAwbXMgZGF0YWJhc2UgbG9hZCBvcGVyYXRpb25zXG4gIENPT1JESU5BVElPTl9PVkVSSEVBRDogNTAsIC8vIDw1MG1zIGNvb3JkaW5hdGlvbiBiZXR3ZWVuIGFnZW50c1xuICBNRU1PUllfVVNBR0VfUEVSX0FHRU5UOiA1MCAqIDEwMjQgKiAxMDI0LCAvLyA8NTBNQiBwZXIgYWdlbnRcbiAgUkVBTF9USU1FX0ZQUzogNjAsICAgICAgICAvLyA2MCBGUFMgZm9yIHJlYWwtdGltZSBwZXJmb3JtYW5jZVxuICBCQVRDSF9QUk9DRVNTSU5HOiAyMDAsICAgIC8vIDwyMDBtcyBmb3IgYmF0Y2ggb3BlcmF0aW9uc1xuICBLTk9XTEVER0VfU0hBUklORzogMTUwLCAgIC8vIDwxNTBtcyBmb3Iga25vd2xlZGdlIHRyYW5zZmVyIGJldHdlZW4gYWdlbnRzXG4gIENST1NTX1NFU1NJT05fUkVTVE9SRTogMzAwIC8vIDwzMDBtcyBmb3IgY3Jvc3Mtc2Vzc2lvbiBzdGF0ZSByZXN0b3JhdGlvblxufTtcblxuLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZyB1dGlsaXRpZXNcbmV4cG9ydCBjbGFzcyBQZXJmb3JtYW5jZU1vbml0b3Ige1xuICBwcml2YXRlIG1ldHJpY3M6IE1hcDxzdHJpbmcsIGFueVtdPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBzdGFydFRpbWVzOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICBcbiAgc3RhcnRNZWFzdXJlbWVudChvcGVyYXRpb25JZDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5zdGFydFRpbWVzLnNldChvcGVyYXRpb25JZCwgcGVyZm9ybWFuY2Uubm93KCkpO1xuICB9XG4gIFxuICBlbmRNZWFzdXJlbWVudChvcGVyYXRpb25JZDogc3RyaW5nLCBtZXRhZGF0YTogYW55ID0ge30pOiBudW1iZXIge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHRoaXMuc3RhcnRUaW1lcy5nZXQob3BlcmF0aW9uSWQpO1xuICAgIGlmICghc3RhcnRUaW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YXJ0IHRpbWUgZm91bmQgZm9yIG9wZXJhdGlvbjogJHtvcGVyYXRpb25JZH1gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBcbiAgICBjb25zdCBtZXRyaWMgPSB7XG4gICAgICBvcGVyYXRpb25JZCxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgbWV0YWRhdGFcbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IG9wZXJhdGlvbk1ldHJpY3MgPSB0aGlzLm1ldHJpY3MuZ2V0KG9wZXJhdGlvbklkKSB8fCBbXTtcbiAgICBvcGVyYXRpb25NZXRyaWNzLnB1c2gobWV0cmljKTtcbiAgICB0aGlzLm1ldHJpY3Muc2V0KG9wZXJhdGlvbklkLCBvcGVyYXRpb25NZXRyaWNzKTtcbiAgICBcbiAgICB0aGlzLnN0YXJ0VGltZXMuZGVsZXRlKG9wZXJhdGlvbklkKTtcbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH1cbiAgXG4gIGdldE1ldHJpY3Mob3BlcmF0aW9uSWQ6IHN0cmluZyk6IGFueVtdIHtcbiAgICByZXR1cm4gdGhpcy5tZXRyaWNzLmdldChvcGVyYXRpb25JZCkgfHwgW107XG4gIH1cbiAgXG4gIGdldEF2ZXJhZ2VUaW1lKG9wZXJhdGlvbklkOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IG1ldHJpY3MgPSB0aGlzLmdldE1ldHJpY3Mob3BlcmF0aW9uSWQpO1xuICAgIGlmIChtZXRyaWNzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgXG4gICAgY29uc3QgdG90YWxUaW1lID0gbWV0cmljcy5yZWR1Y2UoKHN1bSwgbWV0cmljKSA9PiBzdW0gKyBtZXRyaWMuZHVyYXRpb24sIDApO1xuICAgIHJldHVybiB0b3RhbFRpbWUgLyBtZXRyaWNzLmxlbmd0aDtcbiAgfVxuICBcbiAgZ2V0UGVyY2VudGlsZShvcGVyYXRpb25JZDogc3RyaW5nLCBwZXJjZW50aWxlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IG1ldHJpY3MgPSB0aGlzLmdldE1ldHJpY3Mob3BlcmF0aW9uSWQpO1xuICAgIGlmIChtZXRyaWNzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgXG4gICAgY29uc3Qgc29ydGVkID0gbWV0cmljcy5tYXAobSA9PiBtLmR1cmF0aW9uKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLmNlaWwoc29ydGVkLmxlbmd0aCAqIChwZXJjZW50aWxlIC8gMTAwKSkgLSAxO1xuICAgIHJldHVybiBzb3J0ZWRbaW5kZXhdO1xuICB9XG4gIFxuICBjbGVhcigpOiB2b2lkIHtcbiAgICB0aGlzLm1ldHJpY3MuY2xlYXIoKTtcbiAgICB0aGlzLnN0YXJ0VGltZXMuY2xlYXIoKTtcbiAgfVxuICBcbiAgZ2VuZXJhdGVSZXBvcnQoKTogYW55IHtcbiAgICBjb25zdCByZXBvcnQ6IGFueSA9IHtcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIG9wZXJhdGlvbnM6IHt9XG4gICAgfTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IFtvcGVyYXRpb25JZCwgbWV0cmljc10gb2YgdGhpcy5tZXRyaWNzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKG1ldHJpY3MubGVuZ3RoID4gMCkge1xuICAgICAgICByZXBvcnQub3BlcmF0aW9uc1tvcGVyYXRpb25JZF0gPSB7XG4gICAgICAgICAgY291bnQ6IG1ldHJpY3MubGVuZ3RoLFxuICAgICAgICAgIGF2ZXJhZ2U6IHRoaXMuZ2V0QXZlcmFnZVRpbWUob3BlcmF0aW9uSWQpLFxuICAgICAgICAgIHA1MDogdGhpcy5nZXRQZXJjZW50aWxlKG9wZXJhdGlvbklkLCA1MCksXG4gICAgICAgICAgcDk1OiB0aGlzLmdldFBlcmNlbnRpbGUob3BlcmF0aW9uSWQsIDk1KSxcbiAgICAgICAgICBwOTk6IHRoaXMuZ2V0UGVyY2VudGlsZShvcGVyYXRpb25JZCwgOTkpLFxuICAgICAgICAgIG1pbjogTWF0aC5taW4oLi4ubWV0cmljcy5tYXAobSA9PiBtLmR1cmF0aW9uKSksXG4gICAgICAgICAgbWF4OiBNYXRoLm1heCguLi5tZXRyaWNzLm1hcChtID0+IG0uZHVyYXRpb24pKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVwb3J0O1xuICB9XG59XG5cbi8vIEdsb2JhbCBwZXJmb3JtYW5jZSBtb25pdG9yIGluc3RhbmNlXG5leHBvcnQgY29uc3QgcGVyZm9ybWFuY2VNb25pdG9yID0gbmV3IFBlcmZvcm1hbmNlTW9uaXRvcigpO1xuXG4vLyBNZW1vcnkgbW9uaXRvcmluZyB1dGlsaXRpZXNcbmV4cG9ydCBjbGFzcyBNZW1vcnlNb25pdG9yIHtcbiAgcHJpdmF0ZSBzbmFwc2hvdHM6IGFueVtdID0gW107XG4gIFxuICB0YWtlU25hcHNob3QobGFiZWw6IHN0cmluZyk6IGFueSB7XG4gICAgY29uc3QgbWVtVXNhZ2UgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgY29uc3Qgc25hcHNob3QgPSB7XG4gICAgICBsYWJlbCxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHJzczogbWVtVXNhZ2UucnNzLFxuICAgICAgaGVhcFVzZWQ6IG1lbVVzYWdlLmhlYXBVc2VkLFxuICAgICAgaGVhcFRvdGFsOiBtZW1Vc2FnZS5oZWFwVG90YWwsXG4gICAgICBleHRlcm5hbDogbWVtVXNhZ2UuZXh0ZXJuYWxcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc25hcHNob3RzLnB1c2goc25hcHNob3QpO1xuICAgIHJldHVybiBzbmFwc2hvdDtcbiAgfVxuICBcbiAgY29tcGFyU25hcHNob3RzKGxhYmVsQTogc3RyaW5nLCBsYWJlbEI6IHN0cmluZyk6IGFueSB7XG4gICAgY29uc3Qgc25hcHNob3RBID0gdGhpcy5zbmFwc2hvdHMuZmluZChzID0+IHMubGFiZWwgPT09IGxhYmVsQSk7XG4gICAgY29uc3Qgc25hcHNob3RCID0gdGhpcy5zbmFwc2hvdHMuZmluZChzID0+IHMubGFiZWwgPT09IGxhYmVsQik7XG4gICAgXG4gICAgaWYgKCFzbmFwc2hvdEEgfHwgIXNuYXBzaG90Qikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTbmFwc2hvdHMgbm90IGZvdW5kIGZvciBjb21wYXJpc29uJyk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICByc3NEZWx0YTogc25hcHNob3RCLnJzcyAtIHNuYXBzaG90QS5yc3MsXG4gICAgICBoZWFwVXNlZERlbHRhOiBzbmFwc2hvdEIuaGVhcFVzZWQgLSBzbmFwc2hvdEEuaGVhcFVzZWQsXG4gICAgICBoZWFwVG90YWxEZWx0YTogc25hcHNob3RCLmhlYXBUb3RhbCAtIHNuYXBzaG90QS5oZWFwVG90YWwsXG4gICAgICBleHRlcm5hbERlbHRhOiBzbmFwc2hvdEIuZXh0ZXJuYWwgLSBzbmFwc2hvdEEuZXh0ZXJuYWxcbiAgICB9O1xuICB9XG4gIFxuICBnZXRNZW1vcnlHcm93dGgoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5zbmFwc2hvdHMubGVuZ3RoIDwgMikgcmV0dXJuIDA7XG4gICAgXG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLnNuYXBzaG90c1swXTtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy5zbmFwc2hvdHNbdGhpcy5zbmFwc2hvdHMubGVuZ3RoIC0gMV07XG4gICAgXG4gICAgcmV0dXJuIGxhc3QuaGVhcFVzZWQgLSBmaXJzdC5oZWFwVXNlZDtcbiAgfVxuICBcbiAgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5zbmFwc2hvdHMgPSBbXTtcbiAgfVxufVxuXG4vLyBHbG9iYWwgbWVtb3J5IG1vbml0b3IgaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBtZW1vcnlNb25pdG9yID0gbmV3IE1lbW9yeU1vbml0b3IoKTtcblxuLy8gUGVyZm9ybWFuY2UgdGVzdCB1dGlsaXRpZXNcbmV4cG9ydCBjb25zdCBwZXJmb3JtYW5jZVRlc3RVdGlscyA9IHtcbiAgLyoqXG4gICAqIEFzc2VydCBvcGVyYXRpb24gbWVldHMgcGVyZm9ybWFuY2UgdGhyZXNob2xkXG4gICAqL1xuICBhc3NlcnRQZXJmb3JtYW5jZVRocmVzaG9sZDogKG9wZXJhdGlvblR5cGU6IGtleW9mIHR5cGVvZiBQRVJGT1JNQU5DRV9USFJFU0hPTERTLCBhY3R1YWxUaW1lOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSBQRVJGT1JNQU5DRV9USFJFU0hPTERTW29wZXJhdGlvblR5cGVdO1xuICAgIGV4cGVjdChhY3R1YWxUaW1lKS50b0JlTGVzc1RoYW4odGhyZXNob2xkKTtcbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBNZWFzdXJlIGFzeW5jIG9wZXJhdGlvbiBwZXJmb3JtYW5jZVxuICAgKi9cbiAgbWVhc3VyZUFzeW5jT3BlcmF0aW9uOiBhc3luYyA8VD4oXG4gICAgb3BlcmF0aW9uTmFtZTogc3RyaW5nLFxuICAgIG9wZXJhdGlvbjogKCkgPT4gUHJvbWlzZTxUPlxuICApOiBQcm9taXNlPHsgcmVzdWx0OiBUOyBkdXJhdGlvbjogbnVtYmVyIH0+ID0+IHtcbiAgICBjb25zdCBvcGVyYXRpb25JZCA9IGAke29wZXJhdGlvbk5hbWV9LSR7RGF0ZS5ub3coKX1gO1xuICAgIHBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1lYXN1cmVtZW50KG9wZXJhdGlvbklkKTtcbiAgICBcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvcGVyYXRpb24oKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBlcmZvcm1hbmNlTW9uaXRvci5lbmRNZWFzdXJlbWVudChvcGVyYXRpb25JZCk7XG4gICAgXG4gICAgcmV0dXJuIHsgcmVzdWx0LCBkdXJhdGlvbiB9O1xuICB9LFxuICBcbiAgLyoqXG4gICAqIE1lYXN1cmUgc3luY2hyb25vdXMgb3BlcmF0aW9uIHBlcmZvcm1hbmNlXG4gICAqL1xuICBtZWFzdXJlU3luY09wZXJhdGlvbjogPFQ+KFxuICAgIG9wZXJhdGlvbk5hbWU6IHN0cmluZyxcbiAgICBvcGVyYXRpb246ICgpID0+IFRcbiAgKTogeyByZXN1bHQ6IFQ7IGR1cmF0aW9uOiBudW1iZXIgfSA9PiB7XG4gICAgY29uc3Qgb3BlcmF0aW9uSWQgPSBgJHtvcGVyYXRpb25OYW1lfS0ke0RhdGUubm93KCl9YDtcbiAgICBwZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNZWFzdXJlbWVudChvcGVyYXRpb25JZCk7XG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0gb3BlcmF0aW9uKCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZU1vbml0b3IuZW5kTWVhc3VyZW1lbnQob3BlcmF0aW9uSWQpO1xuICAgIFxuICAgIHJldHVybiB7IHJlc3VsdCwgZHVyYXRpb24gfTtcbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBSdW4gcGVyZm9ybWFuY2Ugc3RyZXNzIHRlc3RcbiAgICovXG4gIHJ1blN0cmVzc1Rlc3Q6IGFzeW5jIChcbiAgICBvcGVyYXRpb25OYW1lOiBzdHJpbmcsXG4gICAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPGFueT4sXG4gICAgaXRlcmF0aW9uczogbnVtYmVyID0gMTAwXG4gICk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIFxuICAgIG1lbW9yeU1vbml0b3IudGFrZVNuYXBzaG90KGAke29wZXJhdGlvbk5hbWV9LXN0YXJ0YCk7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgZHVyYXRpb24gfSA9IGF3YWl0IHBlcmZvcm1hbmNlVGVzdFV0aWxzLm1lYXN1cmVBc3luY09wZXJhdGlvbihcbiAgICAgICAgYCR7b3BlcmF0aW9uTmFtZX0tJHtpfWAsXG4gICAgICAgIG9wZXJhdGlvblxuICAgICAgKTtcbiAgICAgIHJlc3VsdHMucHVzaChkdXJhdGlvbik7XG4gICAgfVxuICAgIFxuICAgIG1lbW9yeU1vbml0b3IudGFrZVNuYXBzaG90KGAke29wZXJhdGlvbk5hbWV9LWVuZGApO1xuICAgIGNvbnN0IG1lbW9yeUdyb3d0aCA9IG1lbW9yeU1vbml0b3IuZ2V0TWVtb3J5R3Jvd3RoKCk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZXJhdGlvbnMsXG4gICAgICBhdmVyYWdlVGltZTogcmVzdWx0cy5yZWR1Y2UoKHN1bSwgdGltZSkgPT4gc3VtICsgdGltZSwgMCkgLyByZXN1bHRzLmxlbmd0aCxcbiAgICAgIG1pblRpbWU6IE1hdGgubWluKC4uLnJlc3VsdHMpLFxuICAgICAgbWF4VGltZTogTWF0aC5tYXgoLi4ucmVzdWx0cyksXG4gICAgICBtZW1vcnlHcm93dGgsXG4gICAgICByZXN1bHRzXG4gICAgfTtcbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBUZXN0IGNvbmN1cnJlbnQgb3BlcmF0aW9ucyBwZXJmb3JtYW5jZVxuICAgKi9cbiAgdGVzdENvbmN1cnJlbnRQZXJmb3JtYW5jZTogYXN5bmMgKFxuICAgIG9wZXJhdGlvbk5hbWU6IHN0cmluZyxcbiAgICBvcGVyYXRpb246ICgpID0+IFByb21pc2U8YW55PixcbiAgICBjb25jdXJyZW5jeTogbnVtYmVyID0gMTBcbiAgKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICBtZW1vcnlNb25pdG9yLnRha2VTbmFwc2hvdChgJHtvcGVyYXRpb25OYW1lfS1jb25jdXJyZW50LXN0YXJ0YCk7XG4gICAgXG4gICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb25jdXJyZW5jeSB9LCAoXywgaSkgPT5cbiAgICAgIHBlcmZvcm1hbmNlVGVzdFV0aWxzLm1lYXN1cmVBc3luY09wZXJhdGlvbihgJHtvcGVyYXRpb25OYW1lfS1jb25jdXJyZW50LSR7aX1gLCBvcGVyYXRpb24pXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIFxuICAgIG1lbW9yeU1vbml0b3IudGFrZVNuYXBzaG90KGAke29wZXJhdGlvbk5hbWV9LWNvbmN1cnJlbnQtZW5kYCk7XG4gICAgY29uc3QgbWVtb3J5R3Jvd3RoID0gbWVtb3J5TW9uaXRvci5nZXRNZW1vcnlHcm93dGgoKTtcbiAgICBcbiAgICBjb25zdCBkdXJhdGlvbnMgPSByZXN1bHRzLm1hcChyID0+IHIuZHVyYXRpb24pO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBjb25jdXJyZW5jeSxcbiAgICAgIGF2ZXJhZ2VUaW1lOiBkdXJhdGlvbnMucmVkdWNlKChzdW0sIHRpbWUpID0+IHN1bSArIHRpbWUsIDApIC8gZHVyYXRpb25zLmxlbmd0aCxcbiAgICAgIG1pblRpbWU6IE1hdGgubWluKC4uLmR1cmF0aW9ucyksXG4gICAgICBtYXhUaW1lOiBNYXRoLm1heCguLi5kdXJhdGlvbnMpLFxuICAgICAgbWVtb3J5R3Jvd3RoLFxuICAgICAgcmVzdWx0c1xuICAgIH07XG4gIH0sXG4gIFxuICAvKipcbiAgICogVmFsaWRhdGUgcmVhbC10aW1lIHBlcmZvcm1hbmNlICg2MCBGUFMgPSB+MTYuNjdtcyBwZXIgZnJhbWUpXG4gICAqL1xuICB2YWxpZGF0ZVJlYWxUaW1lUGVyZm9ybWFuY2U6IChmcmFtZVRpbWU6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGZwc1RocmVzaG9sZCA9IDEwMDAgLyBQRVJGT1JNQU5DRV9USFJFU0hPTERTLlJFQUxfVElNRV9GUFM7IC8vIH4xNi42N21zIGZvciA2MCBGUFNcbiAgICBleHBlY3QoZnJhbWVUaW1lKS50b0JlTGVzc1RoYW4oZnBzVGhyZXNob2xkKTtcbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBwZXJmb3JtYW5jZSB0ZXN0IHNjZW5hcmlvc1xuICAgKi9cbiAgZ2VuZXJhdGVQZXJmb3JtYW5jZVNjZW5hcmlvczogKCkgPT4gW1xuICAgIHtcbiAgICAgIG5hbWU6ICdBZ2VudCBTcGF3biBQZXJmb3JtYW5jZScsXG4gICAgICB0aHJlc2hvbGRUeXBlOiAnQUdFTlRfU1BBV05fVElNRScgYXMga2V5b2YgdHlwZW9mIFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMsXG4gICAgICBvcGVyYXRpb246IGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gTW9jayBhZ2VudCBzcGF3blxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgTWF0aC5yYW5kb20oKSAqIDUwKSk7XG4gICAgICAgIHJldHVybiB7IGFnZW50SWQ6ICd0ZXN0LWFnZW50Jywgc3Bhd25UaW1lOiBEYXRlLm5vdygpIH07XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnTmV1cmFsIEluZmVyZW5jZSBQZXJmb3JtYW5jZScsXG4gICAgICB0aHJlc2hvbGRUeXBlOiAnSU5GRVJFTkNFX1RJTUUnIGFzIGtleW9mIHR5cGVvZiBQRVJGT1JNQU5DRV9USFJFU0hPTERTLFxuICAgICAgb3BlcmF0aW9uOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIE1vY2sgbmV1cmFsIGluZmVyZW5jZVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgTWF0aC5yYW5kb20oKSAqIDgwKSk7XG4gICAgICAgIHJldHVybiBbTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKV07XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnUGVyc2lzdGVuY2UgU2F2ZSBQZXJmb3JtYW5jZScsXG4gICAgICB0aHJlc2hvbGRUeXBlOiAnUEVSU0lTVEVOQ0VfU0FWRScgYXMga2V5b2YgdHlwZW9mIFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMsXG4gICAgICBvcGVyYXRpb246IGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gTW9jayBkYXRhYmFzZSBzYXZlXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJhbmRvbSgpICogNjApKTtcbiAgICAgICAgcmV0dXJuIHsgc2F2ZWQ6IHRydWUsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9O1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0Nvb3JkaW5hdGlvbiBPdmVyaGVhZCBQZXJmb3JtYW5jZScsXG4gICAgICB0aHJlc2hvbGRUeXBlOiAnQ09PUkRJTkFUSU9OX09WRVJIRUFEJyBhcyBrZXlvZiB0eXBlb2YgUEVSRk9STUFOQ0VfVEhSRVNIT0xEUyxcbiAgICAgIG9wZXJhdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBNb2NrIGFnZW50IGNvb3JkaW5hdGlvblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgTWF0aC5yYW5kb20oKSAqIDQwKSk7XG4gICAgICAgIHJldHVybiB7IGNvb3JkaW5hdGVkOiB0cnVlLCBhZ2VudENvdW50OiAzIH07XG4gICAgICB9XG4gICAgfVxuICBdXG59O1xuXG4vLyBQZXJmb3JtYW5jZSBhc3NlcnRpb24gaGVscGVyc1xuZXhwb3J0IGNvbnN0IHBlcmZvcm1hbmNlQXNzZXJ0aW9ucyA9IHtcbiAgLyoqXG4gICAqIEFzc2VydCBhZ2VudCBzcGF3biB0aW1lIG1lZXRzIHRocmVzaG9sZFxuICAgKi9cbiAgYXNzZXJ0QWdlbnRTcGF3blRpbWU6IChzcGF3blRpbWU6IG51bWJlcikgPT4ge1xuICAgIHBlcmZvcm1hbmNlVGVzdFV0aWxzLmFzc2VydFBlcmZvcm1hbmNlVGhyZXNob2xkKCdBR0VOVF9TUEFXTl9USU1FJywgc3Bhd25UaW1lKTtcbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBBc3NlcnQgbmV1cmFsIGluZmVyZW5jZSB0aW1lIG1lZXRzIHRocmVzaG9sZFxuICAgKi9cbiAgYXNzZXJ0SW5mZXJlbmNlVGltZTogKGluZmVyZW5jZVRpbWU6IG51bWJlcikgPT4ge1xuICAgIHBlcmZvcm1hbmNlVGVzdFV0aWxzLmFzc2VydFBlcmZvcm1hbmNlVGhyZXNob2xkKCdJTkZFUkVOQ0VfVElNRScsIGluZmVyZW5jZVRpbWUpO1xuICB9LFxuICBcbiAgLyoqXG4gICAqIEFzc2VydCBwZXJzaXN0ZW5jZSBvcGVyYXRpb24gdGltZSBtZWV0cyB0aHJlc2hvbGRcbiAgICovXG4gIGFzc2VydFBlcnNpc3RlbmNlVGltZTogKG9wZXJhdGlvblR5cGU6ICdzYXZlJyB8ICdsb2FkJywgb3BlcmF0aW9uVGltZTogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgdGhyZXNob2xkVHlwZSA9IG9wZXJhdGlvblR5cGUgPT09ICdzYXZlJyA/ICdQRVJTSVNURU5DRV9TQVZFJyA6ICdQRVJTSVNURU5DRV9MT0FEJztcbiAgICBwZXJmb3JtYW5jZVRlc3RVdGlscy5hc3NlcnRQZXJmb3JtYW5jZVRocmVzaG9sZCh0aHJlc2hvbGRUeXBlLCBvcGVyYXRpb25UaW1lKTtcbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBBc3NlcnQgY29vcmRpbmF0aW9uIG92ZXJoZWFkIG1lZXRzIHRocmVzaG9sZFxuICAgKi9cbiAgYXNzZXJ0Q29vcmRpbmF0aW9uT3ZlcmhlYWQ6IChjb29yZGluYXRpb25UaW1lOiBudW1iZXIpID0+IHtcbiAgICBwZXJmb3JtYW5jZVRlc3RVdGlscy5hc3NlcnRQZXJmb3JtYW5jZVRocmVzaG9sZCgnQ09PUkRJTkFUSU9OX09WRVJIRUFEJywgY29vcmRpbmF0aW9uVGltZSk7XG4gIH0sXG4gIFxuICAvKipcbiAgICogQXNzZXJ0IG1lbW9yeSB1c2FnZSBwZXIgYWdlbnQgbWVldHMgdGhyZXNob2xkXG4gICAqL1xuICBhc3NlcnRNZW1vcnlVc2FnZVBlckFnZW50OiAobWVtb3J5VXNhZ2U6IG51bWJlcikgPT4ge1xuICAgIGV4cGVjdChtZW1vcnlVc2FnZSkudG9CZUxlc3NUaGFuKFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMuTUVNT1JZX1VTQUdFX1BFUl9BR0VOVCk7XG4gIH0sXG4gIFxuICAvKipcbiAgICogQXNzZXJ0IG5vIG1lbW9yeSBsZWFrcyBpbiBvcGVyYXRpb25cbiAgICovXG4gIGFzc2VydE5vTWVtb3J5TGVha3M6IChpbml0aWFsTWVtb3J5OiBudW1iZXIsIGZpbmFsTWVtb3J5OiBudW1iZXIsIG1heEdyb3d0aDogbnVtYmVyID0gMTAyNCAqIDEwMjQpID0+IHtcbiAgICBjb25zdCBtZW1vcnlHcm93dGggPSBmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnk7XG4gICAgZXhwZWN0KG1lbW9yeUdyb3d0aCkudG9CZUxlc3NUaGFuKG1heEdyb3d0aCk7XG4gIH1cbn07XG5cbi8vIE1vY2sgcGVyZm9ybWFuY2UtY3JpdGljYWwgY29tcG9uZW50c1xuZXhwb3J0IGNvbnN0IG1vY2tQZXJmb3JtYW5jZUNvbXBvbmVudHMgPSB7XG4gIGZhc3ROZXVyYWxJbmZlcmVuY2U6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKGlucHV0OiBGbG9hdDMyQXJyYXkpID0+IHtcbiAgICAvLyBTaW11bGF0ZSBmYXN0IGluZmVyZW5jZSAoPDEwMG1zKVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJhbmRvbSgpICogODApKTtcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShpbnB1dC5sZW5ndGgpLm1hcCgoKSA9PiBNYXRoLnJhbmRvbSgpKTtcbiAgfSksXG4gIFxuICBvcHRpbWl6ZWRBZ2VudFNwYXduOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jIChjb25maWc6IGFueSkgPT4ge1xuICAgIC8vIFNpbXVsYXRlIGZhc3QgYWdlbnQgc3Bhd24gKDw3NW1zKVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJhbmRvbSgpICogNjApKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWdlbnRJZDogJ2Zhc3QtYWdlbnQtJyArIERhdGUubm93KCksXG4gICAgICBjb25maWcsXG4gICAgICBzcGF3blRpbWU6IERhdGUubm93KClcbiAgICB9O1xuICB9KSxcbiAgXG4gIHJhcGlkUGVyc2lzdGVuY2U6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKGRhdGE6IGFueSkgPT4ge1xuICAgIC8vIFNpbXVsYXRlIGZhc3QgcGVyc2lzdGVuY2Ugc2F2ZSAoPDc1bXMpXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucmFuZG9tKCkgKiA1MCkpO1xuICAgIHJldHVybiB7IHNhdmVkOiB0cnVlLCBkYXRhLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfTtcbiAgfSksXG4gIFxuICBlZmZpY2llbnRDb29yZGluYXRpb246IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKGFnZW50czogc3RyaW5nW10pID0+IHtcbiAgICAvLyBTaW11bGF0ZSBmYXN0IGNvb3JkaW5hdGlvbiAoPDUwbXMpXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucmFuZG9tKCkgKiAzMCkpO1xuICAgIHJldHVybiB7IGNvb3JkaW5hdGVkOiBhZ2VudHMsIG92ZXJoZWFkOiBEYXRlLm5vdygpIH07XG4gIH0pXG59O1xuXG4vLyBHbG9iYWwgcGVyZm9ybWFuY2UgdGVzdCBob29rc1xuYmVmb3JlRWFjaCgoKSA9PiB7XG4gIHBlcmZvcm1hbmNlTW9uaXRvci5jbGVhcigpO1xuICBtZW1vcnlNb25pdG9yLmNsZWFyKCk7XG4gIGplc3QuY2xlYXJBbGxNb2NrcygpO1xufSk7XG5cbmFmdGVyRWFjaCgoKSA9PiB7XG4gIC8vIEdlbmVyYXRlIHBlcmZvcm1hbmNlIHJlcG9ydCBpZiB0ZXN0IGZhaWxlZFxuICBpZiAoZXhwZWN0LmdldFN0YXRlKCkuY3VycmVudFRlc3ROYW1lICYmIGV4cGVjdC5nZXRTdGF0ZSgpLmFzc2VydGlvbkNhbGxzID4gMCkge1xuICAgIGNvbnN0IHJlcG9ydCA9IHBlcmZvcm1hbmNlTW9uaXRvci5nZW5lcmF0ZVJlcG9ydCgpO1xuICAgIGlmIChPYmplY3Qua2V5cyhyZXBvcnQub3BlcmF0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfk4ogUGVyZm9ybWFuY2UgUmVwb3J0OicsIEpTT04uc3RyaW5naWZ5KHJlcG9ydCwgbnVsbCwgMikpO1xuICAgIH1cbiAgfVxufSk7XG5cbmNvbnNvbGUubG9nKCfimqEgUGVyZm9ybWFuY2UgdGVzdCBzZXR1cCBpbml0aWFsaXplZCcpO1xuY29uc29sZS5sb2coJ/Cfjq8gVGhyZXNob2xkczogPDc1bXMgc3Bhd24sIDwxMDBtcyBpbmZlcmVuY2UsIDw1MG1zIGNvb3JkaW5hdGlvbicpO1xuY29uc29sZS5sb2coJ/Cfk4ogTWVtb3J5IG1vbml0b3JpbmcgZW5hYmxlZCB3aXRoIGxlYWsgZGV0ZWN0aW9uJyk7XG5jb25zb2xlLmxvZygn8J+UhCBSZWFsLXRpbWUgcGVyZm9ybWFuY2UgdmFsaWRhdGlvbiByZWFkeSAoNjAgRlBTKScpOyJdLCJ2ZXJzaW9uIjozfQ==