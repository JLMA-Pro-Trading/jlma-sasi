{"file":"/workspaces/agentists-quickstart-workspace-basic/sasi/tests/performance-setup.ts","mappings":";AAAA;;;GAGG;;;AAEH,2CAAqC;AAErC,sCAAsC;AACzB,QAAA,sBAAsB,GAAG;IACpC,gBAAgB,EAAE,EAAE,EAAM,yBAAyB;IACnD,cAAc,EAAE,GAAG,EAAO,0BAA0B;IACpD,gBAAgB,EAAE,EAAE,EAAM,iCAAiC;IAC3D,gBAAgB,EAAE,GAAG,EAAK,kCAAkC;IAC5D,qBAAqB,EAAE,EAAE,EAAE,oCAAoC;IAC/D,sBAAsB,EAAE,EAAE,GAAG,IAAI,GAAG,IAAI,EAAE,kBAAkB;IAC5D,aAAa,EAAE,EAAE,EAAS,mCAAmC;IAC7D,gBAAgB,EAAE,GAAG,EAAK,8BAA8B;IACxD,iBAAiB,EAAE,GAAG,EAAI,+CAA+C;IACzE,qBAAqB,EAAE,GAAG,CAAC,6CAA6C;CACzE,CAAC;AAEF,mCAAmC;AACnC,MAAa,kBAAkB;IAA/B;QACU;;;;mBAA8B,IAAI,GAAG,EAAE;WAAC;QACxC;;;;mBAAkC,IAAI,GAAG,EAAE;WAAC;IA6EtD,CAAC;IA3EC,gBAAgB,CAAC,WAAmB;QAClC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,WAAW,EAAE,WAAW,CAAC,GAAG,EAAE,CAAC,CAAC;IACtD,CAAC;IAED,cAAc,CAAC,WAAmB,EAAE,WAAgB,EAAE;QACpD,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QACnD,IAAI,CAAC,SAAS,EAAE,CAAC;YACf,MAAM,IAAI,KAAK,CAAC,sCAAsC,WAAW,EAAE,CAAC,CAAC;QACvE,CAAC;QAED,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC;QAE/C,MAAM,MAAM,GAAG;YACb,WAAW;YACX,QAAQ;YACR,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;YACrB,QAAQ;SACT,CAAC;QAEF,MAAM,gBAAgB,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;QAC7D,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC9B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,WAAW,EAAE,gBAAgB,CAAC,CAAC;QAEhD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QACpC,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,UAAU,CAAC,WAAmB;QAC5B,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;IAC7C,CAAC;IAED,cAAc,CAAC,WAAmB;QAChC,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAC7C,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO,CAAC,CAAC;QAEnC,MAAM,SAAS,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,MAAM,EAAE,EAAE,CAAC,GAAG,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;QAC5E,OAAO,SAAS,GAAG,OAAO,CAAC,MAAM,CAAC;IACpC,CAAC;IAED,aAAa,CAAC,WAAmB,EAAE,UAAkB;QACnD,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAC7C,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO,CAAC,CAAC;QAEnC,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAClE,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,UAAU,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QAChE,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;IACvB,CAAC;IAED,KAAK;QACH,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;QACrB,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;IAC1B,CAAC;IAED,cAAc;QACZ,MAAM,MAAM,GAAQ;YAClB,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;YACrB,UAAU,EAAE,EAAE;SACf,CAAC;QAEF,KAAK,MAAM,CAAC,WAAW,EAAE,OAAO,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;YAC5D,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACvB,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,GAAG;oBAC/B,KAAK,EAAE,OAAO,CAAC,MAAM;oBACrB,OAAO,EAAE,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC;oBACzC,GAAG,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,EAAE,CAAC;oBACxC,GAAG,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,EAAE,CAAC;oBACxC,GAAG,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,EAAE,CAAC;oBACxC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;oBAC9C,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;iBAC/C,CAAC;YACJ,CAAC;QACH,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA/ED,gDA+EC;AAED,sCAAsC;AACzB,QAAA,kBAAkB,GAAG,IAAI,kBAAkB,EAAE,CAAC;AAE3D,8BAA8B;AAC9B,MAAa,aAAa;IAA1B;QACU;;;;mBAAmB,EAAE;WAAC;IA6ChC,CAAC;IA3CC,YAAY,CAAC,KAAa;QACxB,MAAM,QAAQ,GAAG,OAAO,CAAC,WAAW,EAAE,CAAC;QACvC,MAAM,QAAQ,GAAG;YACf,KAAK;YACL,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;YACrB,GAAG,EAAE,QAAQ,CAAC,GAAG;YACjB,QAAQ,EAAE,QAAQ,CAAC,QAAQ;YAC3B,SAAS,EAAE,QAAQ,CAAC,SAAS;YAC7B,QAAQ,EAAE,QAAQ,CAAC,QAAQ;SAC5B,CAAC;QAEF,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC9B,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,eAAe,CAAC,MAAc,EAAE,MAAc;QAC5C,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,CAAC;QAC/D,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,CAAC;QAE/D,IAAI,CAAC,SAAS,IAAI,CAAC,SAAS,EAAE,CAAC;YAC7B,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;QACxD,CAAC;QAED,OAAO;YACL,QAAQ,EAAE,SAAS,CAAC,GAAG,GAAG,SAAS,CAAC,GAAG;YACvC,aAAa,EAAE,SAAS,CAAC,QAAQ,GAAG,SAAS,CAAC,QAAQ;YACtD,cAAc,EAAE,SAAS,CAAC,SAAS,GAAG,SAAS,CAAC,SAAS;YACzD,aAAa,EAAE,SAAS,CAAC,QAAQ,GAAG,SAAS,CAAC,QAAQ;SACvD,CAAC;IACJ,CAAC;IAED,eAAe;QACb,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC;YAAE,OAAO,CAAC,CAAC;QAExC,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QAChC,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAEvD,OAAO,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;IACxC,CAAC;IAED,KAAK;QACH,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;IACtB,CAAC;CACF;AA9CD,sCA8CC;AAED,iCAAiC;AACpB,QAAA,aAAa,GAAG,IAAI,aAAa,EAAE,CAAC;AAEjD,6BAA6B;AAChB,QAAA,oBAAoB,GAAG;IAClC;;OAEG;IACH,0BAA0B,EAAE,CAAC,aAAkD,EAAE,UAAkB,EAAE,EAAE;QACrG,MAAM,SAAS,GAAG,8BAAsB,CAAC,aAAa,CAAC,CAAC;QACxD,MAAM,CAAC,UAAU,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;IAC7C,CAAC;IAED;;OAEG;IACH,qBAAqB,EAAE,KAAK,EAC1B,aAAqB,EACrB,SAA2B,EACe,EAAE;QAC5C,MAAM,WAAW,GAAG,GAAG,aAAa,IAAI,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC;QACrD,0BAAkB,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC;QAEjD,MAAM,MAAM,GAAG,MAAM,SAAS,EAAE,CAAC;QACjC,MAAM,QAAQ,GAAG,0BAAkB,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;QAEhE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC;IAC9B,CAAC;IAED;;OAEG;IACH,oBAAoB,EAAE,CACpB,aAAqB,EACrB,SAAkB,EACe,EAAE;QACnC,MAAM,WAAW,GAAG,GAAG,aAAa,IAAI,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC;QACrD,0BAAkB,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC;QAEjD,MAAM,MAAM,GAAG,SAAS,EAAE,CAAC;QAC3B,MAAM,QAAQ,GAAG,0BAAkB,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;QAEhE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC;IAC9B,CAAC;IAED;;OAEG;IACH,aAAa,EAAE,KAAK,EAClB,aAAqB,EACrB,SAA6B,EAC7B,aAAqB,GAAG,EACV,EAAE;QAChB,MAAM,OAAO,GAAG,EAAE,CAAC;QAEnB,qBAAa,CAAC,YAAY,CAAC,GAAG,aAAa,QAAQ,CAAC,CAAC;QAErD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE,CAAC;YACpC,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,4BAAoB,CAAC,qBAAqB,CACnE,GAAG,aAAa,IAAI,CAAC,EAAE,EACvB,SAAS,CACV,CAAC;YACF,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACzB,CAAC;QAED,qBAAa,CAAC,YAAY,CAAC,GAAG,aAAa,MAAM,CAAC,CAAC;QACnD,MAAM,YAAY,GAAG,qBAAa,CAAC,eAAe,EAAE,CAAC;QAErD,OAAO;YACL,UAAU;YACV,WAAW,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE,CAAC,GAAG,GAAG,IAAI,EAAE,CAAC,CAAC,GAAG,OAAO,CAAC,MAAM;YAC1E,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC;YAC7B,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC;YAC7B,YAAY;YACZ,OAAO;SACR,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,yBAAyB,EAAE,KAAK,EAC9B,aAAqB,EACrB,SAA6B,EAC7B,cAAsB,EAAE,EACV,EAAE;QAChB,qBAAa,CAAC,YAAY,CAAC,GAAG,aAAa,mBAAmB,CAAC,CAAC;QAEhE,MAAM,QAAQ,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,WAAW,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAC5D,4BAAoB,CAAC,qBAAqB,CAAC,GAAG,aAAa,eAAe,CAAC,EAAE,EAAE,SAAS,CAAC,CAC1F,CAAC;QAEF,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAE5C,qBAAa,CAAC,YAAY,CAAC,GAAG,aAAa,iBAAiB,CAAC,CAAC;QAC9D,MAAM,YAAY,GAAG,qBAAa,CAAC,eAAe,EAAE,CAAC;QAErD,MAAM,SAAS,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;QAE/C,OAAO;YACL,WAAW;YACX,WAAW,EAAE,SAAS,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE,CAAC,GAAG,GAAG,IAAI,EAAE,CAAC,CAAC,GAAG,SAAS,CAAC,MAAM;YAC9E,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC;YAC/B,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC;YAC/B,YAAY;YACZ,OAAO;SACR,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,2BAA2B,EAAE,CAAC,SAAiB,EAAE,EAAE;QACjD,MAAM,YAAY,GAAG,IAAI,GAAG,8BAAsB,CAAC,aAAa,CAAC,CAAC,sBAAsB;QACxF,MAAM,CAAC,SAAS,CAAC,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;IAC/C,CAAC;IAED;;OAEG;IACH,4BAA4B,EAAE,GAAG,EAAE,CAAC;QAClC;YACE,IAAI,EAAE,yBAAyB;YAC/B,aAAa,EAAE,kBAAyD;YACxE,SAAS,EAAE,KAAK,IAAI,EAAE;gBACpB,mBAAmB;gBACnB,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;gBACtE,OAAO,EAAE,OAAO,EAAE,YAAY,EAAE,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC;YAC1D,CAAC;SACF;QACD;YACE,IAAI,EAAE,8BAA8B;YACpC,aAAa,EAAE,gBAAuD;YACtE,SAAS,EAAE,KAAK,IAAI,EAAE;gBACpB,wBAAwB;gBACxB,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;gBACtE,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,IAAI,CAAC,MAAM,EAAE,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;YACvD,CAAC;SACF;QACD;YACE,IAAI,EAAE,8BAA8B;YACpC,aAAa,EAAE,kBAAyD;YACxE,SAAS,EAAE,KAAK,IAAI,EAAE;gBACpB,qBAAqB;gBACrB,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;gBACtE,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC;YAChD,CAAC;SACF;QACD;YACE,IAAI,EAAE,mCAAmC;YACzC,aAAa,EAAE,uBAA8D;YAC7E,SAAS,EAAE,KAAK,IAAI,EAAE;gBACpB,0BAA0B;gBAC1B,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;gBACtE,OAAO,EAAE,WAAW,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC;YAC9C,CAAC;SACF;KACF;CACF,CAAC;AAEF,gCAAgC;AACnB,QAAA,qBAAqB,GAAG;IACnC;;OAEG;IACH,oBAAoB,EAAE,CAAC,SAAiB,EAAE,EAAE;QAC1C,4BAAoB,CAAC,0BAA0B,CAAC,kBAAkB,EAAE,SAAS,CAAC,CAAC;IACjF,CAAC;IAED;;OAEG;IACH,mBAAmB,EAAE,CAAC,aAAqB,EAAE,EAAE;QAC7C,4BAAoB,CAAC,0BAA0B,CAAC,gBAAgB,EAAE,aAAa,CAAC,CAAC;IACnF,CAAC;IAED;;OAEG;IACH,qBAAqB,EAAE,CAAC,aAA8B,EAAE,aAAqB,EAAE,EAAE;QAC/E,MAAM,aAAa,GAAG,aAAa,KAAK,MAAM,CAAC,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC,kBAAkB,CAAC;QACzF,4BAAoB,CAAC,0BAA0B,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;IAChF,CAAC;IAED;;OAEG;IACH,0BAA0B,EAAE,CAAC,gBAAwB,EAAE,EAAE;QACvD,4BAAoB,CAAC,0BAA0B,CAAC,uBAAuB,EAAE,gBAAgB,CAAC,CAAC;IAC7F,CAAC;IAED;;OAEG;IACH,yBAAyB,EAAE,CAAC,WAAmB,EAAE,EAAE;QACjD,MAAM,CAAC,WAAW,CAAC,CAAC,YAAY,CAAC,8BAAsB,CAAC,sBAAsB,CAAC,CAAC;IAClF,CAAC;IAED;;OAEG;IACH,mBAAmB,EAAE,CAAC,aAAqB,EAAE,WAAmB,EAAE,YAAoB,IAAI,GAAG,IAAI,EAAE,EAAE;QACnG,MAAM,YAAY,GAAG,WAAW,GAAG,aAAa,CAAC;QACjD,MAAM,CAAC,YAAY,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;IAC/C,CAAC;CACF,CAAC;AAEF,uCAAuC;AAC1B,QAAA,yBAAyB,GAAG;IACvC,mBAAmB,EAAE,cAAI,CAAC,EAAE,EAAE,CAAC,kBAAkB,CAAC,KAAK,EAAE,KAAmB,EAAE,EAAE;QAC9E,mCAAmC;QACnC,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;QACtE,OAAO,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;IACjE,CAAC,CAAC;IAEF,mBAAmB,EAAE,cAAI,CAAC,EAAE,EAAE,CAAC,kBAAkB,CAAC,KAAK,EAAE,MAAW,EAAE,EAAE;QACtE,oCAAoC;QACpC,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;QACtE,OAAO;YACL,OAAO,EAAE,aAAa,GAAG,IAAI,CAAC,GAAG,EAAE;YACnC,MAAM;YACN,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;SACtB,CAAC;IACJ,CAAC,CAAC;IAEF,gBAAgB,EAAE,cAAI,CAAC,EAAE,EAAE,CAAC,kBAAkB,CAAC,KAAK,EAAE,IAAS,EAAE,EAAE;QACjE,yCAAyC;QACzC,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;QACtE,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC;IACtD,CAAC,CAAC;IAEF,qBAAqB,EAAE,cAAI,CAAC,EAAE,EAAE,CAAC,kBAAkB,CAAC,KAAK,EAAE,MAAgB,EAAE,EAAE;QAC7E,qCAAqC;QACrC,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;QACtE,OAAO,EAAE,WAAW,EAAE,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC,GAAG,EAAE,EAAE,CAAC;IACvD,CAAC,CAAC;CACH,CAAC;AAEF,gCAAgC;AAChC,UAAU,CAAC,GAAG,EAAE;IACd,0BAAkB,CAAC,KAAK,EAAE,CAAC;IAC3B,qBAAa,CAAC,KAAK,EAAE,CAAC;IACtB,cAAI,CAAC,aAAa,EAAE,CAAC;AACvB,CAAC,CAAC,CAAC;AAEH,SAAS,CAAC,GAAG,EAAE;IACb,6CAA6C;IAC7C,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC,eAAe,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC,cAAc,GAAG,CAAC,EAAE,CAAC;QAC9E,MAAM,MAAM,GAAG,0BAAkB,CAAC,cAAc,EAAE,CAAC;QACnD,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC9C,OAAO,CAAC,GAAG,CAAC,wBAAwB,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;QACzE,CAAC;IACH,CAAC;AACH,CAAC,CAAC,CAAC;AAEH,OAAO,CAAC,GAAG,CAAC,sCAAsC,CAAC,CAAC;AACpD,OAAO,CAAC,GAAG,CAAC,kEAAkE,CAAC,CAAC;AAChF,OAAO,CAAC,GAAG,CAAC,kDAAkD,CAAC,CAAC;AAChE,OAAO,CAAC,GAAG,CAAC,oDAAoD,CAAC,CAAC","names":[],"sources":["/workspaces/agentists-quickstart-workspace-basic/sasi/tests/performance-setup.ts"],"sourcesContent":["/**\n * Performance Test Setup for Phase 2A\n * Specialized setup for performance benchmarking with strict thresholds\n */\n\nimport { jest } from '@jest/globals';\n\n// Performance thresholds for Phase 2A\nexport const PERFORMANCE_THRESHOLDS = {\n  AGENT_SPAWN_TIME: 75,     // <75ms agent spawn time\n  INFERENCE_TIME: 100,      // <100ms neural inference\n  PERSISTENCE_SAVE: 75,     // <75ms database save operations\n  PERSISTENCE_LOAD: 100,    // <100ms database load operations\n  COORDINATION_OVERHEAD: 50, // <50ms coordination between agents\n  MEMORY_USAGE_PER_AGENT: 50 * 1024 * 1024, // <50MB per agent\n  REAL_TIME_FPS: 60,        // 60 FPS for real-time performance\n  BATCH_PROCESSING: 200,    // <200ms for batch operations\n  KNOWLEDGE_SHARING: 150,   // <150ms for knowledge transfer between agents\n  CROSS_SESSION_RESTORE: 300 // <300ms for cross-session state restoration\n};\n\n// Performance monitoring utilities\nexport class PerformanceMonitor {\n  private metrics: Map<string, any[]> = new Map();\n  private startTimes: Map<string, number> = new Map();\n  \n  startMeasurement(operationId: string): void {\n    this.startTimes.set(operationId, performance.now());\n  }\n  \n  endMeasurement(operationId: string, metadata: any = {}): number {\n    const startTime = this.startTimes.get(operationId);\n    if (!startTime) {\n      throw new Error(`No start time found for operation: ${operationId}`);\n    }\n    \n    const duration = performance.now() - startTime;\n    \n    const metric = {\n      operationId,\n      duration,\n      timestamp: Date.now(),\n      metadata\n    };\n    \n    const operationMetrics = this.metrics.get(operationId) || [];\n    operationMetrics.push(metric);\n    this.metrics.set(operationId, operationMetrics);\n    \n    this.startTimes.delete(operationId);\n    return duration;\n  }\n  \n  getMetrics(operationId: string): any[] {\n    return this.metrics.get(operationId) || [];\n  }\n  \n  getAverageTime(operationId: string): number {\n    const metrics = this.getMetrics(operationId);\n    if (metrics.length === 0) return 0;\n    \n    const totalTime = metrics.reduce((sum, metric) => sum + metric.duration, 0);\n    return totalTime / metrics.length;\n  }\n  \n  getPercentile(operationId: string, percentile: number): number {\n    const metrics = this.getMetrics(operationId);\n    if (metrics.length === 0) return 0;\n    \n    const sorted = metrics.map(m => m.duration).sort((a, b) => a - b);\n    const index = Math.ceil(sorted.length * (percentile / 100)) - 1;\n    return sorted[index];\n  }\n  \n  clear(): void {\n    this.metrics.clear();\n    this.startTimes.clear();\n  }\n  \n  generateReport(): any {\n    const report: any = {\n      timestamp: Date.now(),\n      operations: {}\n    };\n    \n    for (const [operationId, metrics] of this.metrics.entries()) {\n      if (metrics.length > 0) {\n        report.operations[operationId] = {\n          count: metrics.length,\n          average: this.getAverageTime(operationId),\n          p50: this.getPercentile(operationId, 50),\n          p95: this.getPercentile(operationId, 95),\n          p99: this.getPercentile(operationId, 99),\n          min: Math.min(...metrics.map(m => m.duration)),\n          max: Math.max(...metrics.map(m => m.duration))\n        };\n      }\n    }\n    \n    return report;\n  }\n}\n\n// Global performance monitor instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n// Memory monitoring utilities\nexport class MemoryMonitor {\n  private snapshots: any[] = [];\n  \n  takeSnapshot(label: string): any {\n    const memUsage = process.memoryUsage();\n    const snapshot = {\n      label,\n      timestamp: Date.now(),\n      rss: memUsage.rss,\n      heapUsed: memUsage.heapUsed,\n      heapTotal: memUsage.heapTotal,\n      external: memUsage.external\n    };\n    \n    this.snapshots.push(snapshot);\n    return snapshot;\n  }\n  \n  comparSnapshots(labelA: string, labelB: string): any {\n    const snapshotA = this.snapshots.find(s => s.label === labelA);\n    const snapshotB = this.snapshots.find(s => s.label === labelB);\n    \n    if (!snapshotA || !snapshotB) {\n      throw new Error('Snapshots not found for comparison');\n    }\n    \n    return {\n      rssDelta: snapshotB.rss - snapshotA.rss,\n      heapUsedDelta: snapshotB.heapUsed - snapshotA.heapUsed,\n      heapTotalDelta: snapshotB.heapTotal - snapshotA.heapTotal,\n      externalDelta: snapshotB.external - snapshotA.external\n    };\n  }\n  \n  getMemoryGrowth(): number {\n    if (this.snapshots.length < 2) return 0;\n    \n    const first = this.snapshots[0];\n    const last = this.snapshots[this.snapshots.length - 1];\n    \n    return last.heapUsed - first.heapUsed;\n  }\n  \n  clear(): void {\n    this.snapshots = [];\n  }\n}\n\n// Global memory monitor instance\nexport const memoryMonitor = new MemoryMonitor();\n\n// Performance test utilities\nexport const performanceTestUtils = {\n  /**\n   * Assert operation meets performance threshold\n   */\n  assertPerformanceThreshold: (operationType: keyof typeof PERFORMANCE_THRESHOLDS, actualTime: number) => {\n    const threshold = PERFORMANCE_THRESHOLDS[operationType];\n    expect(actualTime).toBeLessThan(threshold);\n  },\n  \n  /**\n   * Measure async operation performance\n   */\n  measureAsyncOperation: async <T>(\n    operationName: string,\n    operation: () => Promise<T>\n  ): Promise<{ result: T; duration: number }> => {\n    const operationId = `${operationName}-${Date.now()}`;\n    performanceMonitor.startMeasurement(operationId);\n    \n    const result = await operation();\n    const duration = performanceMonitor.endMeasurement(operationId);\n    \n    return { result, duration };\n  },\n  \n  /**\n   * Measure synchronous operation performance\n   */\n  measureSyncOperation: <T>(\n    operationName: string,\n    operation: () => T\n  ): { result: T; duration: number } => {\n    const operationId = `${operationName}-${Date.now()}`;\n    performanceMonitor.startMeasurement(operationId);\n    \n    const result = operation();\n    const duration = performanceMonitor.endMeasurement(operationId);\n    \n    return { result, duration };\n  },\n  \n  /**\n   * Run performance stress test\n   */\n  runStressTest: async (\n    operationName: string,\n    operation: () => Promise<any>,\n    iterations: number = 100\n  ): Promise<any> => {\n    const results = [];\n    \n    memoryMonitor.takeSnapshot(`${operationName}-start`);\n    \n    for (let i = 0; i < iterations; i++) {\n      const { duration } = await performanceTestUtils.measureAsyncOperation(\n        `${operationName}-${i}`,\n        operation\n      );\n      results.push(duration);\n    }\n    \n    memoryMonitor.takeSnapshot(`${operationName}-end`);\n    const memoryGrowth = memoryMonitor.getMemoryGrowth();\n    \n    return {\n      iterations,\n      averageTime: results.reduce((sum, time) => sum + time, 0) / results.length,\n      minTime: Math.min(...results),\n      maxTime: Math.max(...results),\n      memoryGrowth,\n      results\n    };\n  },\n  \n  /**\n   * Test concurrent operations performance\n   */\n  testConcurrentPerformance: async (\n    operationName: string,\n    operation: () => Promise<any>,\n    concurrency: number = 10\n  ): Promise<any> => {\n    memoryMonitor.takeSnapshot(`${operationName}-concurrent-start`);\n    \n    const promises = Array.from({ length: concurrency }, (_, i) =>\n      performanceTestUtils.measureAsyncOperation(`${operationName}-concurrent-${i}`, operation)\n    );\n    \n    const results = await Promise.all(promises);\n    \n    memoryMonitor.takeSnapshot(`${operationName}-concurrent-end`);\n    const memoryGrowth = memoryMonitor.getMemoryGrowth();\n    \n    const durations = results.map(r => r.duration);\n    \n    return {\n      concurrency,\n      averageTime: durations.reduce((sum, time) => sum + time, 0) / durations.length,\n      minTime: Math.min(...durations),\n      maxTime: Math.max(...durations),\n      memoryGrowth,\n      results\n    };\n  },\n  \n  /**\n   * Validate real-time performance (60 FPS = ~16.67ms per frame)\n   */\n  validateRealTimePerformance: (frameTime: number) => {\n    const fpsThreshold = 1000 / PERFORMANCE_THRESHOLDS.REAL_TIME_FPS; // ~16.67ms for 60 FPS\n    expect(frameTime).toBeLessThan(fpsThreshold);\n  },\n  \n  /**\n   * Generate performance test scenarios\n   */\n  generatePerformanceScenarios: () => [\n    {\n      name: 'Agent Spawn Performance',\n      thresholdType: 'AGENT_SPAWN_TIME' as keyof typeof PERFORMANCE_THRESHOLDS,\n      operation: async () => {\n        // Mock agent spawn\n        await new Promise(resolve => setTimeout(resolve, Math.random() * 50));\n        return { agentId: 'test-agent', spawnTime: Date.now() };\n      }\n    },\n    {\n      name: 'Neural Inference Performance',\n      thresholdType: 'INFERENCE_TIME' as keyof typeof PERFORMANCE_THRESHOLDS,\n      operation: async () => {\n        // Mock neural inference\n        await new Promise(resolve => setTimeout(resolve, Math.random() * 80));\n        return [Math.random(), Math.random(), Math.random()];\n      }\n    },\n    {\n      name: 'Persistence Save Performance',\n      thresholdType: 'PERSISTENCE_SAVE' as keyof typeof PERFORMANCE_THRESHOLDS,\n      operation: async () => {\n        // Mock database save\n        await new Promise(resolve => setTimeout(resolve, Math.random() * 60));\n        return { saved: true, timestamp: Date.now() };\n      }\n    },\n    {\n      name: 'Coordination Overhead Performance',\n      thresholdType: 'COORDINATION_OVERHEAD' as keyof typeof PERFORMANCE_THRESHOLDS,\n      operation: async () => {\n        // Mock agent coordination\n        await new Promise(resolve => setTimeout(resolve, Math.random() * 40));\n        return { coordinated: true, agentCount: 3 };\n      }\n    }\n  ]\n};\n\n// Performance assertion helpers\nexport const performanceAssertions = {\n  /**\n   * Assert agent spawn time meets threshold\n   */\n  assertAgentSpawnTime: (spawnTime: number) => {\n    performanceTestUtils.assertPerformanceThreshold('AGENT_SPAWN_TIME', spawnTime);\n  },\n  \n  /**\n   * Assert neural inference time meets threshold\n   */\n  assertInferenceTime: (inferenceTime: number) => {\n    performanceTestUtils.assertPerformanceThreshold('INFERENCE_TIME', inferenceTime);\n  },\n  \n  /**\n   * Assert persistence operation time meets threshold\n   */\n  assertPersistenceTime: (operationType: 'save' | 'load', operationTime: number) => {\n    const thresholdType = operationType === 'save' ? 'PERSISTENCE_SAVE' : 'PERSISTENCE_LOAD';\n    performanceTestUtils.assertPerformanceThreshold(thresholdType, operationTime);\n  },\n  \n  /**\n   * Assert coordination overhead meets threshold\n   */\n  assertCoordinationOverhead: (coordinationTime: number) => {\n    performanceTestUtils.assertPerformanceThreshold('COORDINATION_OVERHEAD', coordinationTime);\n  },\n  \n  /**\n   * Assert memory usage per agent meets threshold\n   */\n  assertMemoryUsagePerAgent: (memoryUsage: number) => {\n    expect(memoryUsage).toBeLessThan(PERFORMANCE_THRESHOLDS.MEMORY_USAGE_PER_AGENT);\n  },\n  \n  /**\n   * Assert no memory leaks in operation\n   */\n  assertNoMemoryLeaks: (initialMemory: number, finalMemory: number, maxGrowth: number = 1024 * 1024) => {\n    const memoryGrowth = finalMemory - initialMemory;\n    expect(memoryGrowth).toBeLessThan(maxGrowth);\n  }\n};\n\n// Mock performance-critical components\nexport const mockPerformanceComponents = {\n  fastNeuralInference: jest.fn().mockImplementation(async (input: Float32Array) => {\n    // Simulate fast inference (<100ms)\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 80));\n    return new Float32Array(input.length).map(() => Math.random());\n  }),\n  \n  optimizedAgentSpawn: jest.fn().mockImplementation(async (config: any) => {\n    // Simulate fast agent spawn (<75ms)\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 60));\n    return {\n      agentId: 'fast-agent-' + Date.now(),\n      config,\n      spawnTime: Date.now()\n    };\n  }),\n  \n  rapidPersistence: jest.fn().mockImplementation(async (data: any) => {\n    // Simulate fast persistence save (<75ms)\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 50));\n    return { saved: true, data, timestamp: Date.now() };\n  }),\n  \n  efficientCoordination: jest.fn().mockImplementation(async (agents: string[]) => {\n    // Simulate fast coordination (<50ms)\n    await new Promise(resolve => setTimeout(resolve, Math.random() * 30));\n    return { coordinated: agents, overhead: Date.now() };\n  })\n};\n\n// Global performance test hooks\nbeforeEach(() => {\n  performanceMonitor.clear();\n  memoryMonitor.clear();\n  jest.clearAllMocks();\n});\n\nafterEach(() => {\n  // Generate performance report if test failed\n  if (expect.getState().currentTestName && expect.getState().assertionCalls > 0) {\n    const report = performanceMonitor.generateReport();\n    if (Object.keys(report.operations).length > 0) {\n      console.log('📊 Performance Report:', JSON.stringify(report, null, 2));\n    }\n  }\n});\n\nconsole.log('⚡ Performance test setup initialized');\nconsole.log('🎯 Thresholds: <75ms spawn, <100ms inference, <50ms coordination');\nconsole.log('📊 Memory monitoring enabled with leak detection');\nconsole.log('🔄 Real-time performance validation ready (60 FPS)');"],"version":3}