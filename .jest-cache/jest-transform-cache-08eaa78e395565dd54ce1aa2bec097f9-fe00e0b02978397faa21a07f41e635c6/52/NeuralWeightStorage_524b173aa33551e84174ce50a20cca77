6413cc59e08c9e3e22d1be9110939c06
"use strict";
/**
 * Neural Weight Storage Manager - Phase 2A Implementation
 * Handles neural network weight serialization, compression, and persistence
 *
 * Performance Requirements:
 * - Weight save/load: <30ms
 * - Compression ratio: >50%
 * - Data integrity: 100% with checksums
 * - Memory usage: <10MB during operations
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NeuralWeightStorage = void 0;
const crypto = __importStar(require("crypto"));
const zlib_1 = require("zlib");
const perf_hooks_1 = require("perf_hooks");
class NeuralWeightStorage {
    constructor(persistenceManager) {
        Object.defineProperty(this, "persistence", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "compressionEnabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "checksumValidation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "compressionThreshold", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1024
        }); // Compress if data > 1KB
        this.persistence = persistenceManager;
    }
    /**
     * Save neural weights for an agent with compression and validation
     * Performance target: <30ms
     */
    async saveNeuralWeights(agentId, networkLayers, weights, biases) {
        const startTime = perf_hooks_1.performance.now();
        try {
            if (weights.length !== biases.length) {
                throw new Error('Weights and biases arrays must have the same length');
            }
            if (weights.length !== networkLayers.length - 1) {
                throw new Error('Weight layers must match network architecture');
            }
            // Process each layer
            for (let layerIndex = 0; layerIndex < weights.length; layerIndex++) {
                const compressedData = await this.compressLayerData(weights[layerIndex], biases[layerIndex]);
                // Save to database via persistence manager
                // This would call a method we'll add to AgentPersistenceManager
                await this.saveLayerWeights(agentId, layerIndex, compressedData);
            }
            const saveTime = perf_hooks_1.performance.now() - startTime;
            if (saveTime > 30) {
                console.warn(`‚ö†Ô∏è Neural weight save time exceeded target: ${saveTime.toFixed(2)}ms`);
            }
            console.log(`üíæ Saved neural weights for agent ${agentId} (${saveTime.toFixed(2)}ms)`);
        }
        catch (error) {
            const saveTime = perf_hooks_1.performance.now() - startTime;
            console.error(`‚ùå Failed to save neural weights for ${agentId} (${saveTime.toFixed(2)}ms):`, error.message);
            throw error;
        }
    }
    /**
     * Load neural weights for an agent with decompression and validation
     * Performance target: <30ms
     */
    async loadNeuralWeights(agentId) {
        const startTime = perf_hooks_1.performance.now();
        try {
            // Load weight records from database
            const weightRecords = await this.getAgentWeightRecords(agentId);
            if (weightRecords.length === 0) {
                throw new Error(`No neural weights found for agent ${agentId}`);
            }
            const weights = [];
            const biases = [];
            // Process each layer in order
            for (const record of weightRecords.sort((a, b) => a.layerIndex - b.layerIndex)) {
                // Validate checksum if enabled
                if (this.checksumValidation) {
                    const expectedChecksum = this.generateChecksum(record.weightData, record.biasData);
                    if (expectedChecksum !== record.checksum) {
                        throw new Error(`Weight corruption detected for agent ${agentId}, layer ${record.layerIndex}`);
                    }
                }
                // Decompress and deserialize
                const layerWeights = await this.decompressWeights(record.weightData, record.compressionType);
                const layerBiases = await this.decompressBiases(record.biasData, record.compressionType);
                weights.push(layerWeights);
                biases.push(layerBiases);
            }
            const loadTime = perf_hooks_1.performance.now() - startTime;
            if (loadTime > 30) {
                console.warn(`‚ö†Ô∏è Neural weight load time exceeded target: ${loadTime.toFixed(2)}ms`);
            }
            console.log(`üì• Loaded neural weights for agent ${agentId} (${loadTime.toFixed(2)}ms)`);
            return { weights, biases };
        }
        catch (error) {
            const loadTime = perf_hooks_1.performance.now() - startTime;
            console.error(`‚ùå Failed to load neural weights for ${agentId} (${loadTime.toFixed(2)}ms):`, error.message);
            throw error;
        }
    }
    /**
     * Compress weight and bias data for a single layer
     */
    async compressLayerData(weights, biases) {
        const startTime = perf_hooks_1.performance.now();
        try {
            // Convert to buffers
            const weightBuffer = Buffer.from(weights.buffer);
            const biasBuffer = Buffer.from(biases.buffer);
            const originalSize = weightBuffer.length + biasBuffer.length;
            let compressedWeights;
            let compressedBiases;
            let compressionType = 'none';
            // Apply compression if data is large enough
            if (originalSize > this.compressionThreshold && this.compressionEnabled) {
                compressedWeights = (0, zlib_1.gzipSync)(weightBuffer);
                compressedBiases = (0, zlib_1.gzipSync)(biasBuffer);
                compressionType = 'gzip';
            }
            else {
                compressedWeights = weightBuffer;
                compressedBiases = biasBuffer;
            }
            const compressedSize = compressedWeights.length + compressedBiases.length;
            const compressionRatio = compressedSize / originalSize;
            // Generate checksum for integrity validation
            const checksum = this.generateChecksum(compressedWeights, compressedBiases);
            const compressionTime = perf_hooks_1.performance.now() - startTime;
            console.log(`üóúÔ∏è Compressed layer data: ${originalSize} ‚Üí ${compressedSize} bytes (${(compressionRatio * 100).toFixed(1)}%) in ${compressionTime.toFixed(2)}ms`);
            return {
                weightData: compressedWeights,
                biasData: compressedBiases,
                compressionType,
                originalSize,
                compressedSize,
                compressionRatio,
                checksum
            };
        }
        catch (error) {
            console.error('‚ùå Failed to compress layer data:', error.message);
            throw error;
        }
    }
    /**
     * Decompress weight data
     */
    async decompressWeights(data, compressionType) {
        try {
            let decompressedBuffer;
            if (compressionType === 'gzip') {
                decompressedBuffer = (0, zlib_1.gunzipSync)(data);
            }
            else {
                decompressedBuffer = data;
            }
            // Convert back to Float32Array
            return new Float32Array(decompressedBuffer.buffer.slice(decompressedBuffer.byteOffset, decompressedBuffer.byteOffset + decompressedBuffer.byteLength));
        }
        catch (error) {
            console.error('‚ùå Failed to decompress weights:', error.message);
            throw error;
        }
    }
    /**
     * Decompress bias data
     */
    async decompressBiases(data, compressionType) {
        try {
            let decompressedBuffer;
            if (compressionType === 'gzip') {
                decompressedBuffer = (0, zlib_1.gunzipSync)(data);
            }
            else {
                decompressedBuffer = data;
            }
            // Convert back to Float32Array
            return new Float32Array(decompressedBuffer.buffer.slice(decompressedBuffer.byteOffset, decompressedBuffer.byteOffset + decompressedBuffer.byteLength));
        }
        catch (error) {
            console.error('‚ùå Failed to decompress biases:', error.message);
            throw error;
        }
    }
    /**
     * Generate checksum for data integrity validation
     */
    generateChecksum(weightData, biasData) {
        const hash = crypto.createHash('sha256');
        hash.update(weightData);
        hash.update(biasData);
        return hash.digest('hex');
    }
    /**
     * Save compressed layer weights to database
     * This method will call the persistence manager
     */
    async saveLayerWeights(agentId, layerIndex, compressedData) {
        // This would call a method we need to add to AgentPersistenceManager
        // For now, we'll implement a placeholder that shows the interface
        try {
            // The AgentPersistenceManager would need a method like this:
            // await this.persistence.saveNeuralWeightRecord({
            //   agentId,
            //   layerIndex,
            //   weightData: compressedData.weightData,
            //   biasData: compressedData.biasData,
            //   updatedAt: Date.now(),
            //   checksum: compressedData.checksum,
            //   compressionType: compressedData.compressionType
            // });
            console.log(`üíæ Saved layer ${layerIndex} weights for agent ${agentId}`);
        }
        catch (error) {
            console.error(`‚ùå Failed to save layer weights:`, error.message);
            throw error;
        }
    }
    /**
     * Get agent weight records from database
     * This method will call the persistence manager
     */
    async getAgentWeightRecords(agentId) {
        // This would call a method we need to add to AgentPersistenceManager
        // For now, we'll return an empty array to show the interface
        try {
            // The AgentPersistenceManager would need a method like this:
            // return await this.persistence.getNeuralWeightRecords(agentId);
            console.log(`üì• Loading weight records for agent ${agentId}`);
            return []; // Placeholder
        }
        catch (error) {
            console.error(`‚ùå Failed to load weight records:`, error.message);
            throw error;
        }
    }
    /**
     * Get compression statistics
     */
    getCompressionStats() {
        return {
            compressionEnabled: this.compressionEnabled,
            checksumValidation: this.checksumValidation,
            compressionThreshold: this.compressionThreshold
        };
    }
    /**
     * Configure compression settings
     */
    configureCompression(options) {
        if (options.enabled !== undefined) {
            this.compressionEnabled = options.enabled;
        }
        if (options.threshold !== undefined) {
            this.compressionThreshold = options.threshold;
        }
        if (options.validation !== undefined) {
            this.checksumValidation = options.validation;
        }
        console.log('‚öôÔ∏è Neural weight storage configuration updated:', {
            compressionEnabled: this.compressionEnabled,
            compressionThreshold: this.compressionThreshold,
            checksumValidation: this.checksumValidation
        });
    }
}
exports.NeuralWeightStorage = NeuralWeightStorage;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL3dvcmtzcGFjZXMvYWdlbnRpc3RzLXF1aWNrc3RhcnQtd29ya3NwYWNlLWJhc2ljL3Nhc2kvc3JjL3BlcnNpc3RlbmNlL05ldXJhbFdlaWdodFN0b3JhZ2UudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7R0FTRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUgsK0NBQWlDO0FBQ2pDLCtCQUE0QztBQUM1QywyQ0FBeUM7QUFzQnpDLE1BQWEsbUJBQW1CO0lBTTlCLFlBQVksa0JBQTJDO1FBTC9DOzs7OztXQUFxQztRQUNyQzs7OzttQkFBOEIsSUFBSTtXQUFDO1FBQ25DOzs7O21CQUE4QixJQUFJO1dBQUM7UUFDbkM7Ozs7bUJBQStCLElBQUk7V0FBQyxDQUFDLHlCQUF5QjtRQUdwRSxJQUFJLENBQUMsV0FBVyxHQUFHLGtCQUFrQixDQUFDO0lBQ3hDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsaUJBQWlCLENBQ3JCLE9BQWUsRUFDZixhQUF1QixFQUN2QixPQUF1QixFQUN2QixNQUFzQjtRQUV0QixNQUFNLFNBQVMsR0FBRyx3QkFBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRXBDLElBQUksQ0FBQztZQUNILElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3JDLE1BQU0sSUFBSSxLQUFLLENBQUMscURBQXFELENBQUMsQ0FBQztZQUN6RSxDQUFDO1lBRUQsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLGFBQWEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7Z0JBQ2hELE1BQU0sSUFBSSxLQUFLLENBQUMsK0NBQStDLENBQUMsQ0FBQztZQUNuRSxDQUFDO1lBRUQscUJBQXFCO1lBQ3JCLEtBQUssSUFBSSxVQUFVLEdBQUcsQ0FBQyxFQUFFLFVBQVUsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxFQUFFLENBQUM7Z0JBQ25FLE1BQU0sY0FBYyxHQUFHLE1BQU0sSUFB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LEVBQUU7WUFDN0Qsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLGtCQUFrQjtZQUMzQyxvQkFBb0IsRUFBRSxJQUFJLENBQUMsb0JBQW9CO1lBQy9DLGtCQUFrQixFQUFFLElBQUksQ0FBQyxrQkFBa0I7U0FDNUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBL1RELGtEQStUQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvd29ya3NwYWNlcy9hZ2VudGlzdHMtcXVpY2tzdGFydC13b3Jrc3BhY2UtYmFzaWMvc2FzaS9zcmMvcGVyc2lzdGVuY2UvTmV1cmFsV2VpZ2h0U3RvcmFnZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE5ldXJhbCBXZWlnaHQgU3RvcmFnZSBNYW5hZ2VyIC0gUGhhc2UgMkEgSW1wbGVtZW50YXRpb25cbiAqIEhhbmRsZXMgbmV1cmFsIG5ldHdvcmsgd2VpZ2h0IHNlcmlhbGl6YXRpb24sIGNvbXByZXNzaW9uLCBhbmQgcGVyc2lzdGVuY2VcbiAqIFxuICogUGVyZm9ybWFuY2UgUmVxdWlyZW1lbnRzOlxuICogLSBXZWlnaHQgc2F2ZS9sb2FkOiA8MzBtc1xuICogLSBDb21wcmVzc2lvbiByYXRpbzogPjUwJVxuICogLSBEYXRhIGludGVncml0eTogMTAwJSB3aXRoIGNoZWNrc3Vtc1xuICogLSBNZW1vcnkgdXNhZ2U6IDwxME1CIGR1cmluZyBvcGVyYXRpb25zXG4gKi9cblxuaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBnemlwU3luYywgZ3VuemlwU3luYyB9IGZyb20gJ3psaWInO1xuaW1wb3J0IHsgcGVyZm9ybWFuY2UgfSBmcm9tICdwZXJmX2hvb2tzJztcbmltcG9ydCB0eXBlIHsgQWdlbnRQZXJzaXN0ZW5jZU1hbmFnZXIgfSBmcm9tICcuL0FnZW50UGVyc2lzdGVuY2VNYW5hZ2VyJztcblxuZXhwb3J0IGludGVyZmFjZSBOZXVyYWxXZWlnaHREYXRhIHtcbiAgYWdlbnRJZDogc3RyaW5nO1xuICBsYXllckluZGV4OiBudW1iZXI7XG4gIHdlaWdodHM6IEZsb2F0MzJBcnJheTtcbiAgYmlhc2VzOiBGbG9hdDMyQXJyYXk7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICBjaGVja3N1bT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wcmVzc2VkV2VpZ2h0RGF0YSB7XG4gIHdlaWdodERhdGE6IEJ1ZmZlcjtcbiAgYmlhc0RhdGE6IEJ1ZmZlcjtcbiAgY29tcHJlc3Npb25UeXBlOiAnZ3ppcCcgfCAnbHo0JyB8ICdub25lJztcbiAgb3JpZ2luYWxTaXplOiBudW1iZXI7XG4gIGNvbXByZXNzZWRTaXplOiBudW1iZXI7XG4gIGNvbXByZXNzaW9uUmF0aW86IG51bWJlcjtcbiAgY2hlY2tzdW06IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIE5ldXJhbFdlaWdodFN0b3JhZ2Uge1xuICBwcml2YXRlIHBlcnNpc3RlbmNlOiBBZ2VudFBlcnNpc3RlbmNlTWFuYWdlcjtcbiAgcHJpdmF0ZSBjb21wcmVzc2lvbkVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICBwcml2YXRlIGNoZWNrc3VtVmFsaWRhdGlvbjogYm9vbGVhbiA9IHRydWU7XG4gIHByaXZhdGUgY29tcHJlc3Npb25UaHJlc2hvbGQ6IG51bWJlciA9IDEwMjQ7IC8vIENvbXByZXNzIGlmIGRhdGEgPiAxS0JcblxuICBjb25zdHJ1Y3RvcihwZXJzaXN0ZW5jZU1hbmFnZXI6IEFnZW50UGVyc2lzdGVuY2VNYW5hZ2VyKSB7XG4gICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlTWFuYWdlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlIG5ldXJhbCB3ZWlnaHRzIGZvciBhbiBhZ2VudCB3aXRoIGNvbXByZXNzaW9uIGFuZCB2YWxpZGF0aW9uXG4gICAqIFBlcmZvcm1hbmNlIHRhcmdldDogPDMwbXNcbiAgICovXG4gIGFzeW5jIHNhdmVOZXVyYWxXZWlnaHRzKFxuICAgIGFnZW50SWQ6IHN0cmluZyxcbiAgICBuZXR3b3JrTGF5ZXJzOiBudW1iZXJbXSxcbiAgICB3ZWlnaHRzOiBGbG9hdDMyQXJyYXlbXSxcbiAgICBiaWFzZXM6IEZsb2F0MzJBcnJheVtdXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh3ZWlnaHRzLmxlbmd0aCAhPT0gYmlhc2VzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlaWdodHMgYW5kIGJpYXNlcyBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAod2VpZ2h0cy5sZW5ndGggIT09IG5ldHdvcmtMYXllcnMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlaWdodCBsYXllcnMgbXVzdCBtYXRjaCBuZXR3b3JrIGFyY2hpdGVjdHVyZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggbGF5ZXJcbiAgICAgIGZvciAobGV0IGxheWVySW5kZXggPSAwOyBsYXllckluZGV4IDwgd2VpZ2h0cy5sZW5ndGg7IGxheWVySW5kZXgrKykge1xuICAgICAgICBjb25zdCBjb21wcmVzc2VkRGF0YSA9IGF3YWl0IHRoaXMuY29tcHJlc3NMYXllckRhdGEoXG4gICAgICAgICAgd2VpZ2h0c1tsYXllckluZGV4XSxcbiAgICAgICAgICBiaWFzZXNbbGF5ZXJJbmRleF1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTYXZlIHRvIGRhdGFiYXNlIHZpYSBwZXJzaXN0ZW5jZSBtYW5hZ2VyXG4gICAgICAgIC8vIFRoaXMgd291bGQgY2FsbCBhIG1ldGhvZCB3ZSdsbCBhZGQgdG8gQWdlbnRQZXJzaXN0ZW5jZU1hbmFnZXJcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlTGF5ZXJXZWlnaHRzKGFnZW50SWQsIGxheWVySW5kZXgsIGNvbXByZXNzZWREYXRhKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2F2ZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgaWYgKHNhdmVUaW1lID4gMzApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gTmV1cmFsIHdlaWdodCBzYXZlIHRpbWUgZXhjZWVkZWQgdGFyZ2V0OiAke3NhdmVUaW1lLnRvRml4ZWQoMil9bXNgKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYPCfkr4gU2F2ZWQgbmV1cmFsIHdlaWdodHMgZm9yIGFnZW50ICR7YWdlbnRJZH0gKCR7c2F2ZVRpbWUudG9GaXhlZCgyKX1tcylgKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBzYXZlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBzYXZlIG5ldXJhbCB3ZWlnaHRzIGZvciAke2FnZW50SWR9ICgke3NhdmVUaW1lLnRvRml4ZWQoMil9bXMpOmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgbmV1cmFsIHdlaWdodHMgZm9yIGFuIGFnZW50IHdpdGggZGVjb21wcmVzc2lvbiBhbmQgdmFsaWRhdGlvblxuICAgKiBQZXJmb3JtYW5jZSB0YXJnZXQ6IDwzMG1zXG4gICAqL1xuICBhc3luYyBsb2FkTmV1cmFsV2VpZ2h0cyhhZ2VudElkOiBzdHJpbmcpOiBQcm9taXNlPHsgd2VpZ2h0czogRmxvYXQzMkFycmF5W107IGJpYXNlczogRmxvYXQzMkFycmF5W10gfT4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIExvYWQgd2VpZ2h0IHJlY29yZHMgZnJvbSBkYXRhYmFzZVxuICAgICAgY29uc3Qgd2VpZ2h0UmVjb3JkcyA9IGF3YWl0IHRoaXMuZ2V0QWdlbnRXZWlnaHRSZWNvcmRzKGFnZW50SWQpO1xuICAgICAgXG4gICAgICBpZiAod2VpZ2h0UmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBuZXVyYWwgd2VpZ2h0cyBmb3VuZCBmb3IgYWdlbnQgJHthZ2VudElkfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3ZWlnaHRzOiBGbG9hdDMyQXJyYXlbXSA9IFtdO1xuICAgICAgY29uc3QgYmlhc2VzOiBGbG9hdDMyQXJyYXlbXSA9IFtdO1xuXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggbGF5ZXIgaW4gb3JkZXJcbiAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHdlaWdodFJlY29yZHMuc29ydCgoYSwgYikgPT4gYS5sYXllckluZGV4IC0gYi5sYXllckluZGV4KSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSBjaGVja3N1bSBpZiBlbmFibGVkXG4gICAgICAgIGlmICh0aGlzLmNoZWNrc3VtVmFsaWRhdGlvbikge1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkQ2hlY2tzdW0gPSB0aGlzLmdlbmVyYXRlQ2hlY2tzdW0ocmVjb3JkLndlaWdodERhdGEsIHJlY29yZC5iaWFzRGF0YSk7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkQ2hlY2tzdW0gIT09IHJlY29yZC5jaGVja3N1bSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXZWlnaHQgY29ycnVwdGlvbiBkZXRlY3RlZCBmb3IgYWdlbnQgJHthZ2VudElkfSwgbGF5ZXIgJHtyZWNvcmQubGF5ZXJJbmRleH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNvbXByZXNzIGFuZCBkZXNlcmlhbGl6ZVxuICAgICAgICBjb25zdCBsYXllcldlaWdodHMgPSBhd2FpdCB0aGlzLmRlY29tcHJlc3NXZWlnaHRzKHJlY29yZC53ZWlnaHREYXRhLCByZWNvcmQuY29tcHJlc3Npb25UeXBlKTtcbiAgICAgICAgY29uc3QgbGF5ZXJCaWFzZXMgPSBhd2FpdCB0aGlzLmRlY29tcHJlc3NCaWFzZXMocmVjb3JkLmJpYXNEYXRhLCByZWNvcmQuY29tcHJlc3Npb25UeXBlKTtcblxuICAgICAgICB3ZWlnaHRzLnB1c2gobGF5ZXJXZWlnaHRzKTtcbiAgICAgICAgYmlhc2VzLnB1c2gobGF5ZXJCaWFzZXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgXG4gICAgICBpZiAobG9hZFRpbWUgPiAzMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBOZXVyYWwgd2VpZ2h0IGxvYWQgdGltZSBleGNlZWRlZCB0YXJnZXQ6ICR7bG9hZFRpbWUudG9GaXhlZCgyKX1tc2ApO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhg8J+TpSBMb2FkZWQgbmV1cmFsIHdlaWdodHMgZm9yIGFnZW50ICR7YWdlbnRJZH0gKCR7bG9hZFRpbWUudG9GaXhlZCgyKX1tcylgKTtcblxuICAgICAgcmV0dXJuIHsgd2VpZ2h0cywgYmlhc2VzIH07XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgbG9hZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gbG9hZCBuZXVyYWwgd2VpZ2h0cyBmb3IgJHthZ2VudElkfSAoJHtsb2FkVGltZS50b0ZpeGVkKDIpfW1zKTpgLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyB3ZWlnaHQgYW5kIGJpYXMgZGF0YSBmb3IgYSBzaW5nbGUgbGF5ZXJcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY29tcHJlc3NMYXllckRhdGEoXG4gICAgd2VpZ2h0czogRmxvYXQzMkFycmF5LFxuICAgIGJpYXNlczogRmxvYXQzMkFycmF5XG4gICk6IFByb21pc2U8Q29tcHJlc3NlZFdlaWdodERhdGE+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIGJ1ZmZlcnNcbiAgICAgIGNvbnN0IHdlaWdodEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHdlaWdodHMuYnVmZmVyKTtcbiAgICAgIGNvbnN0IGJpYXNCdWZmZXIgPSBCdWZmZXIuZnJvbShiaWFzZXMuYnVmZmVyKTtcblxuICAgICAgY29uc3Qgb3JpZ2luYWxTaXplID0gd2VpZ2h0QnVmZmVyLmxlbmd0aCArIGJpYXNCdWZmZXIubGVuZ3RoO1xuICAgICAgXG4gICAgICBsZXQgY29tcHJlc3NlZFdlaWdodHM6IEJ1ZmZlcjtcbiAgICAgIGxldCBjb21wcmVzc2VkQmlhc2VzOiBCdWZmZXI7XG4gICAgICBsZXQgY29tcHJlc3Npb25UeXBlOiAnZ3ppcCcgfCAnbm9uZScgPSAnbm9uZSc7XG5cbiAgICAgIC8vIEFwcGx5IGNvbXByZXNzaW9uIGlmIGRhdGEgaXMgbGFyZ2UgZW5vdWdoXG4gICAgICBpZiAob3JpZ2luYWxTaXplID4gdGhpcy5jb21wcmVzc2lvblRocmVzaG9sZCAmJiB0aGlzLmNvbXByZXNzaW9uRW5hYmxlZCkge1xuICAgICAgICBjb21wcmVzc2VkV2VpZ2h0cyA9IGd6aXBTeW5jKHdlaWdodEJ1ZmZlcik7XG4gICAgICAgIGNvbXByZXNzZWRCaWFzZXMgPSBnemlwU3luYyhiaWFzQnVmZmVyKTtcbiAgICAgICAgY29tcHJlc3Npb25UeXBlID0gJ2d6aXAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcHJlc3NlZFdlaWdodHMgPSB3ZWlnaHRCdWZmZXI7XG4gICAgICAgIGNvbXByZXNzZWRCaWFzZXMgPSBiaWFzQnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb21wcmVzc2VkU2l6ZSA9IGNvbXByZXNzZWRXZWlnaHRzLmxlbmd0aCArIGNvbXByZXNzZWRCaWFzZXMubGVuZ3RoO1xuICAgICAgY29uc3QgY29tcHJlc3Npb25SYXRpbyA9IGNvbXByZXNzZWRTaXplIC8gb3JpZ2luYWxTaXplO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBjaGVja3N1bSBmb3IgaW50ZWdyaXR5IHZhbGlkYXRpb25cbiAgICAgIGNvbnN0IGNoZWNrc3VtID0gdGhpcy5nZW5lcmF0ZUNoZWNrc3VtKGNvbXByZXNzZWRXZWlnaHRzLCBjb21wcmVzc2VkQmlhc2VzKTtcblxuICAgICAgY29uc3QgY29tcHJlc3Npb25UaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5ec77iPIENvbXByZXNzZWQgbGF5ZXIgZGF0YTogJHtvcmlnaW5hbFNpemV9IOKGkiAke2NvbXByZXNzZWRTaXplfSBieXRlcyAoJHsoY29tcHJlc3Npb25SYXRpbyAqIDEwMCkudG9GaXhlZCgxKX0lKSBpbiAke2NvbXByZXNzaW9uVGltZS50b0ZpeGVkKDIpfW1zYCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdlaWdodERhdGE6IGNvbXByZXNzZWRXZWlnaHRzLFxuICAgICAgICBiaWFzRGF0YTogY29tcHJlc3NlZEJpYXNlcyxcbiAgICAgICAgY29tcHJlc3Npb25UeXBlLFxuICAgICAgICBvcmlnaW5hbFNpemUsXG4gICAgICAgIGNvbXByZXNzZWRTaXplLFxuICAgICAgICBjb21wcmVzc2lvblJhdGlvLFxuICAgICAgICBjaGVja3N1bVxuICAgICAgfTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGNvbXByZXNzIGxheWVyIGRhdGE6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyB3ZWlnaHQgZGF0YVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBkZWNvbXByZXNzV2VpZ2h0cyhkYXRhOiBCdWZmZXIsIGNvbXByZXNzaW9uVHlwZTogc3RyaW5nKTogUHJvbWlzZTxGbG9hdDMyQXJyYXk+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGRlY29tcHJlc3NlZEJ1ZmZlcjogQnVmZmVyO1xuXG4gICAgICBpZiAoY29tcHJlc3Npb25UeXBlID09PSAnZ3ppcCcpIHtcbiAgICAgICAgZGVjb21wcmVzc2VkQnVmZmVyID0gZ3VuemlwU3luYyhkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY29tcHJlc3NlZEJ1ZmZlciA9IGRhdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnQgYmFjayB0byBGbG9hdDMyQXJyYXlcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGRlY29tcHJlc3NlZEJ1ZmZlci5idWZmZXIuc2xpY2UoXG4gICAgICAgIGRlY29tcHJlc3NlZEJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICBkZWNvbXByZXNzZWRCdWZmZXIuYnl0ZU9mZnNldCArIGRlY29tcHJlc3NlZEJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICApKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIGRlY29tcHJlc3Mgd2VpZ2h0czonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGJpYXMgZGF0YVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBkZWNvbXByZXNzQmlhc2VzKGRhdGE6IEJ1ZmZlciwgY29tcHJlc3Npb25UeXBlOiBzdHJpbmcpOiBQcm9taXNlPEZsb2F0MzJBcnJheT4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgZGVjb21wcmVzc2VkQnVmZmVyOiBCdWZmZXI7XG5cbiAgICAgIGlmIChjb21wcmVzc2lvblR5cGUgPT09ICdnemlwJykge1xuICAgICAgICBkZWNvbXByZXNzZWRCdWZmZXIgPSBndW56aXBTeW5jKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVjb21wcmVzc2VkQnVmZmVyID0gZGF0YTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29udmVydCBiYWNrIHRvIEZsb2F0MzJBcnJheVxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZGVjb21wcmVzc2VkQnVmZmVyLmJ1ZmZlci5zbGljZShcbiAgICAgICAgZGVjb21wcmVzc2VkQnVmZmVyLmJ5dGVPZmZzZXQsXG4gICAgICAgIGRlY29tcHJlc3NlZEJ1ZmZlci5ieXRlT2Zmc2V0ICsgZGVjb21wcmVzc2VkQnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICkpO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gZGVjb21wcmVzcyBiaWFzZXM6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgY2hlY2tzdW0gZm9yIGRhdGEgaW50ZWdyaXR5IHZhbGlkYXRpb25cbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVDaGVja3N1bSh3ZWlnaHREYXRhOiBCdWZmZXIsIGJpYXNEYXRhOiBCdWZmZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG4gICAgaGFzaC51cGRhdGUod2VpZ2h0RGF0YSk7XG4gICAgaGFzaC51cGRhdGUoYmlhc0RhdGEpO1xuICAgIHJldHVybiBoYXNoLmRpZ2VzdCgnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZSBjb21wcmVzc2VkIGxheWVyIHdlaWdodHMgdG8gZGF0YWJhc2VcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBjYWxsIHRoZSBwZXJzaXN0ZW5jZSBtYW5hZ2VyXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNhdmVMYXllcldlaWdodHMoXG4gICAgYWdlbnRJZDogc3RyaW5nLFxuICAgIGxheWVySW5kZXg6IG51bWJlcixcbiAgICBjb21wcmVzc2VkRGF0YTogQ29tcHJlc3NlZFdlaWdodERhdGFcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gVGhpcyB3b3VsZCBjYWxsIGEgbWV0aG9kIHdlIG5lZWQgdG8gYWRkIHRvIEFnZW50UGVyc2lzdGVuY2VNYW5hZ2VyXG4gICAgLy8gRm9yIG5vdywgd2UnbGwgaW1wbGVtZW50IGEgcGxhY2Vob2xkZXIgdGhhdCBzaG93cyB0aGUgaW50ZXJmYWNlXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBBZ2VudFBlcnNpc3RlbmNlTWFuYWdlciB3b3VsZCBuZWVkIGEgbWV0aG9kIGxpa2UgdGhpczpcbiAgICAgIC8vIGF3YWl0IHRoaXMucGVyc2lzdGVuY2Uuc2F2ZU5ldXJhbFdlaWdodFJlY29yZCh7XG4gICAgICAvLyAgIGFnZW50SWQsXG4gICAgICAvLyAgIGxheWVySW5kZXgsXG4gICAgICAvLyAgIHdlaWdodERhdGE6IGNvbXByZXNzZWREYXRhLndlaWdodERhdGEsXG4gICAgICAvLyAgIGJpYXNEYXRhOiBjb21wcmVzc2VkRGF0YS5iaWFzRGF0YSxcbiAgICAgIC8vICAgdXBkYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgLy8gICBjaGVja3N1bTogY29tcHJlc3NlZERhdGEuY2hlY2tzdW0sXG4gICAgICAvLyAgIGNvbXByZXNzaW9uVHlwZTogY29tcHJlc3NlZERhdGEuY29tcHJlc3Npb25UeXBlXG4gICAgICAvLyB9KTtcblxuICAgICAgY29uc29sZS5sb2coYPCfkr4gU2F2ZWQgbGF5ZXIgJHtsYXllckluZGV4fSB3ZWlnaHRzIGZvciBhZ2VudCAke2FnZW50SWR9YCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBzYXZlIGxheWVyIHdlaWdodHM6YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFnZW50IHdlaWdodCByZWNvcmRzIGZyb20gZGF0YWJhc2VcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBjYWxsIHRoZSBwZXJzaXN0ZW5jZSBtYW5hZ2VyXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldEFnZW50V2VpZ2h0UmVjb3JkcyhhZ2VudElkOiBzdHJpbmcpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgLy8gVGhpcyB3b3VsZCBjYWxsIGEgbWV0aG9kIHdlIG5lZWQgdG8gYWRkIHRvIEFnZW50UGVyc2lzdGVuY2VNYW5hZ2VyXG4gICAgLy8gRm9yIG5vdywgd2UnbGwgcmV0dXJuIGFuIGVtcHR5IGFycmF5IHRvIHNob3cgdGhlIGludGVyZmFjZVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgQWdlbnRQZXJzaXN0ZW5jZU1hbmFnZXIgd291bGQgbmVlZCBhIG1ldGhvZCBsaWtlIHRoaXM6XG4gICAgICAvLyByZXR1cm4gYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5nZXROZXVyYWxXZWlnaHRSZWNvcmRzKGFnZW50SWQpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+TpSBMb2FkaW5nIHdlaWdodCByZWNvcmRzIGZvciBhZ2VudCAke2FnZW50SWR9YCk7XG4gICAgICByZXR1cm4gW107IC8vIFBsYWNlaG9sZGVyXG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBsb2FkIHdlaWdodCByZWNvcmRzOmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb21wcmVzc2lvbiBzdGF0aXN0aWNzXG4gICAqL1xuICBnZXRDb21wcmVzc2lvblN0YXRzKCk6IHtcbiAgICBjb21wcmVzc2lvbkVuYWJsZWQ6IGJvb2xlYW47XG4gICAgY2hlY2tzdW1WYWxpZGF0aW9uOiBib29sZWFuO1xuICAgIGNvbXByZXNzaW9uVGhyZXNob2xkOiBudW1iZXI7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wcmVzc2lvbkVuYWJsZWQ6IHRoaXMuY29tcHJlc3Npb25FbmFibGVkLFxuICAgICAgY2hlY2tzdW1WYWxpZGF0aW9uOiB0aGlzLmNoZWNrc3VtVmFsaWRhdGlvbixcbiAgICAgIGNvbXByZXNzaW9uVGhyZXNob2xkOiB0aGlzLmNvbXByZXNzaW9uVGhyZXNob2xkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmUgY29tcHJlc3Npb24gc2V0dGluZ3NcbiAgICovXG4gIGNvbmZpZ3VyZUNvbXByZXNzaW9uKG9wdGlvbnM6IHtcbiAgICBlbmFibGVkPzogYm9vbGVhbjtcbiAgICB0aHJlc2hvbGQ/OiBudW1iZXI7XG4gICAgdmFsaWRhdGlvbj86IGJvb2xlYW47XG4gIH0pOiB2b2lkIHtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY29tcHJlc3Npb25FbmFibGVkID0gb3B0aW9ucy5lbmFibGVkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jb21wcmVzc2lvblRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy52YWxpZGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tzdW1WYWxpZGF0aW9uID0gb3B0aW9ucy52YWxpZGF0aW9uO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfimpnvuI8gTmV1cmFsIHdlaWdodCBzdG9yYWdlIGNvbmZpZ3VyYXRpb24gdXBkYXRlZDonLCB7XG4gICAgICBjb21wcmVzc2lvbkVuYWJsZWQ6IHRoaXMuY29tcHJlc3Npb25FbmFibGVkLFxuICAgICAgY29tcHJlc3Npb25UaHJlc2hvbGQ6IHRoaXMuY29tcHJlc3Npb25UaHJlc2hvbGQsXG4gICAgICBjaGVja3N1bVZhbGlkYXRpb246IHRoaXMuY2hlY2tzdW1WYWxpZGF0aW9uXG4gICAgfSk7XG4gIH1cbn0iXSwidmVyc2lvbiI6M30=