{"file":"/workspaces/agentists-quickstart-workspace-basic/sasi/src/persistence/NeuralWeightStorage.ts","mappings":"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","names":[],"sources":["/workspaces/agentists-quickstart-workspace-basic/sasi/src/persistence/NeuralWeightStorage.ts"],"sourcesContent":["/**\n * Neural Weight Storage Manager - Phase 2A Implementation\n * Handles neural network weight serialization, compression, and persistence\n * \n * Performance Requirements:\n * - Weight save/load: <30ms\n * - Compression ratio: >50%\n * - Data integrity: 100% with checksums\n * - Memory usage: <10MB during operations\n */\n\nimport * as crypto from 'crypto';\nimport { gzipSync, gunzipSync } from 'zlib';\nimport { performance } from 'perf_hooks';\nimport type { AgentPersistenceManager } from './AgentPersistenceManager';\n\nexport interface NeuralWeightData {\n  agentId: string;\n  layerIndex: number;\n  weights: Float32Array;\n  biases: Float32Array;\n  timestamp: number;\n  checksum?: string;\n}\n\nexport interface CompressedWeightData {\n  weightData: Buffer;\n  biasData: Buffer;\n  compressionType: 'gzip' | 'lz4' | 'none';\n  originalSize: number;\n  compressedSize: number;\n  compressionRatio: number;\n  checksum: string;\n}\n\nexport class NeuralWeightStorage {\n  private persistence: AgentPersistenceManager;\n  private compressionEnabled: boolean = true;\n  private checksumValidation: boolean = true;\n  private compressionThreshold: number = 1024; // Compress if data > 1KB\n\n  constructor(persistenceManager: AgentPersistenceManager) {\n    this.persistence = persistenceManager;\n  }\n\n  /**\n   * Save neural weights for an agent with compression and validation\n   * Performance target: <30ms\n   */\n  async saveNeuralWeights(\n    agentId: string,\n    networkLayers: number[],\n    weights: Float32Array[],\n    biases: Float32Array[]\n  ): Promise<void> {\n    const startTime = performance.now();\n\n    try {\n      if (weights.length !== biases.length) {\n        throw new Error('Weights and biases arrays must have the same length');\n      }\n\n      if (weights.length !== networkLayers.length - 1) {\n        throw new Error('Weight layers must match network architecture');\n      }\n\n      // Process each layer\n      for (let layerIndex = 0; layerIndex < weights.length; layerIndex++) {\n        const compressedData = await this.compressLayerData(\n          weights[layerIndex],\n          biases[layerIndex]\n        );\n\n        // Save to database via persistence manager\n        // This would call a method we'll add to AgentPersistenceManager\n        await this.saveLayerWeights(agentId, layerIndex, compressedData);\n      }\n\n      const saveTime = performance.now() - startTime;\n      \n      if (saveTime > 30) {\n        console.warn(`⚠️ Neural weight save time exceeded target: ${saveTime.toFixed(2)}ms`);\n      }\n\n      console.log(`💾 Saved neural weights for agent ${agentId} (${saveTime.toFixed(2)}ms)`);\n\n    } catch (error) {\n      const saveTime = performance.now() - startTime;\n      console.error(`❌ Failed to save neural weights for ${agentId} (${saveTime.toFixed(2)}ms):`, error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Load neural weights for an agent with decompression and validation\n   * Performance target: <30ms\n   */\n  async loadNeuralWeights(agentId: string): Promise<{ weights: Float32Array[]; biases: Float32Array[] }> {\n    const startTime = performance.now();\n\n    try {\n      // Load weight records from database\n      const weightRecords = await this.getAgentWeightRecords(agentId);\n      \n      if (weightRecords.length === 0) {\n        throw new Error(`No neural weights found for agent ${agentId}`);\n      }\n\n      const weights: Float32Array[] = [];\n      const biases: Float32Array[] = [];\n\n      // Process each layer in order\n      for (const record of weightRecords.sort((a, b) => a.layerIndex - b.layerIndex)) {\n        // Validate checksum if enabled\n        if (this.checksumValidation) {\n          const expectedChecksum = this.generateChecksum(record.weightData, record.biasData);\n          if (expectedChecksum !== record.checksum) {\n            throw new Error(`Weight corruption detected for agent ${agentId}, layer ${record.layerIndex}`);\n          }\n        }\n\n        // Decompress and deserialize\n        const layerWeights = await this.decompressWeights(record.weightData, record.compressionType);\n        const layerBiases = await this.decompressBiases(record.biasData, record.compressionType);\n\n        weights.push(layerWeights);\n        biases.push(layerBiases);\n      }\n\n      const loadTime = performance.now() - startTime;\n      \n      if (loadTime > 30) {\n        console.warn(`⚠️ Neural weight load time exceeded target: ${loadTime.toFixed(2)}ms`);\n      }\n\n      console.log(`📥 Loaded neural weights for agent ${agentId} (${loadTime.toFixed(2)}ms)`);\n\n      return { weights, biases };\n\n    } catch (error) {\n      const loadTime = performance.now() - startTime;\n      console.error(`❌ Failed to load neural weights for ${agentId} (${loadTime.toFixed(2)}ms):`, error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Compress weight and bias data for a single layer\n   */\n  private async compressLayerData(\n    weights: Float32Array,\n    biases: Float32Array\n  ): Promise<CompressedWeightData> {\n    const startTime = performance.now();\n\n    try {\n      // Convert to buffers\n      const weightBuffer = Buffer.from(weights.buffer);\n      const biasBuffer = Buffer.from(biases.buffer);\n\n      const originalSize = weightBuffer.length + biasBuffer.length;\n      \n      let compressedWeights: Buffer;\n      let compressedBiases: Buffer;\n      let compressionType: 'gzip' | 'none' = 'none';\n\n      // Apply compression if data is large enough\n      if (originalSize > this.compressionThreshold && this.compressionEnabled) {\n        compressedWeights = gzipSync(weightBuffer);\n        compressedBiases = gzipSync(biasBuffer);\n        compressionType = 'gzip';\n      } else {\n        compressedWeights = weightBuffer;\n        compressedBiases = biasBuffer;\n      }\n\n      const compressedSize = compressedWeights.length + compressedBiases.length;\n      const compressionRatio = compressedSize / originalSize;\n\n      // Generate checksum for integrity validation\n      const checksum = this.generateChecksum(compressedWeights, compressedBiases);\n\n      const compressionTime = performance.now() - startTime;\n      \n      console.log(`🗜️ Compressed layer data: ${originalSize} → ${compressedSize} bytes (${(compressionRatio * 100).toFixed(1)}%) in ${compressionTime.toFixed(2)}ms`);\n\n      return {\n        weightData: compressedWeights,\n        biasData: compressedBiases,\n        compressionType,\n        originalSize,\n        compressedSize,\n        compressionRatio,\n        checksum\n      };\n\n    } catch (error) {\n      console.error('❌ Failed to compress layer data:', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Decompress weight data\n   */\n  private async decompressWeights(data: Buffer, compressionType: string): Promise<Float32Array> {\n    try {\n      let decompressedBuffer: Buffer;\n\n      if (compressionType === 'gzip') {\n        decompressedBuffer = gunzipSync(data);\n      } else {\n        decompressedBuffer = data;\n      }\n\n      // Convert back to Float32Array\n      return new Float32Array(decompressedBuffer.buffer.slice(\n        decompressedBuffer.byteOffset,\n        decompressedBuffer.byteOffset + decompressedBuffer.byteLength\n      ));\n\n    } catch (error) {\n      console.error('❌ Failed to decompress weights:', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Decompress bias data\n   */\n  private async decompressBiases(data: Buffer, compressionType: string): Promise<Float32Array> {\n    try {\n      let decompressedBuffer: Buffer;\n\n      if (compressionType === 'gzip') {\n        decompressedBuffer = gunzipSync(data);\n      } else {\n        decompressedBuffer = data;\n      }\n\n      // Convert back to Float32Array\n      return new Float32Array(decompressedBuffer.buffer.slice(\n        decompressedBuffer.byteOffset,\n        decompressedBuffer.byteOffset + decompressedBuffer.byteLength\n      ));\n\n    } catch (error) {\n      console.error('❌ Failed to decompress biases:', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate checksum for data integrity validation\n   */\n  private generateChecksum(weightData: Buffer, biasData: Buffer): string {\n    const hash = crypto.createHash('sha256');\n    hash.update(weightData);\n    hash.update(biasData);\n    return hash.digest('hex');\n  }\n\n  /**\n   * Save compressed layer weights to database\n   * This method will call the persistence manager\n   */\n  private async saveLayerWeights(\n    agentId: string,\n    layerIndex: number,\n    compressedData: CompressedWeightData\n  ): Promise<void> {\n    // This would call a method we need to add to AgentPersistenceManager\n    // For now, we'll implement a placeholder that shows the interface\n    \n    try {\n      // The AgentPersistenceManager would need a method like this:\n      // await this.persistence.saveNeuralWeightRecord({\n      //   agentId,\n      //   layerIndex,\n      //   weightData: compressedData.weightData,\n      //   biasData: compressedData.biasData,\n      //   updatedAt: Date.now(),\n      //   checksum: compressedData.checksum,\n      //   compressionType: compressedData.compressionType\n      // });\n\n      console.log(`💾 Saved layer ${layerIndex} weights for agent ${agentId}`);\n      \n    } catch (error) {\n      console.error(`❌ Failed to save layer weights:`, error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Get agent weight records from database\n   * This method will call the persistence manager\n   */\n  private async getAgentWeightRecords(agentId: string): Promise<any[]> {\n    // This would call a method we need to add to AgentPersistenceManager\n    // For now, we'll return an empty array to show the interface\n    \n    try {\n      // The AgentPersistenceManager would need a method like this:\n      // return await this.persistence.getNeuralWeightRecords(agentId);\n      \n      console.log(`📥 Loading weight records for agent ${agentId}`);\n      return []; // Placeholder\n      \n    } catch (error) {\n      console.error(`❌ Failed to load weight records:`, error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Get compression statistics\n   */\n  getCompressionStats(): {\n    compressionEnabled: boolean;\n    checksumValidation: boolean;\n    compressionThreshold: number;\n  } {\n    return {\n      compressionEnabled: this.compressionEnabled,\n      checksumValidation: this.checksumValidation,\n      compressionThreshold: this.compressionThreshold\n    };\n  }\n\n  /**\n   * Configure compression settings\n   */\n  configureCompression(options: {\n    enabled?: boolean;\n    threshold?: number;\n    validation?: boolean;\n  }): void {\n    if (options.enabled !== undefined) {\n      this.compressionEnabled = options.enabled;\n    }\n    if (options.threshold !== undefined) {\n      this.compressionThreshold = options.threshold;\n    }\n    if (options.validation !== undefined) {\n      this.checksumValidation = options.validation;\n    }\n\n    console.log('⚙️ Neural weight storage configuration updated:', {\n      compressionEnabled: this.compressionEnabled,\n      compressionThreshold: this.compressionThreshold,\n      checksumValidation: this.checksumValidation\n    });\n  }\n}"],"version":3}