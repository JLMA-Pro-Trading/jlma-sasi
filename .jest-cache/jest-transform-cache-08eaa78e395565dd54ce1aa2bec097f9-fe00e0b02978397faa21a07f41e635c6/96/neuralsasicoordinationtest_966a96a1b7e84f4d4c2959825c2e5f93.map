{"file":"/workspaces/agentists-quickstart-workspace-basic/sasi/tests/integration/neural-sasi-coordination.test.ts","mappings":"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","names":[],"sources":["/workspaces/agentists-quickstart-workspace-basic/sasi/tests/integration/neural-sasi-coordination.test.ts"],"sourcesContent":["/**\n * Integration Tests for Neural-SASI Coordination\n * Tests interaction between SASI frontend and neural mesh backend\n */\n\nimport { describe, test, expect, beforeEach, afterEach, jest } from '@jest/globals';\nimport { \n  NeuralAgentFactory, \n  MockNeuralMeshService, \n  TestDataGenerator,\n  NeuralAssertions,\n  PerformanceTestUtils \n} from '../utils/neural-test-utils';\nimport { NeuralMeshService } from '../../src/services/NeuralMeshService';\nimport { Agent } from '../../src/types/agent';\n\ndescribe('Neural-SASI Coordination Integration Tests', () => {\n  let neuralService: MockNeuralMeshService;\n  let memoryDetector: ReturnType<typeof PerformanceTestUtils.createMemoryLeakDetector>;\n\n  beforeEach(async () => {\n    neuralService = new MockNeuralMeshService();\n    await neuralService.initialize();\n    memoryDetector = PerformanceTestUtils.createMemoryLeakDetector();\n  });\n\n  afterEach(async () => {\n    await neuralService.disconnect();\n    NeuralAssertions.assertNoMemoryLeaks(memoryDetector);\n  });\n\n  describe('Service Initialization', () => {\n    test('should initialize neural mesh service successfully', async () => {\n      const service = new MockNeuralMeshService();\n      const initialized = await service.initialize();\n      \n      expect(initialized).toBe(true);\n      \n      const status = service.getConnectionStatus();\n      NeuralAssertions.assertValidMeshConnection(status!);\n      expect(status!.status).toBe('connected');\n      \n      await service.disconnect();\n    });\n\n    test('should establish mesh connection with proper topology', async () => {\n      const status = neuralService.getConnectionStatus();\n      \n      expect(status).not.toBeNull();\n      expect(status!.nodeCount).toBeGreaterThan(0);\n      expect(status!.synapseCount).toBeGreaterThanOrEqual(0);\n      expect(status!.meshId).toMatch(/^mesh_/);\n    });\n\n    test('should emit connection events during initialization', (done) => {\n      const service = new MockNeuralMeshService();\n      \n      service.on('connected', (connection) => {\n        expect(connection).toBeDefined();\n        NeuralAssertions.assertValidMeshConnection(connection);\n        done();\n      });\n\n      service.initialize();\n    });\n\n    test('should handle initialization failure gracefully', async () => {\n      const service = new MockNeuralMeshService();\n      \n      // Mock initialization failure\n      jest.spyOn(service, 'initialize').mockResolvedValue(false);\n      \n      const result = await service.initialize();\n      expect(result).toBe(false);\n    });\n  });\n\n  describe('Multi-Agent Coordination', () => {\n    test('should coordinate multiple agents working on same mesh', async () => {\n      const agentTypes: Agent['type'][] = ['researcher', 'coder', 'tester', 'reviewer'];\n      const agents = [];\n\n      // Create diverse agent team\n      for (const type of agentTypes) {\n        const agent = await neuralService.createNeuralAgent(type);\n        expect(agent).not.toBeNull();\n        agents.push(agent!);\n      }\n\n      // Verify all agents are connected to same mesh\n      const meshIds = agents.map(agent => agent.meshConnection?.meshId);\n      const uniqueMeshIds = new Set(meshIds);\n      expect(uniqueMeshIds.size).toBe(1);\n\n      // Coordinate simultaneous updates\n      const updatePromises = agents.map(agent => neuralService.updateNeuralAgent(agent));\n      const updatedAgents = await Promise.all(updatePromises);\n\n      expect(updatedAgents).toHaveLength(agents.length);\n      updatedAgents.forEach(agent => {\n        NeuralAssertions.assertValidNeuralAgent(agent);\n      });\n    });\n\n    test('should handle agent interactions through mesh', async () => {\n      const agent1 = await neuralService.createNeuralAgent('researcher');\n      const agent2 = await neuralService.createNeuralAgent('coder');\n      \n      expect(agent1).not.toBeNull();\n      expect(agent2).not.toBeNull();\n\n      // Simulate interaction through neural activation\n      agent1!.neuralProperties.activation = 0.8;\n      agent2!.neuralProperties.activation = 0.3;\n\n      await neuralService.updateNeuralAgent(agent1!);\n      await neuralService.updateNeuralAgent(agent2!);\n\n      // Verify both agents maintained their neural state\n      expect(agent1!.neuralProperties.spikeHistory.length).toBeGreaterThan(0);\n      expect(agent2!.neuralProperties.spikeHistory.length).toBeGreaterThan(0);\n    });\n\n    test('should maintain coordination under high load', async () => {\n      const agentCount = 20;\n      const agents = [];\n\n      // Create many agents\n      for (let i = 0; i < agentCount; i++) {\n        const type = ['researcher', 'coder', 'tester', 'reviewer'][i % 4] as Agent['type'];\n        const agent = await neuralService.createNeuralAgent(type);\n        if (agent) agents.push(agent);\n      }\n\n      expect(agents).toHaveLength(agentCount);\n\n      // Perform coordinated updates\n      const startTime = performance.now();\n      await Promise.all(agents.map(agent => neuralService.updateNeuralAgent(agent)));\n      const endTime = performance.now();\n\n      const totalTime = endTime - startTime;\n      const averageTime = totalTime / agentCount;\n\n      expect(averageTime).toBeLessThan(50); // 50ms per agent max\n      expect(totalTime).toBeLessThan(1000); // 1 second total max\n    });\n  });\n\n  describe('Mesh Status and Monitoring', () => {\n    test('should provide real-time mesh status', async () => {\n      const status = await neuralService.getMeshStatus();\n      \n      expect(status).toBeDefined();\n      expect(status.nodeCount).toBeGreaterThanOrEqual(0);\n      expect(status.synapseCount).toBeGreaterThanOrEqual(0);\n      expect(status.activity).toBeGreaterThanOrEqual(0);\n      expect(status.activity).toBeLessThanOrEqual(1);\n      expect(status.connectivity).toBeGreaterThanOrEqual(0);\n      expect(status.connectivity).toBeLessThanOrEqual(1);\n      expect(status.efficiency).toBeGreaterThanOrEqual(0);\n      expect(status.efficiency).toBeLessThanOrEqual(1);\n    });\n\n    test('should track mesh activity changes', async () => {\n      const initialStatus = await neuralService.getMeshStatus();\n      \n      // Create some agents to increase activity\n      await neuralService.createNeuralAgent('neural');\n      await neuralService.createNeuralAgent('neural');\n      \n      const updatedStatus = await neuralService.getMeshStatus();\n      \n      expect(updatedStatus).toBeDefined();\n      // Activity levels may change (in a real system)\n      expect(updatedStatus.activity).toBeGreaterThanOrEqual(0);\n    });\n\n    test('should emit status update events', async () => {\n      const statusPromise = new Promise((resolve) => {\n        neuralService.on('status_update', (status) => {\n          expect(status).toBeDefined();\n          expect(status.activity).toBeGreaterThanOrEqual(0);\n          resolve(status);\n        });\n      });\n\n      // Create agent and manually emit status_update\n      await neuralService.createNeuralAgent('neural');\n      \n      // For this test, manually trigger the status update event\n      const testStatus = {\n        nodeCount: 1,\n        synapseCount: 10,\n        activity: 0.5,\n        connectivity: 0.7,\n        efficiency: 0.8\n      };\n      \n      // Directly emit the event since this is a mock\n      (neuralService as any).emit('status_update', testStatus);\n      \n      await statusPromise;\n    });\n  });\n\n  describe('Neural Training Integration', () => {\n    test('should train mesh with pattern data', async () => {\n      const patterns = TestDataGenerator.generateTrainingPatterns(50);\n      \n      const trained = await neuralService.trainMesh(patterns);\n      expect(trained).toBe(true);\n    });\n\n    test('should emit training completion events', (done) => {\n      const patterns = TestDataGenerator.generateTrainingPatterns(10);\n      \n      neuralService.on('mesh_trained', (result) => {\n        expect(result).toBeDefined();\n        expect(result.patterns).toBe(10);\n        expect(result.accuracy).toBeGreaterThan(0);\n        expect(result.accuracy).toBeLessThanOrEqual(1);\n        done();\n      });\n\n      neuralService.trainMesh(patterns);\n    });\n\n    test('should improve agent performance after training', async () => {\n      const agent = await neuralService.createNeuralAgent('neural');\n      expect(agent).not.toBeNull();\n\n      const initialEfficiency = agent!.efficiency;\n      \n      // Train the mesh\n      const patterns = TestDataGenerator.generateTrainingPatterns(20);\n      await neuralService.trainMesh(patterns);\n      \n      // Update agent (in real system, this might show improvement)\n      await neuralService.updateNeuralAgent(agent!);\n      \n      // Performance may improve (depends on implementation)\n      expect(agent!.efficiency).toBeGreaterThanOrEqual(0);\n    });\n  });\n\n  describe('Data Flow and Synchronization', () => {\n    test('should synchronize agent state across updates', async () => {\n      const agent = await neuralService.createNeuralAgent('neural');\n      expect(agent).not.toBeNull();\n\n      const originalId = agent!.id;\n      const originalNeuralId = agent!.neuralProperties.neuronId;\n\n      // Multiple updates should maintain identity\n      for (let i = 0; i < 5; i++) {\n        await neuralService.updateNeuralAgent(agent!);\n        expect(agent!.id).toBe(originalId);\n        expect(agent!.neuralProperties.neuronId).toBe(originalNeuralId);\n      }\n    });\n\n    test('should handle concurrent agent operations', async () => {\n      const agents = await Promise.all([\n        neuralService.createNeuralAgent('researcher'),\n        neuralService.createNeuralAgent('coder'),\n        neuralService.createNeuralAgent('tester')\n      ]);\n\n      expect(agents.every(agent => agent !== null)).toBe(true);\n\n      // Concurrent updates\n      const updatePromises = agents.map(agent => \n        neuralService.updateNeuralAgent(agent!)\n      );\n\n      const results = await Promise.all(updatePromises);\n      expect(results).toHaveLength(3);\n      results.forEach(agent => {\n        NeuralAssertions.assertValidNeuralAgent(agent);\n      });\n    });\n\n    test('should maintain data consistency during operations', async () => {\n      const agent = await neuralService.createNeuralAgent('neural');\n      expect(agent).not.toBeNull();\n\n      // Verify initial consistency\n      expect(agent!.neuralId).toBe(agent!.neuralProperties.neuronId);\n      expect(agent!.meshConnection!.meshId).toBe(agent!.neuralProperties.meshId);\n\n      // Update and verify consistency maintained\n      await neuralService.updateNeuralAgent(agent!);\n      expect(agent!.neuralId).toBe(agent!.neuralProperties.neuronId);\n      expect(agent!.meshConnection!.meshId).toBe(agent!.neuralProperties.meshId);\n    });\n  });\n\n  describe('Error Recovery and Resilience', () => {\n    test('should recover from temporary disconnections', async () => {\n      const agent = await neuralService.createNeuralAgent('neural');\n      expect(agent).not.toBeNull();\n\n      // Simulate disconnect and reconnect\n      await neuralService.disconnect();\n      expect(neuralService.getConnectionStatus()?.status).toBe('disconnected');\n\n      // Reinitialize\n      await neuralService.initialize();\n      expect(neuralService.getConnectionStatus()?.status).toBe('connected');\n\n      // Should be able to create new agents\n      const newAgent = await neuralService.createNeuralAgent('neural');\n      expect(newAgent).not.toBeNull();\n    });\n\n    test('should handle mesh failures gracefully', async () => {\n      // Mock mesh status failure\n      jest.spyOn(neuralService, 'getMeshStatus').mockResolvedValue(null);\n\n      const status = await neuralService.getMeshStatus();\n      expect(status).toBeNull();\n\n      // Should still be able to create agents\n      const agent = await neuralService.createNeuralAgent('neural');\n      expect(agent).not.toBeNull();\n    });\n\n    test('should maintain partial functionality during degraded mode', async () => {\n      const agent = await neuralService.createNeuralAgent('neural');\n      expect(agent).not.toBeNull();\n\n      // Even with potential issues, basic operations should work\n      const updated = await neuralService.updateNeuralAgent(agent!);\n      expect(updated).toBeDefined();\n      NeuralAssertions.assertValidNeuralAgent(updated);\n    });\n  });\n\n  describe('Performance Integration', () => {\n    test('should meet end-to-end performance requirements', async () => {\n      const results = await PerformanceTestUtils.testNeuralPerformance(\n        neuralService, \n        100, // iterations\n        50   // max time in ms\n      );\n\n      expect(results.passed).toBe(true);\n      NeuralAssertions.assertPerformanceThresholds(\n        { averageTime: results.averageTime, maxTime: results.maxTime },\n        { averageMs: 25, maxMs: 50 }\n      );\n    });\n\n    test('should scale with multiple agents', async () => {\n      const results = await PerformanceTestUtils.testMeshCoordination(\n        neuralService,\n        10, // agent count\n        100 // max time in ms\n      );\n\n      expect(results.passed).toBe(true);\n      expect(results.setupTime).toBeLessThan(100);\n      expect(results.updateTime).toBeLessThan(100);\n    });\n\n    test('should maintain performance under sustained load', async () => {\n      const iterations = 50;\n      const times: number[] = [];\n\n      for (let i = 0; i < iterations; i++) {\n        const start = performance.now();\n        const agent = await neuralService.createNeuralAgent('neural');\n        if (agent) {\n          await neuralService.updateNeuralAgent(agent);\n        }\n        const end = performance.now();\n        times.push(end - start);\n      }\n\n      const averageTime = times.reduce((a, b) => a + b, 0) / times.length;\n      const maxTime = Math.max(...times);\n\n      expect(averageTime).toBeLessThan(50);\n      expect(maxTime).toBeLessThan(100);\n\n      // Performance should not degrade significantly over time\n      const firstHalf = times.slice(0, iterations / 2);\n      const secondHalf = times.slice(iterations / 2);\n      \n      const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;\n      const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;\n      \n      // Second half should not be more than 50% slower than first half\n      expect(secondAvg).toBeLessThan(firstAvg * 1.5);\n    });\n  });\n});"],"version":3}