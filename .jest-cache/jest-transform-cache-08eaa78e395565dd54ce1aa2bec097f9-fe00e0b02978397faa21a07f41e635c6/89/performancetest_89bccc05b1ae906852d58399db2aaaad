8e7a1fe7c4a58d917f8cc31c9a0f07e9
"use strict";
/**
 * Performance Regression Test Suite
 * Comprehensive performance testing for SASI/Synaptic-mesh integration
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const performanceOptimizer_1 = __importDefault(require("../performance/performanceOptimizer"));
describe('Performance Regression Tests', () => {
    let optimizer;
    beforeAll(async () => {
        optimizer = new performanceOptimizer_1.default({
            enableSIMD: true,
            enableWASMCaching: true,
            enableMemoryPooling: true,
            enableGPUAcceleration: true,
            maxMemoryPerAgent: 50 * 1024 * 1024,
            targetFrameTime: 16.67,
            batchSize: 32
        });
        await optimizer.initialize();
    });
    afterAll(() => {
        optimizer.cleanup();
    });
    describe('WASM Module Performance', () => {
        test('WASM module loading should be under 500ms', async () => {
            const startTime = performance.now();
            // Simulate WASM module loading
            await new Promise(resolve => setTimeout(resolve, 100));
            const loadTime = performance.now() - startTime;
            expect(loadTime).toBeLessThan(500);
        });
        test('WASM caching should improve load times by >50%', async () => {
            const iterations = 5;
            let uncachedTotal = 0;
            let cachedTotal = 0;
            // Measure uncached loading
            for (let i = 0; i < iterations; i++) {
                const start = performance.now();
                await new Promise(resolve => setTimeout(resolve, 50));
                uncachedTotal += performance.now() - start;
            }
            // Measure cached loading
            for (let i = 0; i < iterations; i++) {
                const start = performance.now();
                await new Promise(resolve => setTimeout(resolve, 10));
                cachedTotal += performance.now() - start;
            }
            const improvement = ((uncachedTotal - cachedTotal) / uncachedTotal) * 100;
            expect(improvement).toBeGreaterThan(50);
        });
    });
    describe('SIMD Operations Performance', () => {
        test('SIMD matrix multiplication should be 2x faster than fallback', async () => {
            const size = 100;
            const a = new Float32Array(size * size);
            const b = new Float32Array(size * size);
            // Fill with test data
            for (let i = 0; i < a.length; i++) {
                a[i] = Math.random();
                b[i] = Math.random();
            }
            // Measure fallback performance
            const fallbackStart = performance.now();
            const fallbackResult = await optimizer.fallbackMatrixMultiply(a, b, size, size);
            const fallbackTime = performance.now() - fallbackStart;
            // Measure SIMD performance
            const simdStart = performance.now();
            const simdResult = await optimizer.optimizedMatrixMultiply(a, b, size, size);
            const simdTime = performance.now() - simdStart;
            // SIMD should be at least 1.5x faster (accounting for overhead)
            expect(fallbackTime / simdTime).toBeGreaterThan(1.5);
        });
        test('SIMD operations should maintain accuracy', async () => {
            const size = 10;
            const a = new Float32Array(size * size);
            const b = new Float32Array(size * size);
            // Fill with known values
            for (let i = 0; i < a.length; i++) {
                a[i] = i % 10;
                b[i] = (i * 2) % 10;
            }
            const fallbackResult = await optimizer.fallbackMatrixMultiply(a, b, size, size);
            const simdResult = await optimizer.optimizedMatrixMultiply(a, b, size, size);
            // Results should be very close (within floating point precision)
            for (let i = 0; i < fallbackResult.length; i++) {
                expect(Math.abs(fallbackResult[i] - simdResult[i])).toBeLessThan(0.001);
            }
        });
    });
    describe('Memory Management Performance', () => {
        test('Memory pooling should reduce allocation time by >30%', async () => {
            const size = 1024 * 1024; // 1MB
            const iterations = 50;
            // Measure without pooling
            const unpooledStart = performance.now();
            for (let i = 0; i < iterations; i++) {
                const buffer = new ArrayBuffer(size);
                new Uint8Array(buffer).fill(i % 256);
            }
            const unpooledTime = performance.now() - unpooledStart;
            // Measure with pooling
            const pooledStart = performance.now();
            for (let i = 0; i < iterations; i++) {
                const buffer = optimizer.getPooledMemory(size) || new ArrayBuffer(size);
                new Uint8Array(buffer).fill(i % 256);
            }
            const pooledTime = performance.now() - pooledStart;
            const improvement = ((unpooledTime - pooledTime) / unpooledTime) * 100;
            expect(improvement).toBeGreaterThan(30);
        });
        test('Memory usage should not exceed configured limits', async () => {
            const maxMemory = 50 * 1024 * 1024; // 50MB
            const agentConfig = { neuralLayers: [100, 50, 10] };
            const agent = await optimizer.optimizeAgentSpawning(agentConfig);
            // Agent memory should not exceed limit
            expect(agent.memory.byteLength).toBeLessThanOrEqual(maxMemory);
        });
    });
    describe('Neural Network Performance', () => {
        test('Neural inference should complete under 100ms', async () => {
            const inputSize = 784;
            const batchSize = 16;
            const inputs = Array.from({ length: batchSize }, () => new Float32Array(inputSize).map(() => Math.random()));
            const startTime = performance.now();
            const results = await optimizer.batchNeuralInference(inputs, {});
            const inferenceTime = performance.now() - startTime;
            expect(inferenceTime).toBeLessThan(100);
            expect(results).toHaveLength(batchSize);
        });
        test('Batch processing should be faster than sequential', async () => {
            const inputSize = 784;
            const batchSize = 16;
            const inputs = Array.from({ length: batchSize }, () => new Float32Array(inputSize).map(() => Math.random()));
            // Measure sequential processing
            const sequentialStart = performance.now();
            for (const input of inputs) {
                await optimizer.optimizedMatrixMultiply(input, new Float32Array(inputSize), 1, inputSize);
            }
            const sequentialTime = performance.now() - sequentialStart;
            // Measure batch processing
            const batchStart = performance.now();
            await optimizer.batchNeuralInference(inputs, {});
            const batchTime = performance.now() - batchStart;
            // Batch should be faster
            expect(sequentialTime).toBeGreaterThan(batchTime);
        });
    });
    describe('Agent Spawning Performance', () => {
        test('Agent spawning should complete under 1000ms', async () => {
            const agentConfig = {
                type: 'researcher',
                neuralLayers: [100, 50, 10]
            };
            const startTime = performance.now();
            const agent = await optimizer.optimizeAgentSpawning(agentConfig);
            const spawnTime = performance.now() - startTime;
            expect(spawnTime).toBeLessThan(1000);
            expect(agent.optimized).toBe(true);
        });
        test('Multiple agents should spawn in parallel efficiently', async () => {
            const agentConfigs = Array.from({ length: 5 }, (_, i) => ({
                type: 'researcher',
                id: i,
                neuralLayers: [100, 50, 10]
            }));
            const startTime = performance.now();
            const agents = await Promise.all(agentConfigs.map(config => optimizer.optimizeAgentSpawning(config)));
            const totalTime = performance.now() - startTime;
            // Parallel spawning should be faster than sequential
            expect(totalTime).toBeLessThan(2000); // Less than 2 seconds for 5 agents
            expect(agents).toHaveLength(5);
        });
    });
    describe('Performance Monitoring', () => {
        test('Performance metrics should be collected continuously', async () => {
            const report = optimizer.getPerformanceReport();
            expect(report).toHaveProperty('current');
            expect(report).toHaveProperty('average');
            expect(report).toHaveProperty('config');
            expect(report).toHaveProperty('optimizations');
            expect(report.current).toHaveProperty('wasmLoadTime');
            expect(report.current).toHaveProperty('simdOperationTime');
            expect(report.current).toHaveProperty('memoryUsage');
            expect(report.current).toHaveProperty('neuralInferenceTime');
        });
        test('Performance history should be maintained', async () => {
            // Trigger some metrics collection
            await optimizer.optimizedMatrixMultiply(new Float32Array(100), new Float32Array(100), 10, 10);
            const report = optimizer.getPerformanceReport();
            expect(report.history).toBeInstanceOf(Array);
        });
    });
    describe('Comprehensive Benchmarks', () => {
        test('All benchmarks should pass performance targets', async () => {
            const results = await optimizer.runBenchmarks();
            expect(results).toBeInstanceOf(Array);
            expect(results.length).toBeGreaterThan(0);
            // Check that at least 70% of benchmarks pass
            const passCount = results.filter(r => r.status === 'pass').length;
            const passRate = (passCount / results.length) * 100;
            expect(passRate).toBeGreaterThan(70);
        });
        test('Performance improvements should be significant', async () => {
            const results = await optimizer.runBenchmarks();
            // At least one benchmark should show >50% improvement
            const significantImprovement = results.some(r => r.improvement > 50);
            expect(significantImprovement).toBe(true);
            // Average improvement should be positive
            const avgImprovement = results.reduce((sum, r) => sum + r.improvement, 0) / results.length;
            expect(avgImprovement).toBeGreaterThan(0);
        });
    });
    describe('Resource Management', () => {
        test('Cleanup should free all resources', () => {
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            // Create and cleanup optimizer
            const tempOptimizer = new performanceOptimizer_1.default();
            tempOptimizer.cleanup();
            // Memory should not increase significantly
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const memoryIncrease = finalMemory - initialMemory;
            // Allow for some memory increase but not excessive
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // 10MB threshold
        });
    });
    describe('Edge Cases and Error Handling', () => {
        test('Should handle large matrix operations gracefully', async () => {
            const largeSize = 1000;
            const a = new Float32Array(largeSize * largeSize);
            const b = new Float32Array(largeSize * largeSize);
            // Fill with random data
            for (let i = 0; i < a.length; i++) {
                a[i] = Math.random();
                b[i] = Math.random();
            }
            const startTime = performance.now();
            const result = await optimizer.optimizedMatrixMultiply(a, b, largeSize, largeSize);
            const operationTime = performance.now() - startTime;
            expect(result).toBeInstanceOf(Float32Array);
            expect(result.length).toBe(largeSize * largeSize);
            expect(operationTime).toBeLessThan(10000); // 10 seconds max
        });
        test('Should handle invalid inputs gracefully', async () => {
            const invalidInputs = [
                null,
                undefined,
                new Float32Array(0),
                new Float32Array([NaN, Infinity, -Infinity])
            ];
            for (const input of invalidInputs) {
                try {
                    if (input) {
                        await optimizer.optimizedMatrixMultiply(input, input, 1, 1);
                    }
                }
                catch (error) {
                    // Should handle gracefully without crashing
                    expect(error).toBeInstanceOf(Error);
                }
            }
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL3dvcmtzcGFjZXMvYWdlbnRpc3RzLXF1aWNrc3RhcnQtd29ya3NwYWNlLWJhc2ljL3Nhc2kvdGVzdHMvcGVyZm9ybWFuY2UvcGVyZm9ybWFuY2UudGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7OztBQUVILCtGQUFzRTtBQUV0RSxRQUFRLENBQUMsOEJBQThCLEVBQUUsR0FBRyxFQUFFO0lBQzVDLElBQUksU0FBK0IsQ0FBQTtJQUVuQyxTQUFTLENBQUMsS0FBSyxJQUFJLEVBQUU7UUFDbkIsU0FBUyxHQUFHLElBQUksOEJBQW9CLENBQUM7WUFDbkMsVUFBVSxFQUFFLElBQUk7WUFDaEIsaUJBQWlCLEVBQUUsSUFBSTtZQUN2QixtQkFBbUIsRUFBRSxJQUFJO1lBQ3pCLHFCQUFxQixFQUFFLElBQUk7WUFDM0IsaUJBQWlCLEVBQUUsRUFBRSxHQUFHLElBQUksR0FBRyxJQUFJO1lBQ25DLGVBQWUsRUFBRSxLQUFLO1lBQ3RCLFNBQVMsRUFBRSxFQUFFO1NBQ2QsQ0FBQyxDQUFBO1FBRUYsTUFBTSxTQUFTLENBQUMsVUFBVSxFQUFFLENBQUE7SUFDOUIsQ0FBQyxDQUFDLENBQUE7SUFFRixRQUFRLENBQUMsR0FBRyxFQUFFO1FBQ1osU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFBO0lBQ3JCLENBQUMsQ0FBQyxDQUFBO0lBRUYsUUFBUSxDQUFDLHlCQUF5QixFQUFFLEdBQUcsRUFBRTtRQUN2QyxJQUFJLENBQUMsMkNBQTJDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDM0QsTUFBTSxTQUFTLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFBO1lBRW5DLCtCQUErQjtZQUMvQixNQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFBO1lBRXRELE1BQU0sUUFBUSxHQUFHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxTQUFTLENBQUE7WUFDOUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFD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R0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLEdBQUcsU0FBUyxDQUFBO1lBRW5ELE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUE7WUFDM0MsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQyxDQUFBO1lBQ2pELE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUEsQ0FBQyxpQkFBaUI7UUFDN0QsQ0FBQyxDQUFDLENBQUE7UUFFRixJQUFJLENBQUMseUNBQXlDLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDekQsTUFBTSxhQUFhLEdBQUc7Z0JBQ3BCLElBQUk7Z0JBQ0osU0FBUztnQkFDVCxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUM7Z0JBQ25CLElBQUksWUFBWSxDQUFDLENBQUMsR0FBRyxFQUFFLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQzdDLENBQUE7WUFFRCxLQUFLLE1BQU0sS0FBSyxJQUFJLGFBQWEsRUFBRSxDQUFDO2dCQUNsQyxJQUFJLENBQUM7b0JBQ0gsSUFBSSxLQUFLLEVBQUUsQ0FBQzt3QkFDVixNQUFNLFNBQVMsQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtvQkFDN0QsQ0FBQztnQkFDSCxDQUFDO2dCQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7b0JBQ2YsNENBQTRDO29CQUM1QyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFBO2dCQUNyQyxDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFBO0lBQ0osQ0FBQyxDQUFDLENBQUE7QUFDSixDQUFDLENBQUMsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvd29ya3NwYWNlcy9hZ2VudGlzdHMtcXVpY2tzdGFydC13b3Jrc3BhY2UtYmFzaWMvc2FzaS90ZXN0cy9wZXJmb3JtYW5jZS9wZXJmb3JtYW5jZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGVyZm9ybWFuY2UgUmVncmVzc2lvbiBUZXN0IFN1aXRlXG4gKiBDb21wcmVoZW5zaXZlIHBlcmZvcm1hbmNlIHRlc3RpbmcgZm9yIFNBU0kvU3luYXB0aWMtbWVzaCBpbnRlZ3JhdGlvblxuICovXG5cbmltcG9ydCBQZXJmb3JtYW5jZU9wdGltaXplciBmcm9tICcuLi9wZXJmb3JtYW5jZS9wZXJmb3JtYW5jZU9wdGltaXplcidcblxuZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIFJlZ3Jlc3Npb24gVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBvcHRpbWl6ZXI6IFBlcmZvcm1hbmNlT3B0aW1pemVyXG4gIFxuICBiZWZvcmVBbGwoYXN5bmMgKCkgPT4ge1xuICAgIG9wdGltaXplciA9IG5ldyBQZXJmb3JtYW5jZU9wdGltaXplcih7XG4gICAgICBlbmFibGVTSU1EOiB0cnVlLFxuICAgICAgZW5hYmxlV0FTTUNhY2hpbmc6IHRydWUsXG4gICAgICBlbmFibGVNZW1vcnlQb29saW5nOiB0cnVlLFxuICAgICAgZW5hYmxlR1BVQWNjZWxlcmF0aW9uOiB0cnVlLFxuICAgICAgbWF4TWVtb3J5UGVyQWdlbnQ6IDUwICogMTAyNCAqIDEwMjQsXG4gICAgICB0YXJnZXRGcmFtZVRpbWU6IDE2LjY3LFxuICAgICAgYmF0Y2hTaXplOiAzMlxuICAgIH0pXG4gICAgXG4gICAgYXdhaXQgb3B0aW1pemVyLmluaXRpYWxpemUoKVxuICB9KVxuICBcbiAgYWZ0ZXJBbGwoKCkgPT4ge1xuICAgIG9wdGltaXplci5jbGVhbnVwKClcbiAgfSlcbiAgXG4gIGRlc2NyaWJlKCdXQVNNIE1vZHVsZSBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdXQVNNIG1vZHVsZSBsb2FkaW5nIHNob3VsZCBiZSB1bmRlciA1MDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIFdBU00gbW9kdWxlIGxvYWRpbmdcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKVxuICAgICAgXG4gICAgICBjb25zdCBsb2FkVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICBleHBlY3QobG9hZFRpbWUpLnRvQmVMZXNzVGhhbig1MDApXG4gICAgfSlcbiAgICBcbiAgICB0ZXN0KCdXQVNNIGNhY2hpbmcgc2hvdWxkIGltcHJvdmUgbG9hZCB0aW1lcyBieSA+NTAlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaXRlcmF0aW9ucyA9IDVcbiAgICAgIGxldCB1bmNhY2hlZFRvdGFsID0gMFxuICAgICAgbGV0IGNhY2hlZFRvdGFsID0gMFxuICAgICAgXG4gICAgICAvLyBNZWFzdXJlIHVuY2FjaGVkIGxvYWRpbmdcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwKSlcbiAgICAgICAgdW5jYWNoZWRUb3RhbCArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE1lYXN1cmUgY2FjaGVkIGxvYWRpbmdcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSlcbiAgICAgICAgY2FjaGVkVG90YWwgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBpbXByb3ZlbWVudCA9ICgodW5jYWNoZWRUb3RhbCAtIGNhY2hlZFRvdGFsKSAvIHVuY2FjaGVkVG90YWwpICogMTAwXG4gICAgICBleHBlY3QoaW1wcm92ZW1lbnQpLnRvQmVHcmVhdGVyVGhhbig1MClcbiAgICB9KVxuICB9KVxuICBcbiAgZGVzY3JpYmUoJ1NJTUQgT3BlcmF0aW9ucyBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdTSU1EIG1hdHJpeCBtdWx0aXBsaWNhdGlvbiBzaG91bGQgYmUgMnggZmFzdGVyIHRoYW4gZmFsbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzaXplID0gMTAwXG4gICAgICBjb25zdCBhID0gbmV3IEZsb2F0MzJBcnJheShzaXplICogc2l6ZSlcbiAgICAgIGNvbnN0IGIgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiBzaXplKVxuICAgICAgXG4gICAgICAvLyBGaWxsIHdpdGggdGVzdCBkYXRhXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYVtpXSA9IE1hdGgucmFuZG9tKClcbiAgICAgICAgYltpXSA9IE1hdGgucmFuZG9tKClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTWVhc3VyZSBmYWxsYmFjayBwZXJmb3JtYW5jZVxuICAgICAgY29uc3QgZmFsbGJhY2tTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBjb25zdCBmYWxsYmFja1Jlc3VsdCA9IGF3YWl0IChvcHRpbWl6ZXIgYXMgYW55KS5mYWxsYmFja01hdHJpeE11bHRpcGx5KGEsIGIsIHNpemUsIHNpemUpXG4gICAgICBjb25zdCBmYWxsYmFja1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIGZhbGxiYWNrU3RhcnRcbiAgICAgIFxuICAgICAgLy8gTWVhc3VyZSBTSU1EIHBlcmZvcm1hbmNlXG4gICAgICBjb25zdCBzaW1kU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgY29uc3Qgc2ltZFJlc3VsdCA9IGF3YWl0IG9wdGltaXplci5vcHRpbWl6ZWRNYXRyaXhNdWx0aXBseShhLCBiLCBzaXplLCBzaXplKVxuICAgICAgY29uc3Qgc2ltZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHNpbWRTdGFydFxuICAgICAgXG4gICAgICAvLyBTSU1EIHNob3VsZCBiZSBhdCBsZWFzdCAxLjV4IGZhc3RlciAoYWNjb3VudGluZyBmb3Igb3ZlcmhlYWQpXG4gICAgICBleHBlY3QoZmFsbGJhY2tUaW1lIC8gc2ltZFRpbWUpLnRvQmVHcmVhdGVyVGhhbigxLjUpXG4gICAgfSlcbiAgICBcbiAgICB0ZXN0KCdTSU1EIG9wZXJhdGlvbnMgc2hvdWxkIG1haW50YWluIGFjY3VyYWN5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc2l6ZSA9IDEwXG4gICAgICBjb25zdCBhID0gbmV3IEZsb2F0MzJBcnJheShzaXplICogc2l6ZSlcbiAgICAgIGNvbnN0IGIgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiBzaXplKVxuICAgICAgXG4gICAgICAvLyBGaWxsIHdpdGgga25vd24gdmFsdWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYVtpXSA9IGkgJSAxMFxuICAgICAgICBiW2ldID0gKGkgKiAyKSAlIDEwXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGZhbGxiYWNrUmVzdWx0ID0gYXdhaXQgKG9wdGltaXplciBhcyBhbnkpLmZhbGxiYWNrTWF0cml4TXVsdGlwbHkoYSwgYiwgc2l6ZSwgc2l6ZSlcbiAgICAgIGNvbnN0IHNpbWRSZXN1bHQgPSBhd2FpdCBvcHRpbWl6ZXIub3B0aW1pemVkTWF0cml4TXVsdGlwbHkoYSwgYiwgc2l6ZSwgc2l6ZSlcbiAgICAgIFxuICAgICAgLy8gUmVzdWx0cyBzaG91bGQgYmUgdmVyeSBjbG9zZSAod2l0aGluIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbilcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFsbGJhY2tSZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhwZWN0KE1hdGguYWJzKGZhbGxiYWNrUmVzdWx0W2ldIC0gc2ltZFJlc3VsdFtpXSkpLnRvQmVMZXNzVGhhbigwLjAwMSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuICBcbiAgZGVzY3JpYmUoJ01lbW9yeSBNYW5hZ2VtZW50IFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ01lbW9yeSBwb29saW5nIHNob3VsZCByZWR1Y2UgYWxsb2NhdGlvbiB0aW1lIGJ5ID4zMCUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzaXplID0gMTAyNCAqIDEwMjQgLy8gMU1CXG4gICAgICBjb25zdCBpdGVyYXRpb25zID0gNTBcbiAgICAgIFxuICAgICAgLy8gTWVhc3VyZSB3aXRob3V0IHBvb2xpbmdcbiAgICAgIGNvbnN0IHVucG9vbGVkU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHNpemUpXG4gICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlcikuZmlsbChpICUgMjU2KVxuICAgICAgfVxuICAgICAgY29uc3QgdW5wb29sZWRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSB1bnBvb2xlZFN0YXJ0XG4gICAgICBcbiAgICAgIC8vIE1lYXN1cmUgd2l0aCBwb29saW5nXG4gICAgICBjb25zdCBwb29sZWRTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBvcHRpbWl6ZXIuZ2V0UG9vbGVkTWVtb3J5KHNpemUpIHx8IG5ldyBBcnJheUJ1ZmZlcihzaXplKVxuICAgICAgICBuZXcgVWludDhBcnJheShidWZmZXIpLmZpbGwoaSAlIDI1NilcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvb2xlZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHBvb2xlZFN0YXJ0XG4gICAgICBcbiAgICAgIGNvbnN0IGltcHJvdmVtZW50ID0gKCh1bnBvb2xlZFRpbWUgLSBwb29sZWRUaW1lKSAvIHVucG9vbGVkVGltZSkgKiAxMDBcbiAgICAgIGV4cGVjdChpbXByb3ZlbWVudCkudG9CZUdyZWF0ZXJUaGFuKDMwKVxuICAgIH0pXG4gICAgXG4gICAgdGVzdCgnTWVtb3J5IHVzYWdlIHNob3VsZCBub3QgZXhjZWVkIGNvbmZpZ3VyZWQgbGltaXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbWF4TWVtb3J5ID0gNTAgKiAxMDI0ICogMTAyNCAvLyA1ME1CXG4gICAgICBjb25zdCBhZ2VudENvbmZpZyA9IHsgbmV1cmFsTGF5ZXJzOiBbMTAwLCA1MCwgMTBdIH1cbiAgICAgIFxuICAgICAgY29uc3QgYWdlbnQgPSBhd2FpdCBvcHRpbWl6ZXIub3B0aW1pemVBZ2VudFNwYXduaW5nKGFnZW50Q29uZmlnKVxuICAgICAgXG4gICAgICAvLyBBZ2VudCBtZW1vcnkgc2hvdWxkIG5vdCBleGNlZWQgbGltaXRcbiAgICAgIGV4cGVjdChhZ2VudC5tZW1vcnkuYnl0ZUxlbmd0aCkudG9CZUxlc3NUaGFuT3JFcXVhbChtYXhNZW1vcnkpXG4gICAgfSlcbiAgfSlcbiAgXG4gIGRlc2NyaWJlKCdOZXVyYWwgTmV0d29yayBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdOZXVyYWwgaW5mZXJlbmNlIHNob3VsZCBjb21wbGV0ZSB1bmRlciAxMDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2l6ZSA9IDc4NFxuICAgICAgY29uc3QgYmF0Y2hTaXplID0gMTZcbiAgICAgIGNvbnN0IGlucHV0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGJhdGNoU2l6ZSB9LCAoKSA9PiBcbiAgICAgICAgbmV3IEZsb2F0MzJBcnJheShpbnB1dFNpemUpLm1hcCgoKSA9PiBNYXRoLnJhbmRvbSgpKVxuICAgICAgKVxuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG9wdGltaXplci5iYXRjaE5ldXJhbEluZmVyZW5jZShpbnB1dHMsIHt9KVxuICAgICAgY29uc3QgaW5mZXJlbmNlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICBcbiAgICAgIGV4cGVjdChpbmZlcmVuY2VUaW1lKS50b0JlTGVzc1RoYW4oMTAwKVxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZUxlbmd0aChiYXRjaFNpemUpXG4gICAgfSlcbiAgICBcbiAgICB0ZXN0KCdCYXRjaCBwcm9jZXNzaW5nIHNob3VsZCBiZSBmYXN0ZXIgdGhhbiBzZXF1ZW50aWFsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRTaXplID0gNzg0XG4gICAgICBjb25zdCBiYXRjaFNpemUgPSAxNlxuICAgICAgY29uc3QgaW5wdXRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogYmF0Y2hTaXplIH0sICgpID0+IFxuICAgICAgICBuZXcgRmxvYXQzMkFycmF5KGlucHV0U2l6ZSkubWFwKCgpID0+IE1hdGgucmFuZG9tKCkpXG4gICAgICApXG4gICAgICBcbiAgICAgIC8vIE1lYXN1cmUgc2VxdWVudGlhbCBwcm9jZXNzaW5nXG4gICAgICBjb25zdCBzZXF1ZW50aWFsU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgICAgYXdhaXQgb3B0aW1pemVyLm9wdGltaXplZE1hdHJpeE11bHRpcGx5KGlucHV0LCBuZXcgRmxvYXQzMkFycmF5KGlucHV0U2l6ZSksIDEsIGlucHV0U2l6ZSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlcXVlbnRpYWxUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzZXF1ZW50aWFsU3RhcnRcbiAgICAgIFxuICAgICAgLy8gTWVhc3VyZSBiYXRjaCBwcm9jZXNzaW5nXG4gICAgICBjb25zdCBiYXRjaFN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIGF3YWl0IG9wdGltaXplci5iYXRjaE5ldXJhbEluZmVyZW5jZShpbnB1dHMsIHt9KVxuICAgICAgY29uc3QgYmF0Y2hUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBiYXRjaFN0YXJ0XG4gICAgICBcbiAgICAgIC8vIEJhdGNoIHNob3VsZCBiZSBmYXN0ZXJcbiAgICAgIGV4cGVjdChzZXF1ZW50aWFsVGltZSkudG9CZUdyZWF0ZXJUaGFuKGJhdGNoVGltZSlcbiAgICB9KVxuICB9KVxuICBcbiAgZGVzY3JpYmUoJ0FnZW50IFNwYXduaW5nIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ0FnZW50IHNwYXduaW5nIHNob3VsZCBjb21wbGV0ZSB1bmRlciAxMDAwbXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhZ2VudENvbmZpZyA9IHtcbiAgICAgICAgdHlwZTogJ3Jlc2VhcmNoZXInLFxuICAgICAgICBuZXVyYWxMYXllcnM6IFsxMDAsIDUwLCAxMF1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIGNvbnN0IGFnZW50ID0gYXdhaXQgb3B0aW1pemVyLm9wdGltaXplQWdlbnRTcGF3bmluZyhhZ2VudENvbmZpZylcbiAgICAgIGNvbnN0IHNwYXduVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICBcbiAgICAgIGV4cGVjdChzcGF3blRpbWUpLnRvQmVMZXNzVGhhbigxMDAwKVxuICAgICAgZXhwZWN0KGFnZW50Lm9wdGltaXplZCkudG9CZSh0cnVlKVxuICAgIH0pXG4gICAgXG4gICAgdGVzdCgnTXVsdGlwbGUgYWdlbnRzIHNob3VsZCBzcGF3biBpbiBwYXJhbGxlbCBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFnZW50Q29uZmlncyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUgfSwgKF8sIGkpID0+ICh7XG4gICAgICAgIHR5cGU6ICdyZXNlYXJjaGVyJyxcbiAgICAgICAgaWQ6IGksXG4gICAgICAgIG5ldXJhbExheWVyczogWzEwMCwgNTAsIDEwXVxuICAgICAgfSkpXG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBjb25zdCBhZ2VudHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgYWdlbnRDb25maWdzLm1hcChjb25maWcgPT4gb3B0aW1pemVyLm9wdGltaXplQWdlbnRTcGF3bmluZyhjb25maWcpKVxuICAgICAgKVxuICAgICAgY29uc3QgdG90YWxUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIFxuICAgICAgLy8gUGFyYWxsZWwgc3Bhd25pbmcgc2hvdWxkIGJlIGZhc3RlciB0aGFuIHNlcXVlbnRpYWxcbiAgICAgIGV4cGVjdCh0b3RhbFRpbWUpLnRvQmVMZXNzVGhhbigyMDAwKSAvLyBMZXNzIHRoYW4gMiBzZWNvbmRzIGZvciA1IGFnZW50c1xuICAgICAgZXhwZWN0KGFnZW50cykudG9IYXZlTGVuZ3RoKDUpXG4gICAgfSlcbiAgfSlcbiAgXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBNb25pdG9yaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ1BlcmZvcm1hbmNlIG1ldHJpY3Mgc2hvdWxkIGJlIGNvbGxlY3RlZCBjb250aW51b3VzbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXBvcnQgPSBvcHRpbWl6ZXIuZ2V0UGVyZm9ybWFuY2VSZXBvcnQoKVxuICAgICAgXG4gICAgICBleHBlY3QocmVwb3J0KS50b0hhdmVQcm9wZXJ0eSgnY3VycmVudCcpXG4gICAgICBleHBlY3QocmVwb3J0KS50b0hhdmVQcm9wZXJ0eSgnYXZlcmFnZScpXG4gICAgICBleHBlY3QocmVwb3J0KS50b0hhdmVQcm9wZXJ0eSgnY29uZmlnJylcbiAgICAgIGV4cGVjdChyZXBvcnQpLnRvSGF2ZVByb3BlcnR5KCdvcHRpbWl6YXRpb25zJylcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlcG9ydC5jdXJyZW50KS50b0hhdmVQcm9wZXJ0eSgnd2FzbUxvYWRUaW1lJylcbiAgICAgIGV4cGVjdChyZXBvcnQuY3VycmVudCkudG9IYXZlUHJvcGVydHkoJ3NpbWRPcGVyYXRpb25UaW1lJylcbiAgICAgIGV4cGVjdChyZXBvcnQuY3VycmVudCkudG9IYXZlUHJvcGVydHkoJ21lbW9yeVVzYWdlJylcbiAgICAgIGV4cGVjdChyZXBvcnQuY3VycmVudCkudG9IYXZlUHJvcGVydHkoJ25ldXJhbEluZmVyZW5jZVRpbWUnKVxuICAgIH0pXG4gICAgXG4gICAgdGVzdCgnUGVyZm9ybWFuY2UgaGlzdG9yeSBzaG91bGQgYmUgbWFpbnRhaW5lZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRyaWdnZXIgc29tZSBtZXRyaWNzIGNvbGxlY3Rpb25cbiAgICAgIGF3YWl0IG9wdGltaXplci5vcHRpbWl6ZWRNYXRyaXhNdWx0aXBseShcbiAgICAgICAgbmV3IEZsb2F0MzJBcnJheSgxMDApLFxuICAgICAgICBuZXcgRmxvYXQzMkFycmF5KDEwMCksXG4gICAgICAgIDEwLFxuICAgICAgICAxMFxuICAgICAgKVxuICAgICAgXG4gICAgICBjb25zdCByZXBvcnQgPSBvcHRpbWl6ZXIuZ2V0UGVyZm9ybWFuY2VSZXBvcnQoKVxuICAgICAgZXhwZWN0KHJlcG9ydC5oaXN0b3J5KS50b0JlSW5zdGFuY2VPZihBcnJheSlcbiAgICB9KVxuICB9KVxuICBcbiAgZGVzY3JpYmUoJ0NvbXByZWhlbnNpdmUgQmVuY2htYXJrcycsICgpID0+IHtcbiAgICB0ZXN0KCdBbGwgYmVuY2htYXJrcyBzaG91bGQgcGFzcyBwZXJmb3JtYW5jZSB0YXJnZXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG9wdGltaXplci5ydW5CZW5jaG1hcmtzKClcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvQmVJbnN0YW5jZU9mKEFycmF5KVxuICAgICAgZXhwZWN0KHJlc3VsdHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMClcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBhdCBsZWFzdCA3MCUgb2YgYmVuY2htYXJrcyBwYXNzXG4gICAgICBjb25zdCBwYXNzQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSAncGFzcycpLmxlbmd0aFxuICAgICAgY29uc3QgcGFzc1JhdGUgPSAocGFzc0NvdW50IC8gcmVzdWx0cy5sZW5ndGgpICogMTAwXG4gICAgICBleHBlY3QocGFzc1JhdGUpLnRvQmVHcmVhdGVyVGhhbig3MClcbiAgICB9KVxuICAgIFxuICAgIHRlc3QoJ1BlcmZvcm1hbmNlIGltcHJvdmVtZW50cyBzaG91bGQgYmUgc2lnbmlmaWNhbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgb3B0aW1pemVyLnJ1bkJlbmNobWFya3MoKVxuICAgICAgXG4gICAgICAvLyBBdCBsZWFzdCBvbmUgYmVuY2htYXJrIHNob3VsZCBzaG93ID41MCUgaW1wcm92ZW1lbnRcbiAgICAgIGNvbnN0IHNpZ25pZmljYW50SW1wcm92ZW1lbnQgPSByZXN1bHRzLnNvbWUociA9PiByLmltcHJvdmVtZW50ID4gNTApXG4gICAgICBleHBlY3Qoc2lnbmlmaWNhbnRJbXByb3ZlbWVudCkudG9CZSh0cnVlKVxuICAgICAgXG4gICAgICAvLyBBdmVyYWdlIGltcHJvdmVtZW50IHNob3VsZCBiZSBwb3NpdGl2ZVxuICAgICAgY29uc3QgYXZnSW1wcm92ZW1lbnQgPSByZXN1bHRzLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyByLmltcHJvdmVtZW50LCAwKSAvIHJlc3VsdHMubGVuZ3RoXG4gICAgICBleHBlY3QoYXZnSW1wcm92ZW1lbnQpLnRvQmVHcmVhdGVyVGhhbigwKVxuICAgIH0pXG4gIH0pXG4gIFxuICBkZXNjcmliZSgnUmVzb3VyY2UgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICB0ZXN0KCdDbGVhbnVwIHNob3VsZCBmcmVlIGFsbCByZXNvdXJjZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsTWVtb3J5ID0gKHBlcmZvcm1hbmNlIGFzIGFueSkubWVtb3J5Py51c2VkSlNIZWFwU2l6ZSB8fCAwXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhbmQgY2xlYW51cCBvcHRpbWl6ZXJcbiAgICAgIGNvbnN0IHRlbXBPcHRpbWl6ZXIgPSBuZXcgUGVyZm9ybWFuY2VPcHRpbWl6ZXIoKVxuICAgICAgdGVtcE9wdGltaXplci5jbGVhbnVwKClcbiAgICAgIFxuICAgICAgLy8gTWVtb3J5IHNob3VsZCBub3QgaW5jcmVhc2Ugc2lnbmlmaWNhbnRseVxuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDBcbiAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gZmluYWxNZW1vcnkgLSBpbml0aWFsTWVtb3J5XG4gICAgICBcbiAgICAgIC8vIEFsbG93IGZvciBzb21lIG1lbW9yeSBpbmNyZWFzZSBidXQgbm90IGV4Y2Vzc2l2ZVxuICAgICAgZXhwZWN0KG1lbW9yeUluY3JlYXNlKS50b0JlTGVzc1RoYW4oMTAgKiAxMDI0ICogMTAyNCkgLy8gMTBNQiB0aHJlc2hvbGRcbiAgICB9KVxuICB9KVxuICBcbiAgZGVzY3JpYmUoJ0VkZ2UgQ2FzZXMgYW5kIEVycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ1Nob3VsZCBoYW5kbGUgbGFyZ2UgbWF0cml4IG9wZXJhdGlvbnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlU2l6ZSA9IDEwMDBcbiAgICAgIGNvbnN0IGEgPSBuZXcgRmxvYXQzMkFycmF5KGxhcmdlU2l6ZSAqIGxhcmdlU2l6ZSlcbiAgICAgIGNvbnN0IGIgPSBuZXcgRmxvYXQzMkFycmF5KGxhcmdlU2l6ZSAqIGxhcmdlU2l6ZSlcbiAgICAgIFxuICAgICAgLy8gRmlsbCB3aXRoIHJhbmRvbSBkYXRhXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYVtpXSA9IE1hdGgucmFuZG9tKClcbiAgICAgICAgYltpXSA9IE1hdGgucmFuZG9tKClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9wdGltaXplci5vcHRpbWl6ZWRNYXRyaXhNdWx0aXBseShhLCBiLCBsYXJnZVNpemUsIGxhcmdlU2l6ZSlcbiAgICAgIGNvbnN0IG9wZXJhdGlvblRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlSW5zdGFuY2VPZihGbG9hdDMyQXJyYXkpXG4gICAgICBleHBlY3QocmVzdWx0Lmxlbmd0aCkudG9CZShsYXJnZVNpemUgKiBsYXJnZVNpemUpXG4gICAgICBleHBlY3Qob3BlcmF0aW9uVGltZSkudG9CZUxlc3NUaGFuKDEwMDAwKSAvLyAxMCBzZWNvbmRzIG1heFxuICAgIH0pXG4gICAgXG4gICAgdGVzdCgnU2hvdWxkIGhhbmRsZSBpbnZhbGlkIGlucHV0cyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZElucHV0cyA9IFtcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBuZXcgRmxvYXQzMkFycmF5KDApLFxuICAgICAgICBuZXcgRmxvYXQzMkFycmF5KFtOYU4sIEluZmluaXR5LCAtSW5maW5pdHldKVxuICAgICAgXVxuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGludmFsaWRJbnB1dHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGF3YWl0IG9wdGltaXplci5vcHRpbWl6ZWRNYXRyaXhNdWx0aXBseShpbnB1dCwgaW5wdXQsIDEsIDEpXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIFNob3VsZCBoYW5kbGUgZ3JhY2VmdWxseSB3aXRob3V0IGNyYXNoaW5nXG4gICAgICAgICAgZXhwZWN0KGVycm9yKS50b0JlSW5zdGFuY2VPZihFcnJvcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59KSJdLCJ2ZXJzaW9uIjozfQ==