e9def69520cdff9c9ff239ee5da04368
"use strict";
/**
 * Neural Agent Persistence Tests for Phase 2A
 * Tests SQLite persistence with performance thresholds and data integrity
 */
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const sqlite_setup_1 = require("../sqlite-setup");
const performance_setup_1 = require("../performance-setup");
describe('Neural Agent Persistence', () => {
    let db;
    beforeEach(async () => {
        db = await sqlite_setup_1.sqliteTestUtils.createTestDatabase();
    });
    afterEach(async () => {
        if (db) {
            db.close();
        }
    });
    describe('Agent State Persistence', () => {
        test('should save agent state within performance threshold (<75ms)', async () => {
            const agentData = sqlite_setup_1.sqliteTestUtils.generateAgentStateData({
                id: 'test-agent-persistence-001',
                agent_type: 'mlp',
                neural_config: JSON.stringify({
                    type: 'mlp',
                    architecture: [10, 5, 1],
                    activationFunction: 'relu'
                })
            });
            const { duration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('agent-state-save', async () => {
                await new Promise((resolve, reject) => {
                    sqlite_setup_1.mockSQLiteDB.run('INSERT INTO agent_states (id, agent_type, neural_config, created_at, last_active) VALUES (?, ?, ?, ?, ?)', [agentData.id, agentData.agent_type, agentData.neural_config, agentData.created_at, agentData.last_active], (err) => err ? reject(err) : resolve(undefined));
                });
            });
            // Assert performance threshold
            expect(duration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.PERSISTENCE_SAVE);
            // Verify data saved correctly
            const savedAgent = sqlite_setup_1.mockSQLiteDB.getTestData('agent_states')
                .find((agent) => agent.id === agentData.id);
            expect(savedAgent).toBeDefined();
            expect(savedAgent.agent_type).toBe(agentData.agent_type);
        });
        test('should load agent state within performance threshold (<100ms)', async () => {
            // Setup test data
            const agentData = sqlite_setup_1.sqliteTestUtils.generateAgentStateData();
            sqlite_setup_1.mockSQLiteDB.setTestData('agent_states', [agentData]);
            const { result, duration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('agent-state-load', async () => {
                return new Promise((resolve, reject) => {
                    sqlite_setup_1.mockSQLiteDB.get('SELECT * FROM agent_states WHERE id = ?', [agentData.id], (err, row) => err ? reject(err) : resolve(row));
                });
            });
            // Assert performance threshold
            expect(duration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.PERSISTENCE_LOAD);
            // Verify data loaded correctly
            expect(result).toBeDefined();
            expect(result.id).toBe(agentData.id);
        });
        test('should handle batch save operations efficiently', async () => {
            const agentCount = 10;
            const agentDataList = Array.from({ length: agentCount }, () => sqlite_setup_1.sqliteTestUtils.generateAgentStateData());
            const { duration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('batch-agent-save', async () => {
                for (const agentData of agentDataList) {
                    await new Promise((resolve, reject) => {
                        sqlite_setup_1.mockSQLiteDB.run('INSERT INTO agent_states (id, agent_type, neural_config, created_at, last_active) VALUES (?, ?, ?, ?, ?)', [agentData.id, agentData.agent_type, agentData.neural_config, agentData.created_at, agentData.last_active], (err) => err ? reject(err) : resolve(undefined));
                    });
                }
            });
            // Batch operations should complete within reasonable time
            expect(duration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.BATCH_PROCESSING);
            // Verify all agents saved
            const savedAgents = sqlite_setup_1.mockSQLiteDB.getTestData('agent_states');
            expect(savedAgents).toHaveLength(agentCount);
        });
    });
    describe('Neural Weights Persistence', () => {
        test('should save and load neural weights with data integrity', async () => {
            const agentId = 'weight-test-agent-001';
            const weights = new Float32Array([0.1, 0.2, 0.3, 0.4, 0.5]);
            const biases = new Float32Array([0.01, 0.02]);
            const agentData = sqlite_setup_1.sqliteTestUtils.generateAgentStateData({
                id: agentId,
                weights: Buffer.from(weights.buffer),
                biases: Buffer.from(biases.buffer)
            });
            // Save weights
            const { duration: saveDuration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('weights-save', async () => {
                await new Promise((resolve, reject) => {
                    sqlite_setup_1.mockSQLiteDB.run('INSERT INTO agent_states (id, agent_type, neural_config, weights, biases, created_at, last_active) VALUES (?, ?, ?, ?, ?, ?, ?)', [agentData.id, agentData.agent_type, agentData.neural_config, agentData.weights, agentData.biases, agentData.created_at, agentData.last_active], (err) => err ? reject(err) : resolve(undefined));
                });
            });
            expect(saveDuration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.PERSISTENCE_SAVE);
            // Load weights
            const { result: loadedAgent, duration: loadDuration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('weights-load', async () => {
                return new Promise((resolve, reject) => {
                    sqlite_setup_1.mockSQLiteDB.get('SELECT * FROM agent_states WHERE id = ?', [agentId], (err, row) => err ? reject(err) : resolve(row));
                });
            });
            expect(loadDuration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.PERSISTENCE_LOAD);
            // Verify data integrity
            expect(loadedAgent).toBeDefined();
            expect(loadedAgent.id).toBe(agentId);
            // Note: In real implementation, you'd verify Buffer.from(weights.buffer) matches
        });
    });
    describe('Training Session Persistence', () => {
        test('should persist training sessions with performance metrics', async () => {
            const agentId = 'training-agent-001';
            const sessionData = sqlite_setup_1.sqliteTestUtils.generateTrainingSessionData(agentId, {
                epochs: 50,
                final_accuracy: 0.92,
                convergence_epoch: 35
            });
            const { duration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('training-session-save', async () => {
                await new Promise((resolve, reject) => {
                    sqlite_setup_1.mockSQLiteDB.run('INSERT INTO training_sessions (session_id, agent_id, start_time, end_time, epochs, data_points, final_accuracy) VALUES (?, ?, ?, ?, ?, ?, ?)', [sessionData.session_id, sessionData.agent_id, sessionData.start_time, sessionData.end_time, sessionData.epochs, sessionData.data_points, sessionData.final_accuracy], (err) => err ? reject(err) : resolve(undefined));
                });
            });
            expect(duration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.PERSISTENCE_SAVE);
            // Verify training session data integrity
            const savedSessions = sqlite_setup_1.mockSQLiteDB.getTestData('training_sessions');
            const savedSession = savedSessions.find((s) => s.session_id === sessionData.session_id);
            expect(savedSession).toBeDefined();
            expect(savedSession.final_accuracy).toBe(sessionData.final_accuracy);
        });
    });
    describe('Cross-Session Persistence', () => {
        test('should maintain data integrity across sessions', async () => {
            const agentId = 'cross-session-agent-001';
            const originalData = sqlite_setup_1.sqliteTestUtils.generateAgentStateData({
                id: agentId,
                total_inferences: 150,
                learning_progress: 0.85
            });
            // Simulate session 1: Save agent state
            sqlite_setup_1.mockSQLiteDB.setTestData('agent_states', [originalData]);
            // Simulate session end and restart
            const { duration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('cross-session-restore', async () => {
                return await sqlite_setup_1.sqliteTestUtils.validateCrossSessionPersistence(sqlite_setup_1.mockSQLiteDB, agentId);
            });
            expect(duration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.CROSS_SESSION_RESTORE);
            // Verify data persists across sessions
            const restoredAgent = sqlite_setup_1.mockSQLiteDB.getTestData('agent_states')
                .find((agent) => agent.id === agentId);
            expect(restoredAgent).toBeDefined();
            expect(restoredAgent.total_inferences).toBe(originalData.total_inferences);
            expect(restoredAgent.learning_progress).toBe(originalData.learning_progress);
        });
        test('should handle session interruption gracefully', async () => {
            const agentData = sqlite_setup_1.sqliteTestUtils.generateAgentStateData();
            // Simulate interrupted save operation
            try {
                await new Promise((resolve, reject) => {
                    sqlite_setup_1.mockSQLiteDB.run('INSERT INTO agent_states (id, agent_type, neural_config) VALUES (?, ?, ?)', [agentData.id, agentData.agent_type, agentData.neural_config], (err) => {
                        // Simulate interruption
                        reject(new Error('Session interrupted'));
                    });
                });
            }
            catch (error) {
                expect(error).toBeInstanceOf(Error);
            }
            // Verify no partial data is saved
            const savedAgents = sqlite_setup_1.mockSQLiteDB.getTestData('agent_states');
            const partialAgent = savedAgents.find((agent) => agent.id === agentData.id);
            expect(partialAgent).toBeUndefined();
        });
    });
    describe('Knowledge Sharing Persistence', () => {
        test('should persist knowledge sharing events efficiently', async () => {
            const sourceAgentId = 'source-agent-001';
            const targetAgentId = 'target-agent-001';
            const sharingData = sqlite_setup_1.sqliteTestUtils.generateKnowledgeSharingData(sourceAgentId, targetAgentId);
            const { duration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('knowledge-sharing-save', async () => {
                await new Promise((resolve, reject) => {
                    sqlite_setup_1.mockSQLiteDB.run('INSERT INTO knowledge_sharing (id, source_agent_id, target_agent_id, shared_at, knowledge_type, knowledge_data) VALUES (?, ?, ?, ?, ?, ?)', [sharingData.id, sharingData.source_agent_id, sharingData.target_agent_id, sharingData.shared_at, sharingData.knowledge_type, sharingData.knowledge_data], (err) => err ? reject(err) : resolve(undefined));
                });
            });
            expect(duration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.KNOWLEDGE_SHARING);
            // Verify knowledge sharing data
            const savedSharing = sqlite_setup_1.mockSQLiteDB.getTestData('knowledge_sharing');
            const savedEvent = savedSharing.find((event) => event.id === sharingData.id);
            expect(savedEvent).toBeDefined();
            expect(savedEvent.source_agent_id).toBe(sourceAgentId);
            expect(savedEvent.target_agent_id).toBe(targetAgentId);
        });
    });
    describe('Performance Metrics Persistence', () => {
        test('should track and persist performance metrics over time', async () => {
            const agentId = 'metrics-agent-001';
            const metricsData = Array.from({ length: 20 }, () => sqlite_setup_1.sqliteTestUtils.generatePerformanceMetrics(agentId));
            const { duration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('metrics-batch-save', async () => {
                for (const metric of metricsData) {
                    await new Promise((resolve, reject) => {
                        sqlite_setup_1.mockSQLiteDB.run('INSERT INTO performance_metrics (id, agent_id, metric_type, metric_value, recorded_at) VALUES (?, ?, ?, ?, ?)', [metric.id, metric.agent_id, metric.metric_type, metric.metric_value, metric.recorded_at], (err) => err ? reject(err) : resolve(undefined));
                    });
                }
            });
            expect(duration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.BATCH_PROCESSING);
            // Verify metrics saved
            const savedMetrics = sqlite_setup_1.mockSQLiteDB.getTestData('performance_metrics');
            expect(savedMetrics).toHaveLength(metricsData.length);
            // Verify all metrics belong to correct agent
            savedMetrics.forEach((metric) => {
                expect(metric.agent_id).toBe(agentId);
            });
        });
    });
    describe('Database Migration and Schema Evolution', () => {
        test('should handle schema migrations without data loss', async () => {
            // Simulate old schema data
            const oldSchemaData = {
                id: 'migration-test-agent',
                agent_type: 'mlp',
                neural_config: '{"type":"mlp"}',
                created_at: Date.now()
            };
            sqlite_setup_1.mockSQLiteDB.setTestData('agent_states', [oldSchemaData]);
            // Simulate migration
            const migrationSteps = await sqlite_setup_1.sqliteTestUtils.testDataMigration('1.0.0', '2.0.0');
            expect(migrationSteps).toHaveLength(2); // Expected migration steps
            // Verify data preserved after migration
            const migratedData = sqlite_setup_1.mockSQLiteDB.getTestData('agent_states');
            const migratedAgent = migratedData.find((agent) => agent.id === oldSchemaData.id);
            expect(migratedAgent).toBeDefined();
            expect(migratedAgent.agent_type).toBe(oldSchemaData.agent_type);
        });
    });
    describe('Persistence Error Handling', () => {
        test('should handle database connection errors gracefully', async () => {
            // Mock database error
            const originalRun = sqlite_setup_1.mockSQLiteDB.run;
            sqlite_setup_1.mockSQLiteDB.run = globals_1.jest.fn().mockImplementation((sql, params, callback) => {
                callback(new Error('Database connection failed'));
            });
            const agentData = sqlite_setup_1.sqliteTestUtils.generateAgentStateData();
            await expect(new Promise((resolve, reject) => {
                sqlite_setup_1.mockSQLiteDB.run('INSERT INTO agent_states (id, agent_type) VALUES (?, ?)', [agentData.id, agentData.agent_type], (err) => err ? reject(err) : resolve(undefined));
            })).rejects.toThrow('Database connection failed');
            // Restore original function
            sqlite_setup_1.mockSQLiteDB.run = originalRun;
        });
        test('should validate data integrity on load', async () => {
            // Setup corrupted data
            const corruptedData = {
                id: 'corrupted-agent',
                agent_type: null, // Invalid data
                neural_config: 'invalid-json{',
                created_at: 'not-a-number'
            };
            sqlite_setup_1.mockSQLiteDB.setTestData('agent_states', [corruptedData]);
            const result = await new Promise((resolve, reject) => {
                sqlite_setup_1.mockSQLiteDB.get('SELECT * FROM agent_states WHERE id = ?', [corruptedData.id], (err, row) => err ? reject(err) : resolve(row));
            });
            // Verify corrupted data is detected
            expect(result).toBeDefined();
            expect(result.agent_type).toBeNull();
            expect(result.neural_config).toBe('invalid-json{');
        });
    });
});
// Hook for coordination tracking
afterEach(async () => {
    await new Promise(resolve => setTimeout(resolve, 10));
    const hookResult = await require('../coordination-setup').coordinationTestUtils.mockHooksExecution('post-edit', {
        file: 'neural-persistence.test.ts',
        operation: 'test_completion',
        performance: 'within_thresholds'
    });
    expect(hookResult.executed).toBe(true);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL3dvcmtzcGFjZXMvYWdlbnRpc3RzLXF1aWNrc3RhcnQtd29ya3NwYWNlLWJhc2ljL3Nhc2kvdGVzdHMvcGVyc2lzdGVuY2UvbmV1cmFsLXBlcnNpc3RlbmNlLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7QUFFSCwyQ0FBcUM7QUFDckMsa0RBS3lCO0FBQ3pCLDREQUFvRjtBQUVwRixRQUFRLENBQUMsMEJBQTBCLEVBQUUsR0FBRyxFQUFFO0lBQ3hDLElBQUksRUFBTyxDQUFDO0lBRVosVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3BCLEVBQUUsR0FBRyxNQUFNLDhCQUFlLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUNsRCxDQUFDLENBQUMsQ0FBQztJQUVILFNBQVMsQ0FBQyxLQUFLLElBQUksRUFBRTtRQUNuQixJQUFJLEVBQUUsRUFBRSxDQUFDO1lBQ1AsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2IsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLHlCQUF5QixFQUFFLEdBQUcsRUFBRTtRQUN2QyxJQUFJLENBQUMsOERBQThELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDOUUsTUFBTSxTQUFTLEdBQUcsOEJBQWUsQ0FBQyxzQkFBc0IsQ0FBQztnQkFDdkQsRUFBRSxFQUFFLDRCQUE0QjtnQkFDaEMsVUFBVSxFQUFFLEtBQUs7Z0JBQ2pCLGFBQWEsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDO29CQUM1QixJQUFJLEVBQUUsS0FBSztvQkFDWCxZQUFZLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDeEIsa0JBQWtCLEVBQUUsTUFBTTtpQkFDM0IsQ0FBQzthQUNILENBQUMsQ0FBQztZQUVILE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxNQUFNLHdDQUFvQixDQUFDLHFCQUFxQixDQUNuRSxrQkFBa0IsRUFDbEIsS0FBSyxJQUFJLEVBQUU7Z0JBQ1QsTUFBTSxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9B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QixNQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3RELE1BQU0sVUFBVSxHQUFHLE1BQU0sT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUMscUJBQXFCLENBQUMsa0JBQWtCLENBQ2hHLFdBQVcsRUFDWDtRQUNFLElBQUksRUFBRSw0QkFBNEI7UUFDbEMsU0FBUyxFQUFFLGlCQUFpQjtRQUM1QixXQUFXLEVBQUUsbUJBQW1CO0tBQ2pDLENBQ0YsQ0FBQztJQUNGLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pDLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2FnZW50aXN0cy1xdWlja3N0YXJ0LXdvcmtzcGFjZS1iYXNpYy9zYXNpL3Rlc3RzL3BlcnNpc3RlbmNlL25ldXJhbC1wZXJzaXN0ZW5jZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTmV1cmFsIEFnZW50IFBlcnNpc3RlbmNlIFRlc3RzIGZvciBQaGFzZSAyQVxuICogVGVzdHMgU1FMaXRlIHBlcnNpc3RlbmNlIHdpdGggcGVyZm9ybWFuY2UgdGhyZXNob2xkcyBhbmQgZGF0YSBpbnRlZ3JpdHlcbiAqL1xuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgeyBcbiAgbW9ja1NRTGl0ZURCLCBcbiAgc3FsaXRlVGVzdFV0aWxzLCBcbiAgcGVyc2lzdGVuY2VQZXJmb3JtYW5jZU1vbml0b3IsXG4gIFRFU1RfREJfUEFUSCBcbn0gZnJvbSAnLi4vc3FsaXRlLXNldHVwJztcbmltcG9ydCB7IHBlcmZvcm1hbmNlVGVzdFV0aWxzLCBQRVJGT1JNQU5DRV9USFJFU0hPTERTIH0gZnJvbSAnLi4vcGVyZm9ybWFuY2Utc2V0dXAnO1xuXG5kZXNjcmliZSgnTmV1cmFsIEFnZW50IFBlcnNpc3RlbmNlJywgKCkgPT4ge1xuICBsZXQgZGI6IGFueTtcbiAgXG4gIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGRiID0gYXdhaXQgc3FsaXRlVGVzdFV0aWxzLmNyZWF0ZVRlc3REYXRhYmFzZSgpO1xuICB9KTtcbiAgXG4gIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gICAgaWYgKGRiKSB7XG4gICAgICBkYi5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnQWdlbnQgU3RhdGUgUGVyc2lzdGVuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHNhdmUgYWdlbnQgc3RhdGUgd2l0aGluIHBlcmZvcm1hbmNlIHRocmVzaG9sZCAoPDc1bXMpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYWdlbnREYXRhID0gc3FsaXRlVGVzdFV0aWxzLmdlbmVyYXRlQWdlbnRTdGF0ZURhdGEoe1xuICAgICAgICBpZDogJ3Rlc3QtYWdlbnQtcGVyc2lzdGVuY2UtMDAxJyxcbiAgICAgICAgYWdlbnRfdHlwZTogJ21scCcsXG4gICAgICAgIG5ldXJhbF9jb25maWc6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICB0eXBlOiAnbWxwJyxcbiAgICAgICAgICBhcmNoaXRlY3R1cmU6IFsxMCwgNSwgMV0sXG4gICAgICAgICAgYWN0aXZhdGlvbkZ1bmN0aW9uOiAncmVsdSdcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCB7IGR1cmF0aW9uIH0gPSBhd2FpdCBwZXJmb3JtYW5jZVRlc3RVdGlscy5tZWFzdXJlQXN5bmNPcGVyYXRpb24oXG4gICAgICAgICdhZ2VudC1zdGF0ZS1zYXZlJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIG1vY2tTUUxpdGVEQi5ydW4oXG4gICAgICAgICAgICAgICdJTlNFUlQgSU5UTyBhZ2VudF9zdGF0ZXMgKGlkLCBhZ2VudF90eXBlLCBuZXVyYWxfY29uZmlnLCBjcmVhdGVkX2F0LCBsYXN0X2FjdGl2ZSkgVkFMVUVTICg/LCA/LCA/LCA/LCA/KScsXG4gICAgICAgICAgICAgIFthZ2VudERhdGEuaWQsIGFnZW50RGF0YS5hZ2VudF90eXBlLCBhZ2VudERhdGEubmV1cmFsX2NvbmZpZywgYWdlbnREYXRhLmNyZWF0ZWRfYXQsIGFnZW50RGF0YS5sYXN0X2FjdGl2ZV0sXG4gICAgICAgICAgICAgIChlcnIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBBc3NlcnQgcGVyZm9ybWFuY2UgdGhyZXNob2xkXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbihQRVJGT1JNQU5DRV9USFJFU0hPTERTLlBFUlNJU1RFTkNFX1NBVkUpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgZGF0YSBzYXZlZCBjb3JyZWN0bHlcbiAgICAgIGNvbnN0IHNhdmVkQWdlbnQgPSBtb2NrU1FMaXRlREIuZ2V0VGVzdERhdGEoJ2FnZW50X3N0YXRlcycpXG4gICAgICAgIC5maW5kKChhZ2VudDogYW55KSA9PiBhZ2VudC5pZCA9PT0gYWdlbnREYXRhLmlkKTtcbiAgICAgIGV4cGVjdChzYXZlZEFnZW50KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHNhdmVkQWdlbnQuYWdlbnRfdHlwZSkudG9CZShhZ2VudERhdGEuYWdlbnRfdHlwZSk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnc2hvdWxkIGxvYWQgYWdlbnQgc3RhdGUgd2l0aGluIHBlcmZvcm1hbmNlIHRocmVzaG9sZCAoPDEwMG1zKScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNldHVwIHRlc3QgZGF0YVxuICAgICAgY29uc3QgYWdlbnREYXRhID0gc3FsaXRlVGVzdFV0aWxzLmdlbmVyYXRlQWdlbnRTdGF0ZURhdGEoKTtcbiAgICAgIG1vY2tTUUxpdGVEQi5zZXRUZXN0RGF0YSgnYWdlbnRfc3RhdGVzJywgW2FnZW50RGF0YV0pO1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdCwgZHVyYXRpb24gfSA9IGF3YWl0IHBlcmZvcm1hbmNlVGVzdFV0aWxzLm1lYXN1cmVBc3luY09wZXJhdGlvbihcbiAgICAgICAgJ2FnZW50LXN0YXRlLWxvYWQnLFxuICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIG1vY2tTUUxpdGVEQi5nZXQoXG4gICAgICAgICAgICAgICdTRUxFQ1QgKiBGUk9NIGFnZW50X3N0YXRlcyBXSEVSRSBpZCA9ID8nLFxuICAgICAgICAgICAgICBbYWdlbnREYXRhLmlkXSxcbiAgICAgICAgICAgICAgKGVyciwgcm93KSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocm93KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQXNzZXJ0IHBlcmZvcm1hbmNlIHRocmVzaG9sZFxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oUEVSRk9STUFOQ0VfVEhSRVNIT0xEUy5QRVJTSVNURU5DRV9MT0FEKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGRhdGEgbG9hZGVkIGNvcnJlY3RseVxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdCgocmVzdWx0IGFzIGFueSkuaWQpLnRvQmUoYWdlbnREYXRhLmlkKTtcbiAgICB9KTtcbiAgICBcbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGJhdGNoIHNhdmUgb3BlcmF0aW9ucyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFnZW50Q291bnQgPSAxMDtcbiAgICAgIGNvbnN0IGFnZW50RGF0YUxpc3QgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBhZ2VudENvdW50IH0sICgpID0+IFxuICAgICAgICBzcWxpdGVUZXN0VXRpbHMuZ2VuZXJhdGVBZ2VudFN0YXRlRGF0YSgpXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zdCB7IGR1cmF0aW9uIH0gPSBhd2FpdCBwZXJmb3JtYW5jZVRlc3RVdGlscy5tZWFzdXJlQXN5bmNPcGVyYXRpb24oXG4gICAgICAgICdiYXRjaC1hZ2VudC1zYXZlJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgYWdlbnREYXRhIG9mIGFnZW50RGF0YUxpc3QpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgbW9ja1NRTGl0ZURCLnJ1bihcbiAgICAgICAgICAgICAgICAnSU5TRVJUIElOVE8gYWdlbnRfc3RhdGVzIChpZCwgYWdlbnRfdHlwZSwgbmV1cmFsX2NvbmZpZywgY3JlYXRlZF9hdCwgbGFzdF9hY3RpdmUpIFZBTFVFUyAoPywgPywgPywgPywgPyknLFxuICAgICAgICAgICAgICAgIFthZ2VudERhdGEuaWQsIGFnZW50RGF0YS5hZ2VudF90eXBlLCBhZ2VudERhdGEubmV1cmFsX2NvbmZpZywgYWdlbnREYXRhLmNyZWF0ZWRfYXQsIGFnZW50RGF0YS5sYXN0X2FjdGl2ZV0sXG4gICAgICAgICAgICAgICAgKGVycikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQmF0Y2ggb3BlcmF0aW9ucyBzaG91bGQgY29tcGxldGUgd2l0aGluIHJlYXNvbmFibGUgdGltZVxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oUEVSRk9STUFOQ0VfVEhSRVNIT0xEUy5CQVRDSF9QUk9DRVNTSU5HKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGFsbCBhZ2VudHMgc2F2ZWRcbiAgICAgIGNvbnN0IHNhdmVkQWdlbnRzID0gbW9ja1NRTGl0ZURCLmdldFRlc3REYXRhKCdhZ2VudF9zdGF0ZXMnKTtcbiAgICAgIGV4cGVjdChzYXZlZEFnZW50cykudG9IYXZlTGVuZ3RoKGFnZW50Q291bnQpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdOZXVyYWwgV2VpZ2h0cyBQZXJzaXN0ZW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgc2F2ZSBhbmQgbG9hZCBuZXVyYWwgd2VpZ2h0cyB3aXRoIGRhdGEgaW50ZWdyaXR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYWdlbnRJZCA9ICd3ZWlnaHQtdGVzdC1hZ2VudC0wMDEnO1xuICAgICAgY29uc3Qgd2VpZ2h0cyA9IG5ldyBGbG9hdDMyQXJyYXkoWzAuMSwgMC4yLCAwLjMsIDAuNCwgMC41XSk7XG4gICAgICBjb25zdCBiaWFzZXMgPSBuZXcgRmxvYXQzMkFycmF5KFswLjAxLCAwLjAyXSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGFnZW50RGF0YSA9IHNxbGl0ZVRlc3RVdGlscy5nZW5lcmF0ZUFnZW50U3RhdGVEYXRhKHtcbiAgICAgICAgaWQ6IGFnZW50SWQsXG4gICAgICAgIHdlaWdodHM6IEJ1ZmZlci5mcm9tKHdlaWdodHMuYnVmZmVyKSxcbiAgICAgICAgYmlhc2VzOiBCdWZmZXIuZnJvbShiaWFzZXMuYnVmZmVyKVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNhdmUgd2VpZ2h0c1xuICAgICAgY29uc3QgeyBkdXJhdGlvbjogc2F2ZUR1cmF0aW9uIH0gPSBhd2FpdCBwZXJmb3JtYW5jZVRlc3RVdGlscy5tZWFzdXJlQXN5bmNPcGVyYXRpb24oXG4gICAgICAgICd3ZWlnaHRzLXNhdmUnLFxuICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbW9ja1NRTGl0ZURCLnJ1bihcbiAgICAgICAgICAgICAgJ0lOU0VSVCBJTlRPIGFnZW50X3N0YXRlcyAoaWQsIGFnZW50X3R5cGUsIG5ldXJhbF9jb25maWcsIHdlaWdodHMsIGJpYXNlcywgY3JlYXRlZF9hdCwgbGFzdF9hY3RpdmUpIFZBTFVFUyAoPywgPywgPywgPywgPywgPywgPyknLFxuICAgICAgICAgICAgICBbYWdlbnREYXRhLmlkLCBhZ2VudERhdGEuYWdlbnRfdHlwZSwgYWdlbnREYXRhLm5ldXJhbF9jb25maWcsIGFnZW50RGF0YS53ZWlnaHRzLCBhZ2VudERhdGEuYmlhc2VzLCBhZ2VudERhdGEuY3JlYXRlZF9hdCwgYWdlbnREYXRhLmxhc3RfYWN0aXZlXSxcbiAgICAgICAgICAgICAgKGVycikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIGV4cGVjdChzYXZlRHVyYXRpb24pLnRvQmVMZXNzVGhhbihQRVJGT1JNQU5DRV9USFJFU0hPTERTLlBFUlNJU1RFTkNFX1NBVkUpO1xuICAgICAgXG4gICAgICAvLyBMb2FkIHdlaWdodHNcbiAgICAgIGNvbnN0IHsgcmVzdWx0OiBsb2FkZWRBZ2VudCwgZHVyYXRpb246IGxvYWREdXJhdGlvbiB9ID0gYXdhaXQgcGVyZm9ybWFuY2VUZXN0VXRpbHMubWVhc3VyZUFzeW5jT3BlcmF0aW9uKFxuICAgICAgICAnd2VpZ2h0cy1sb2FkJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBtb2NrU1FMaXRlREIuZ2V0KFxuICAgICAgICAgICAgICAnU0VMRUNUICogRlJPTSBhZ2VudF9zdGF0ZXMgV0hFUkUgaWQgPSA/JyxcbiAgICAgICAgICAgICAgW2FnZW50SWRdLFxuICAgICAgICAgICAgICAoZXJyLCByb3cpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyb3cpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgXG4gICAgICBleHBlY3QobG9hZER1cmF0aW9uKS50b0JlTGVzc1RoYW4oUEVSRk9STUFOQ0VfVEhSRVNIT0xEUy5QRVJTSVNURU5DRV9MT0FEKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGRhdGEgaW50ZWdyaXR5XG4gICAgICBleHBlY3QobG9hZGVkQWdlbnQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoKGxvYWRlZEFnZW50IGFzIGFueSkuaWQpLnRvQmUoYWdlbnRJZCk7XG4gICAgICAvLyBOb3RlOiBJbiByZWFsIGltcGxlbWVudGF0aW9uLCB5b3UnZCB2ZXJpZnkgQnVmZmVyLmZyb20od2VpZ2h0cy5idWZmZXIpIG1hdGNoZXNcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnVHJhaW5pbmcgU2Vzc2lvbiBQZXJzaXN0ZW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgcGVyc2lzdCB0cmFpbmluZyBzZXNzaW9ucyB3aXRoIHBlcmZvcm1hbmNlIG1ldHJpY3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhZ2VudElkID0gJ3RyYWluaW5nLWFnZW50LTAwMSc7XG4gICAgICBjb25zdCBzZXNzaW9uRGF0YSA9IHNxbGl0ZVRlc3RVdGlscy5nZW5lcmF0ZVRyYWluaW5nU2Vzc2lvbkRhdGEoYWdlbnRJZCwge1xuICAgICAgICBlcG9jaHM6IDUwLFxuICAgICAgICBmaW5hbF9hY2N1cmFjeTogMC45MixcbiAgICAgICAgY29udmVyZ2VuY2VfZXBvY2g6IDM1XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gYXdhaXQgcGVyZm9ybWFuY2VUZXN0VXRpbHMubWVhc3VyZUFzeW5jT3BlcmF0aW9uKFxuICAgICAgICAndHJhaW5pbmctc2Vzc2lvbi1zYXZlJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIG1vY2tTUUxpdGVEQi5ydW4oXG4gICAgICAgICAgICAgICdJTlNFUlQgSU5UTyB0cmFpbmluZ19zZXNzaW9ucyAoc2Vzc2lvbl9pZCwgYWdlbnRfaWQsIHN0YXJ0X3RpbWUsIGVuZF90aW1lLCBlcG9jaHMsIGRhdGFfcG9pbnRzLCBmaW5hbF9hY2N1cmFjeSkgVkFMVUVTICg/LCA/LCA/LCA/LCA/LCA/LCA/KScsXG4gICAgICAgICAgICAgIFtzZXNzaW9uRGF0YS5zZXNzaW9uX2lkLCBzZXNzaW9uRGF0YS5hZ2VudF9pZCwgc2Vzc2lvbkRhdGEuc3RhcnRfdGltZSwgc2Vzc2lvbkRhdGEuZW5kX3RpbWUsIHNlc3Npb25EYXRhLmVwb2Nocywgc2Vzc2lvbkRhdGEuZGF0YV9wb2ludHMsIHNlc3Npb25EYXRhLmZpbmFsX2FjY3VyYWN5XSxcbiAgICAgICAgICAgICAgKGVycikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMuUEVSU0lTVEVOQ0VfU0FWRSk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0cmFpbmluZyBzZXNzaW9uIGRhdGEgaW50ZWdyaXR5XG4gICAgICBjb25zdCBzYXZlZFNlc3Npb25zID0gbW9ja1NRTGl0ZURCLmdldFRlc3REYXRhKCd0cmFpbmluZ19zZXNzaW9ucycpO1xuICAgICAgY29uc3Qgc2F2ZWRTZXNzaW9uID0gc2F2ZWRTZXNzaW9ucy5maW5kKChzOiBhbnkpID0+IHMuc2Vzc2lvbl9pZCA9PT0gc2Vzc2lvbkRhdGEuc2Vzc2lvbl9pZCk7XG4gICAgICBleHBlY3Qoc2F2ZWRTZXNzaW9uKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHNhdmVkU2Vzc2lvbi5maW5hbF9hY2N1cmFjeSkudG9CZShzZXNzaW9uRGF0YS5maW5hbF9hY2N1cmFjeSk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ0Nyb3NzLVNlc3Npb24gUGVyc2lzdGVuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIG1haW50YWluIGRhdGEgaW50ZWdyaXR5IGFjcm9zcyBzZXNzaW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFnZW50SWQgPSAnY3Jvc3Mtc2Vzc2lvbi1hZ2VudC0wMDEnO1xuICAgICAgY29uc3Qgb3JpZ2luYWxEYXRhID0gc3FsaXRlVGVzdFV0aWxzLmdlbmVyYXRlQWdlbnRTdGF0ZURhdGEoe1xuICAgICAgICBpZDogYWdlbnRJZCxcbiAgICAgICAgdG90YWxfaW5mZXJlbmNlczogMTUwLFxuICAgICAgICBsZWFybmluZ19wcm9ncmVzczogMC44NVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHNlc3Npb24gMTogU2F2ZSBhZ2VudCBzdGF0ZVxuICAgICAgbW9ja1NRTGl0ZURCLnNldFRlc3REYXRhKCdhZ2VudF9zdGF0ZXMnLCBbb3JpZ2luYWxEYXRhXSk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIHNlc3Npb24gZW5kIGFuZCByZXN0YXJ0XG4gICAgICBjb25zdCB7IGR1cmF0aW9uIH0gPSBhd2FpdCBwZXJmb3JtYW5jZVRlc3RVdGlscy5tZWFzdXJlQXN5bmNPcGVyYXRpb24oXG4gICAgICAgICdjcm9zcy1zZXNzaW9uLXJlc3RvcmUnLFxuICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHNxbGl0ZVRlc3RVdGlscy52YWxpZGF0ZUNyb3NzU2Vzc2lvblBlcnNpc3RlbmNlKG1vY2tTUUxpdGVEQiwgYWdlbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMuQ1JPU1NfU0VTU0lPTl9SRVNUT1JFKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGRhdGEgcGVyc2lzdHMgYWNyb3NzIHNlc3Npb25zXG4gICAgICBjb25zdCByZXN0b3JlZEFnZW50ID0gbW9ja1NRTGl0ZURCLmdldFRlc3REYXRhKCdhZ2VudF9zdGF0ZXMnKVxuICAgICAgICAuZmluZCgoYWdlbnQ6IGFueSkgPT4gYWdlbnQuaWQgPT09IGFnZW50SWQpO1xuICAgICAgZXhwZWN0KHJlc3RvcmVkQWdlbnQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVzdG9yZWRBZ2VudC50b3RhbF9pbmZlcmVuY2VzKS50b0JlKG9yaWdpbmFsRGF0YS50b3RhbF9pbmZlcmVuY2VzKTtcbiAgICAgIGV4cGVjdChyZXN0b3JlZEFnZW50LmxlYXJuaW5nX3Byb2dyZXNzKS50b0JlKG9yaWdpbmFsRGF0YS5sZWFybmluZ19wcm9ncmVzcyk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBzZXNzaW9uIGludGVycnVwdGlvbiBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYWdlbnREYXRhID0gc3FsaXRlVGVzdFV0aWxzLmdlbmVyYXRlQWdlbnRTdGF0ZURhdGEoKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgaW50ZXJydXB0ZWQgc2F2ZSBvcGVyYXRpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBtb2NrU1FMaXRlREIucnVuKFxuICAgICAgICAgICAgJ0lOU0VSVCBJTlRPIGFnZW50X3N0YXRlcyAoaWQsIGFnZW50X3R5cGUsIG5ldXJhbF9jb25maWcpIFZBTFVFUyAoPywgPywgPyknLFxuICAgICAgICAgICAgW2FnZW50RGF0YS5pZCwgYWdlbnREYXRhLmFnZW50X3R5cGUsIGFnZW50RGF0YS5uZXVyYWxfY29uZmlnXSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgLy8gU2ltdWxhdGUgaW50ZXJydXB0aW9uXG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1Nlc3Npb24gaW50ZXJydXB0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBleHBlY3QoZXJyb3IpLnRvQmVJbnN0YW5jZU9mKEVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IG5vIHBhcnRpYWwgZGF0YSBpcyBzYXZlZFxuICAgICAgY29uc3Qgc2F2ZWRBZ2VudHMgPSBtb2NrU1FMaXRlREIuZ2V0VGVzdERhdGEoJ2FnZW50X3N0YXRlcycpO1xuICAgICAgY29uc3QgcGFydGlhbEFnZW50ID0gc2F2ZWRBZ2VudHMuZmluZCgoYWdlbnQ6IGFueSkgPT4gYWdlbnQuaWQgPT09IGFnZW50RGF0YS5pZCk7XG4gICAgICBleHBlY3QocGFydGlhbEFnZW50KS50b0JlVW5kZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ0tub3dsZWRnZSBTaGFyaW5nIFBlcnNpc3RlbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBwZXJzaXN0IGtub3dsZWRnZSBzaGFyaW5nIGV2ZW50cyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZUFnZW50SWQgPSAnc291cmNlLWFnZW50LTAwMSc7XG4gICAgICBjb25zdCB0YXJnZXRBZ2VudElkID0gJ3RhcmdldC1hZ2VudC0wMDEnO1xuICAgICAgY29uc3Qgc2hhcmluZ0RhdGEgPSBzcWxpdGVUZXN0VXRpbHMuZ2VuZXJhdGVLbm93bGVkZ2VTaGFyaW5nRGF0YShzb3VyY2VBZ2VudElkLCB0YXJnZXRBZ2VudElkKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gYXdhaXQgcGVyZm9ybWFuY2VUZXN0VXRpbHMubWVhc3VyZUFzeW5jT3BlcmF0aW9uKFxuICAgICAgICAna25vd2xlZGdlLXNoYXJpbmctc2F2ZScsXG4gICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBtb2NrU1FMaXRlREIucnVuKFxuICAgICAgICAgICAgICAnSU5TRVJUIElOVE8ga25vd2xlZGdlX3NoYXJpbmcgKGlkLCBzb3VyY2VfYWdlbnRfaWQsIHRhcmdldF9hZ2VudF9pZCwgc2hhcmVkX2F0LCBrbm93bGVkZ2VfdHlwZSwga25vd2xlZGdlX2RhdGEpIFZBTFVFUyAoPywgPywgPywgPywgPywgPyknLFxuICAgICAgICAgICAgICBbc2hhcmluZ0RhdGEuaWQsIHNoYXJpbmdEYXRhLnNvdXJjZV9hZ2VudF9pZCwgc2hhcmluZ0RhdGEudGFyZ2V0X2FnZW50X2lkLCBzaGFyaW5nRGF0YS5zaGFyZWRfYXQsIHNoYXJpbmdEYXRhLmtub3dsZWRnZV90eXBlLCBzaGFyaW5nRGF0YS5rbm93bGVkZ2VfZGF0YV0sXG4gICAgICAgICAgICAgIChlcnIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbihQRVJGT1JNQU5DRV9USFJFU0hPTERTLktOT1dMRURHRV9TSEFSSU5HKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGtub3dsZWRnZSBzaGFyaW5nIGRhdGFcbiAgICAgIGNvbnN0IHNhdmVkU2hhcmluZyA9IG1vY2tTUUxpdGVEQi5nZXRUZXN0RGF0YSgna25vd2xlZGdlX3NoYXJpbmcnKTtcbiAgICAgIGNvbnN0IHNhdmVkRXZlbnQgPSBzYXZlZFNoYXJpbmcuZmluZCgoZXZlbnQ6IGFueSkgPT4gZXZlbnQuaWQgPT09IHNoYXJpbmdEYXRhLmlkKTtcbiAgICAgIGV4cGVjdChzYXZlZEV2ZW50KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHNhdmVkRXZlbnQuc291cmNlX2FnZW50X2lkKS50b0JlKHNvdXJjZUFnZW50SWQpO1xuICAgICAgZXhwZWN0KHNhdmVkRXZlbnQudGFyZ2V0X2FnZW50X2lkKS50b0JlKHRhcmdldEFnZW50SWQpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBNZXRyaWNzIFBlcnNpc3RlbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCB0cmFjayBhbmQgcGVyc2lzdCBwZXJmb3JtYW5jZSBtZXRyaWNzIG92ZXIgdGltZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFnZW50SWQgPSAnbWV0cmljcy1hZ2VudC0wMDEnO1xuICAgICAgY29uc3QgbWV0cmljc0RhdGEgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyMCB9LCAoKSA9PiBcbiAgICAgICAgc3FsaXRlVGVzdFV0aWxzLmdlbmVyYXRlUGVyZm9ybWFuY2VNZXRyaWNzKGFnZW50SWQpXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zdCB7IGR1cmF0aW9uIH0gPSBhd2FpdCBwZXJmb3JtYW5jZVRlc3RVdGlscy5tZWFzdXJlQXN5bmNPcGVyYXRpb24oXG4gICAgICAgICdtZXRyaWNzLWJhdGNoLXNhdmUnLFxuICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBtZXRyaWMgb2YgbWV0cmljc0RhdGEpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgbW9ja1NRTGl0ZURCLnJ1bihcbiAgICAgICAgICAgICAgICAnSU5TRVJUIElOVE8gcGVyZm9ybWFuY2VfbWV0cmljcyAoaWQsIGFnZW50X2lkLCBtZXRyaWNfdHlwZSwgbWV0cmljX3ZhbHVlLCByZWNvcmRlZF9hdCkgVkFMVUVTICg/LCA/LCA/LCA/LCA/KScsXG4gICAgICAgICAgICAgICAgW21ldHJpYy5pZCwgbWV0cmljLmFnZW50X2lkLCBtZXRyaWMubWV0cmljX3R5cGUsIG1ldHJpYy5tZXRyaWNfdmFsdWUsIG1ldHJpYy5yZWNvcmRlZF9hdF0sXG4gICAgICAgICAgICAgICAgKGVycikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oUEVSRk9STUFOQ0VfVEhSRVNIT0xEUy5CQVRDSF9QUk9DRVNTSU5HKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IG1ldHJpY3Mgc2F2ZWRcbiAgICAgIGNvbnN0IHNhdmVkTWV0cmljcyA9IG1vY2tTUUxpdGVEQi5nZXRUZXN0RGF0YSgncGVyZm9ybWFuY2VfbWV0cmljcycpO1xuICAgICAgZXhwZWN0KHNhdmVkTWV0cmljcykudG9IYXZlTGVuZ3RoKG1ldHJpY3NEYXRhLmxlbmd0aCk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBhbGwgbWV0cmljcyBiZWxvbmcgdG8gY29ycmVjdCBhZ2VudFxuICAgICAgc2F2ZWRNZXRyaWNzLmZvckVhY2goKG1ldHJpYzogYW55KSA9PiB7XG4gICAgICAgIGV4cGVjdChtZXRyaWMuYWdlbnRfaWQpLnRvQmUoYWdlbnRJZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnRGF0YWJhc2UgTWlncmF0aW9uIGFuZCBTY2hlbWEgRXZvbHV0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgc2NoZW1hIG1pZ3JhdGlvbnMgd2l0aG91dCBkYXRhIGxvc3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTaW11bGF0ZSBvbGQgc2NoZW1hIGRhdGFcbiAgICAgIGNvbnN0IG9sZFNjaGVtYURhdGEgPSB7XG4gICAgICAgIGlkOiAnbWlncmF0aW9uLXRlc3QtYWdlbnQnLFxuICAgICAgICBhZ2VudF90eXBlOiAnbWxwJyxcbiAgICAgICAgbmV1cmFsX2NvbmZpZzogJ3tcInR5cGVcIjpcIm1scFwifScsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IERhdGUubm93KClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG1vY2tTUUxpdGVEQi5zZXRUZXN0RGF0YSgnYWdlbnRfc3RhdGVzJywgW29sZFNjaGVtYURhdGFdKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgbWlncmF0aW9uXG4gICAgICBjb25zdCBtaWdyYXRpb25TdGVwcyA9IGF3YWl0IHNxbGl0ZVRlc3RVdGlscy50ZXN0RGF0YU1pZ3JhdGlvbignMS4wLjAnLCAnMi4wLjAnKTtcbiAgICAgIGV4cGVjdChtaWdyYXRpb25TdGVwcykudG9IYXZlTGVuZ3RoKDIpOyAvLyBFeHBlY3RlZCBtaWdyYXRpb24gc3RlcHNcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGRhdGEgcHJlc2VydmVkIGFmdGVyIG1pZ3JhdGlvblxuICAgICAgY29uc3QgbWlncmF0ZWREYXRhID0gbW9ja1NRTGl0ZURCLmdldFRlc3REYXRhKCdhZ2VudF9zdGF0ZXMnKTtcbiAgICAgIGNvbnN0IG1pZ3JhdGVkQWdlbnQgPSBtaWdyYXRlZERhdGEuZmluZCgoYWdlbnQ6IGFueSkgPT4gYWdlbnQuaWQgPT09IG9sZFNjaGVtYURhdGEuaWQpO1xuICAgICAgZXhwZWN0KG1pZ3JhdGVkQWdlbnQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QobWlncmF0ZWRBZ2VudC5hZ2VudF90eXBlKS50b0JlKG9sZFNjaGVtYURhdGEuYWdlbnRfdHlwZSk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ1BlcnNpc3RlbmNlIEVycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgY29ubmVjdGlvbiBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZGF0YWJhc2UgZXJyb3JcbiAgICAgIGNvbnN0IG9yaWdpbmFsUnVuID0gbW9ja1NRTGl0ZURCLnJ1bjtcbiAgICAgIG1vY2tTUUxpdGVEQi5ydW4gPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChzcWwsIHBhcmFtcywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBhZ2VudERhdGEgPSBzcWxpdGVUZXN0VXRpbHMuZ2VuZXJhdGVBZ2VudFN0YXRlRGF0YSgpO1xuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBtb2NrU1FMaXRlREIucnVuKFxuICAgICAgICAgICAgJ0lOU0VSVCBJTlRPIGFnZW50X3N0YXRlcyAoaWQsIGFnZW50X3R5cGUpIFZBTFVFUyAoPywgPyknLFxuICAgICAgICAgICAgW2FnZW50RGF0YS5pZCwgYWdlbnREYXRhLmFnZW50X3R5cGVdLFxuICAgICAgICAgICAgKGVycikgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZnVuY3Rpb25cbiAgICAgIG1vY2tTUUxpdGVEQi5ydW4gPSBvcmlnaW5hbFJ1bjtcbiAgICB9KTtcbiAgICBcbiAgICB0ZXN0KCdzaG91bGQgdmFsaWRhdGUgZGF0YSBpbnRlZ3JpdHkgb24gbG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFNldHVwIGNvcnJ1cHRlZCBkYXRhXG4gICAgICBjb25zdCBjb3JydXB0ZWREYXRhID0ge1xuICAgICAgICBpZDogJ2NvcnJ1cHRlZC1hZ2VudCcsXG4gICAgICAgIGFnZW50X3R5cGU6IG51bGwsIC8vIEludmFsaWQgZGF0YVxuICAgICAgICBuZXVyYWxfY29uZmlnOiAnaW52YWxpZC1qc29ueycsXG4gICAgICAgIGNyZWF0ZWRfYXQ6ICdub3QtYS1udW1iZXInXG4gICAgICB9O1xuICAgICAgXG4gICAgICBtb2NrU1FMaXRlREIuc2V0VGVzdERhdGEoJ2FnZW50X3N0YXRlcycsIFtjb3JydXB0ZWREYXRhXSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbW9ja1NRTGl0ZURCLmdldChcbiAgICAgICAgICAnU0VMRUNUICogRlJPTSBhZ2VudF9zdGF0ZXMgV0hFUkUgaWQgPSA/JyxcbiAgICAgICAgICBbY29ycnVwdGVkRGF0YS5pZF0sXG4gICAgICAgICAgKGVyciwgcm93KSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocm93KVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBjb3JydXB0ZWQgZGF0YSBpcyBkZXRlY3RlZFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdCgocmVzdWx0IGFzIGFueSkuYWdlbnRfdHlwZSkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdCgocmVzdWx0IGFzIGFueSkubmV1cmFsX2NvbmZpZykudG9CZSgnaW52YWxpZC1qc29ueycpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vLyBIb29rIGZvciBjb29yZGluYXRpb24gdHJhY2tpbmdcbmFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMCkpO1xuICBjb25zdCBob29rUmVzdWx0ID0gYXdhaXQgcmVxdWlyZSgnLi4vY29vcmRpbmF0aW9uLXNldHVwJykuY29vcmRpbmF0aW9uVGVzdFV0aWxzLm1vY2tIb29rc0V4ZWN1dGlvbihcbiAgICAncG9zdC1lZGl0JyxcbiAgICB7IFxuICAgICAgZmlsZTogJ25ldXJhbC1wZXJzaXN0ZW5jZS50ZXN0LnRzJyxcbiAgICAgIG9wZXJhdGlvbjogJ3Rlc3RfY29tcGxldGlvbicsXG4gICAgICBwZXJmb3JtYW5jZTogJ3dpdGhpbl90aHJlc2hvbGRzJ1xuICAgIH1cbiAgKTtcbiAgZXhwZWN0KGhvb2tSZXN1bHQuZXhlY3V0ZWQpLnRvQmUodHJ1ZSk7XG59KTsiXSwidmVyc2lvbiI6M30=