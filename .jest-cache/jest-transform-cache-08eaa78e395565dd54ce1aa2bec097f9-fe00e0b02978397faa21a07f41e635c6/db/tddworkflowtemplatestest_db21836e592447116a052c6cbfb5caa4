c3f5c974b7033ef74ef6d95e217990d9
"use strict";
/**
 * TDD Workflow Templates for Phase 2A
 * Test-Driven Development templates and patterns for neural agent development
 */
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const performance_setup_1 = require("../performance-setup");
const coordination_setup_1 = require("../coordination-setup");
describe('TDD Workflow Templates', () => {
    describe('Neural Agent TDD Template', () => {
        /**
         * TDD Template: Neural Agent Development
         * RED -> GREEN -> REFACTOR cycle for neural agents
         */
        test('RED: Neural agent spawn should fail without implementation', async () => {
            // Step 1: Write failing test first
            const mockNeuralAgentManager = {
                spawnAgent: globals_1.jest.fn().mockRejectedValue(new Error('Not implemented'))
            };
            await expect(mockNeuralAgentManager.spawnAgent({
                type: 'mlp',
                architecture: [10, 5, 1]
            })).rejects.toThrow('Not implemented');
            console.log('ðŸ”´ RED: Test fails as expected - Neural agent spawn not implemented');
        });
        test('GREEN: Neural agent spawn should succeed with minimal implementation', async () => {
            // Step 2: Implement minimal functionality to pass test
            const mockNeuralAgentManager = {
                spawnAgent: globals_1.jest.fn().mockImplementation(async (config) => {
                    // Minimal implementation
                    return {
                        agentId: 'temp-agent-' + Date.now(),
                        config,
                        status: 'active',
                        spawnTime: Date.now()
                    };
                })
            };
            const result = await mockNeuralAgentManager.spawnAgent({
                type: 'mlp',
                architecture: [10, 5, 1]
            });
            expect(result.agentId).toBeDefined();
            expect(result.status).toBe('active');
            console.log('ðŸŸ¢ GREEN: Test passes with minimal implementation');
        });
        test('REFACTOR: Neural agent spawn should be optimized for performance', async () => {
            // Step 3: Refactor for performance and maintainability
            const optimizedNeuralAgentManager = {
                spawnAgent: globals_1.jest.fn().mockImplementation(async (config) => {
                    const startTime = performance.now();
                    // Optimized implementation with validation
                    if (!config.type || !config.architecture) {
                        throw new Error('Invalid configuration');
                    }
                    const agent = {
                        agentId: `${config.type}-agent-${Date.now()}`,
                        config,
                        status: 'active',
                        spawnTime: Date.now(),
                        memoryUsage: config.architecture.reduce((sum, layer) => sum + layer, 0) * 1000,
                        performance: {
                            spawnDuration: performance.now() - startTime
                        }
                    };
                    return agent;
                })
            };
            const { result, duration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('optimized-agent-spawn', async () => {
                return await optimizedNeuralAgentManager.spawnAgent({
                    type: 'mlp',
                    architecture: [10, 5, 1]
                });
            });
            // Verify performance meets threshold
            expect(duration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.AGENT_SPAWN_TIME);
            expect(result.agentId).toContain('mlp-agent-');
            expect(result.memoryUsage).toBeDefined();
            console.log('ðŸ”„ REFACTOR: Implementation optimized for performance and maintainability');
        });
    });
    describe('Persistence TDD Template', () => {
        /**
         * TDD Template: Database Persistence
         * Testing persistence operations with performance constraints
         */
        test('RED: Agent state persistence should fail without database implementation', async () => {
            const mockPersistenceService = {
                saveAgentState: globals_1.jest.fn().mockRejectedValue(new Error('Database not configured'))
            };
            const agentState = {
                id: 'test-agent-001',
                type: 'mlp',
                weights: new Float32Array([0.1, 0.2, 0.3])
            };
            await expect(mockPersistenceService.saveAgentState(agentState)).rejects.toThrow('Database not configured');
            console.log('ðŸ”´ RED: Persistence fails without database implementation');
        });
        test('GREEN: Agent state persistence should succeed with basic implementation', async () => {
            const mockDatabase = new Map();
            const mockPersistenceService = {
                saveAgentState: globals_1.jest.fn().mockImplementation(async (agentState) => {
                    mockDatabase.set(agentState.id, agentState);
                    return { saved: true, timestamp: Date.now() };
                }),
                loadAgentState: globals_1.jest.fn().mockImplementation(async (agentId) => {
                    return mockDatabase.get(agentId) || null;
                })
            };
            const agentState = {
                id: 'test-agent-001',
                type: 'mlp',
                weights: new Float32Array([0.1, 0.2, 0.3])
            };
            const saveResult = await mockPersistenceService.saveAgentState(agentState);
            expect(saveResult.saved).toBe(true);
            const loadedState = await mockPersistenceService.loadAgentState(agentState.id);
            expect(loadedState).toEqual(agentState);
            console.log('ðŸŸ¢ GREEN: Basic persistence implementation works');
        });
        test('REFACTOR: Agent state persistence should be optimized with SQLite and validation', async () => {
            const mockSQLiteDatabase = {
                save: globals_1.jest.fn().mockImplementation(async (agentState) => {
                    // Simulate optimized SQLite operations
                    const startTime = performance.now();
                    // Validation
                    if (!agentState.id || !agentState.type) {
                        throw new Error('Invalid agent state');
                    }
                    // Simulate SQLite save
                    await new Promise(resolve => setTimeout(resolve, 30)); // <75ms
                    return {
                        saved: true,
                        agentId: agentState.id,
                        timestamp: Date.now(),
                        duration: performance.now() - startTime
                    };
                }),
                load: globals_1.jest.fn().mockImplementation(async (agentId) => {
                    // Simulate optimized SQLite load
                    await new Promise(resolve => setTimeout(resolve, 50)); // <100ms
                    return {
                        id: agentId,
                        type: 'mlp',
                        weights: new Float32Array([0.1, 0.2, 0.3]),
                        loadTime: Date.now()
                    };
                })
            };
            const agentState = {
                id: 'optimized-agent-001',
                type: 'mlp',
                weights: new Float32Array([0.1, 0.2, 0.3, 0.4, 0.5])
            };
            const { result: saveResult, duration: saveDuration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('optimized-persistence-save', async () => {
                return await mockSQLiteDatabase.save(agentState);
            });
            const { result: loadResult, duration: loadDuration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('optimized-persistence-load', async () => {
                return await mockSQLiteDatabase.load(agentState.id);
            });
            // Verify performance thresholds
            expect(saveDuration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.PERSISTENCE_SAVE);
            expect(loadDuration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.PERSISTENCE_LOAD);
            expect(saveResult.saved).toBe(true);
            expect(loadResult.id).toBe(agentState.id);
            console.log('ðŸ”„ REFACTOR: Persistence optimized with SQLite and validation');
        });
    });
    describe('Coordination TDD Template', () => {
        /**
         * TDD Template: Agent Coordination
         * Testing multi-agent coordination with performance requirements
         */
        test('RED: Agent coordination should fail without implementation', async () => {
            const mockCoordinationService = {
                coordinateAgents: globals_1.jest.fn().mockRejectedValue(new Error('Coordination not implemented'))
            };
            await expect(mockCoordinationService.coordinateAgents(['agent-1', 'agent-2'], 'collaborative-task')).rejects.toThrow('Coordination not implemented');
            console.log('ðŸ”´ RED: Coordination fails without implementation');
        });
        test('GREEN: Agent coordination should work with basic message passing', async () => {
            const mockCoordinationService = {
                coordinateAgents: globals_1.jest.fn().mockImplementation(async (agentIds, task) => {
                    // Basic coordination: just assign task to all agents
                    return {
                        coordinationId: 'coord-' + Date.now(),
                        assignedAgents: agentIds,
                        task,
                        status: 'coordinated'
                    };
                })
            };
            const result = await mockCoordinationService.coordinateAgents(['agent-1', 'agent-2', 'agent-3'], 'analyze-performance-data');
            expect(result.assignedAgents).toHaveLength(3);
            expect(result.status).toBe('coordinated');
            console.log('ðŸŸ¢ GREEN: Basic coordination works');
        });
        test('REFACTOR: Agent coordination should be optimized with smart load balancing', async () => {
            const mockOptimizedCoordinationService = {
                coordinateAgents: globals_1.jest.fn().mockImplementation(async (agentIds, task) => {
                    const startTime = performance.now();
                    // Optimized coordination with load balancing
                    const agentCapabilities = agentIds.map(id => ({
                        id,
                        currentLoad: Math.random() * 0.8, // 0-80% load
                        capabilities: ['analysis', 'optimization'],
                        performance: 0.85 + Math.random() * 0.15 // 85-100% efficiency
                    }));
                    // Smart assignment based on load and capabilities
                    const assignments = agentCapabilities
                        .sort((a, b) => a.currentLoad - b.currentLoad) // Assign to least loaded first
                        .map(agent => ({
                        agentId: agent.id,
                        assignedTask: task,
                        priority: agent.currentLoad < 0.5 ? 'high' : 'medium'
                    }));
                    const coordinationOverhead = performance.now() - startTime;
                    return {
                        coordinationId: 'optimized-coord-' + Date.now(),
                        assignments,
                        strategy: 'load-balanced',
                        coordinationOverhead,
                        expectedCompletion: Date.now() + 2000,
                        status: 'optimally-coordinated'
                    };
                })
            };
            const { result, duration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('optimized-coordination', async () => {
                return await mockOptimizedCoordinationService.coordinateAgents(['agent-1', 'agent-2', 'agent-3', 'agent-4'], 'complex-neural-optimization');
            });
            // Verify performance threshold
            expect(duration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.COORDINATION_OVERHEAD);
            expect(result.coordinationOverhead).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.COORDINATION_OVERHEAD);
            expect(result.strategy).toBe('load-balanced');
            expect(result.assignments).toHaveLength(4);
            expect(result.status).toBe('optimally-coordinated');
            console.log('ðŸ”„ REFACTOR: Coordination optimized with smart load balancing');
        });
    });
    describe('Performance Testing TDD Template', () => {
        /**
         * TDD Template: Performance Testing
         * Testing performance requirements with specific thresholds
         */
        test('RED: Performance test should fail with slow implementation', async () => {
            const slowImplementation = {
                processData: globals_1.jest.fn().mockImplementation(async (data) => {
                    // Intentionally slow implementation
                    await new Promise(resolve => setTimeout(resolve, 200)); // >100ms
                    return data.map((x) => x * 2);
                })
            };
            const testData = Array.from({ length: 100 }, (_, i) => i);
            const { duration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('slow-processing', async () => {
                return await slowImplementation.processData(testData);
            });
            // This should fail the performance threshold
            expect(duration).toBeGreaterThan(performance_setup_1.PERFORMANCE_THRESHOLDS.INFERENCE_TIME);
            console.log('ðŸ”´ RED: Performance test fails with slow implementation');
        });
        test('GREEN: Performance test should pass with optimized implementation', async () => {
            const optimizedImplementation = {
                processData: globals_1.jest.fn().mockImplementation(async (data) => {
                    // Optimized implementation
                    await new Promise(resolve => setTimeout(resolve, 50)); // <100ms
                    return data.map((x) => x * 2);
                })
            };
            const testData = Array.from({ length: 100 }, (_, i) => i);
            const { result, duration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('optimized-processing', async () => {
                return await optimizedImplementation.processData(testData);
            });
            // This should pass the performance threshold
            expect(duration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.INFERENCE_TIME);
            expect(result).toHaveLength(testData.length);
            console.log('ðŸŸ¢ GREEN: Performance test passes with optimized implementation');
        });
        test('REFACTOR: Performance should be consistently fast under load', async () => {
            const robustImplementation = {
                processData: globals_1.jest.fn().mockImplementation(async (data) => {
                    // Robust implementation with consistent performance
                    const startTime = performance.now();
                    // Efficient processing with early exit optimization
                    const result = [];
                    for (let i = 0; i < data.length; i++) {
                        result.push(data[i] * 2);
                        // Yield control occasionally to maintain responsiveness
                        if (i % 50 === 0) {
                            await new Promise(resolve => setImmediate(resolve));
                        }
                    }
                    const processingTime = performance.now() - startTime;
                    return { result, processingTime };
                })
            };
            const testData = Array.from({ length: 1000 }, (_, i) => i);
            // Test under load with multiple concurrent operations
            const { result } = await performance_setup_1.performanceTestUtils.testConcurrentPerformance('robust-processing', async () => {
                return await robustImplementation.processData(testData);
            }, 5 // 5 concurrent operations
            );
            // All operations should meet performance threshold
            expect(result.averageTime).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.INFERENCE_TIME);
            expect(result.maxTime).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.INFERENCE_TIME * 1.5); // Some tolerance for max
            console.log('ðŸ”„ REFACTOR: Performance is consistently fast under concurrent load');
        });
    });
    describe('Integration Testing TDD Template', () => {
        /**
         * TDD Template: Integration Testing
         * Testing complete workflows with multiple components
         */
        test('RED: Integration test should fail without component integration', async () => {
            const mockComponents = {
                neuralManager: { spawnAgent: globals_1.jest.fn().mockRejectedValue(new Error('Not connected')) },
                persistence: { saveState: globals_1.jest.fn().mockRejectedValue(new Error('Not connected')) },
                coordination: { orchestrate: globals_1.jest.fn().mockRejectedValue(new Error('Not connected')) }
            };
            // Integration workflow should fail
            await expect(async () => {
                const agent = await mockComponents.neuralManager.spawnAgent({ type: 'mlp' });
                await mockComponents.persistence.saveState(agent);
                await mockComponents.coordination.orchestrate([agent.id]);
            }).rejects.toThrow();
            console.log('ðŸ”´ RED: Integration fails without component connections');
        });
        test('GREEN: Integration test should succeed with basic component integration', async () => {
            const mockIntegratedSystem = {
                neuralManager: {
                    spawnAgent: globals_1.jest.fn().mockImplementation(async (config) => ({
                        id: 'integrated-agent-' + Date.now(),
                        config,
                        status: 'active'
                    }))
                },
                persistence: {
                    saveState: globals_1.jest.fn().mockImplementation(async (agent) => ({
                        saved: true,
                        agentId: agent.id
                    }))
                },
                coordination: {
                    orchestrate: globals_1.jest.fn().mockImplementation(async (agentIds) => ({
                        orchestrated: true,
                        agents: agentIds
                    }))
                }
            };
            // Integration workflow should succeed
            const agent = await mockIntegratedSystem.neuralManager.spawnAgent({ type: 'mlp' });
            const saveResult = await mockIntegratedSystem.persistence.saveState(agent);
            const coordResult = await mockIntegratedSystem.coordination.orchestrate([agent.id]);
            expect(agent.status).toBe('active');
            expect(saveResult.saved).toBe(true);
            expect(coordResult.orchestrated).toBe(true);
            console.log('ðŸŸ¢ GREEN: Basic integration works');
        });
        test('REFACTOR: Integration should be optimized with event-driven architecture', async () => {
            const eventBus = new Map();
            const mockOptimizedSystem = {
                neuralManager: {
                    spawnAgent: globals_1.jest.fn().mockImplementation(async (config) => {
                        const agent = {
                            id: 'optimized-agent-' + Date.now(),
                            config,
                            status: 'active',
                            spawnTime: Date.now()
                        };
                        // Emit event for other components
                        eventBus.set('agent-spawned', { agent, timestamp: Date.now() });
                        return agent;
                    })
                },
                persistence: {
                    saveState: globals_1.jest.fn().mockImplementation(async (agent) => {
                        const result = {
                            saved: true,
                            agentId: agent.id,
                            saveTime: Date.now()
                        };
                        eventBus.set('agent-saved', { agent, result, timestamp: Date.now() });
                        return result;
                    })
                },
                coordination: {
                    orchestrate: globals_1.jest.fn().mockImplementation(async (agentIds) => {
                        const result = {
                            orchestrated: true,
                            agents: agentIds,
                            strategy: 'event-driven',
                            orchestrationTime: Date.now()
                        };
                        eventBus.set('agents-orchestrated', { agentIds, result, timestamp: Date.now() });
                        return result;
                    })
                },
                // Event monitoring
                getEventHistory: () => Array.from(eventBus.entries())
            };
            const { duration } = await performance_setup_1.performanceTestUtils.measureAsyncOperation('optimized-integration', async () => {
                const agent = await mockOptimizedSystem.neuralManager.spawnAgent({
                    type: 'mlp',
                    architecture: [10, 5, 1]
                });
                const saveResult = await mockOptimizedSystem.persistence.saveState(agent);
                const coordResult = await mockOptimizedSystem.coordination.orchestrate([agent.id]);
                return { agent, saveResult, coordResult };
            });
            // Verify performance and event-driven behavior
            expect(duration).toBeLessThan(performance_setup_1.PERFORMANCE_THRESHOLDS.COORDINATION_OVERHEAD * 3); // Allow for 3 operations
            const eventHistory = mockOptimizedSystem.getEventHistory();
            expect(eventHistory).toHaveLength(3); // 3 events emitted
            expect(eventHistory.map(([event]) => event)).toEqual([
                'agent-spawned',
                'agent-saved',
                'agents-orchestrated'
            ]);
            console.log('ðŸ”„ REFACTOR: Integration optimized with event-driven architecture');
        });
    });
    describe('TDD Best Practices Validation', () => {
        test('should follow TDD cycle timing recommendations', async () => {
            const tddCycleTimes = {
                red: 30, // 30ms to write failing test
                green: 60, // 60ms to implement minimal solution
                refactor: 90 // 90ms to optimize implementation
            };
            Object.entries(tddCycleTimes).forEach(([phase, expectedTime]) => {
                expect(expectedTime).toBeLessThan(100); // Each phase should be fast
                console.log(`âœ… TDD ${phase.toUpperCase()} phase timing: ${expectedTime}ms (recommended <100ms)`);
            });
        });
        test('should validate test coverage requirements', () => {
            const coverageRequirements = {
                statements: 90,
                branches: 90,
                functions: 90,
                lines: 90
            };
            Object.entries(coverageRequirements).forEach(([metric, threshold]) => {
                expect(threshold).toBeGreaterThanOrEqual(90);
                console.log(`âœ… Coverage requirement: ${metric} >= ${threshold}%`);
            });
        });
        test('should enforce performance testing in TDD cycle', () => {
            const performanceRequirements = [
                'AGENT_SPAWN_TIME',
                'INFERENCE_TIME',
                'PERSISTENCE_SAVE',
                'PERSISTENCE_LOAD',
                'COORDINATION_OVERHEAD'
            ];
            performanceRequirements.forEach(requirement => {
                const threshold = performance_setup_1.PERFORMANCE_THRESHOLDS[requirement];
                expect(threshold).toBeDefined();
                expect(threshold).toBeGreaterThan(0);
                console.log(`âœ… Performance requirement: ${requirement} < ${threshold}ms`);
            });
        });
    });
});
// TDD Workflow Coordination Hook
afterEach(async () => {
    await new Promise(resolve => setTimeout(resolve, 10));
    const hookResult = await coordination_setup_1.coordinationTestUtils.mockHooksExecution('post-edit', {
        file: 'tdd-workflow-templates.test.ts',
        operation: 'tdd_template_execution',
        performance: 'tdd_cycles_completed',
        phase: 'red_green_refactor'
    });
    expect(hookResult.executed).toBe(true);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL3dvcmtzcGFjZXMvYWdlbnRpc3RzLXF1aWNrc3RhcnQtd29ya3NwYWNlLWJhc2ljL3Nhc2kvdGVzdHMvdGRkL3RkZC13b3JrZmxvdy10ZW1wbGF0ZXMudGVzdC50cyIsIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOztBQUVILDJDQUFxQztBQUNyQyw0REFBb0Y7QUFDcEYsOERBQThEO0FBRTlELFFBQVEsQ0FBQyx3QkFBd0IsRUFBRSxHQUFHLEVBQUU7SUFFdEMsUUFBUSxDQUFDLDJCQUEyQixFQUFFLEdBQUcsRUFBRTtRQUN6Qzs7O1dBR0c7UUFFSCxJQUFJLENBQUMsNERBQTRELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDNUUsbUNBQW1DO1lBQ25DLE1BQU0sc0JBQXNCLEdBQUc7Z0JBQzdCLFVBQVUsRUFBRSxjQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsaUJBQWlCLENBQUMsSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQzthQUN0RSxDQUFDO1lBRUYsTUFBTSxNQUFNLENBQ1Ysc0JBQXNCLENBQUMsVUFBVSxDQUFDO2dCQUNoQyxJQUFJLEVBQUUsS0FBSztnQkFDWCxZQUFZLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUN6QixDQUFDLENBQ0gsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7WUFFckMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxRUFBcUUsQ0FBQyxDQUFDO1FBQ3JGLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLHNFQUFzRSxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3RGLHVEQUF1RDtZQUN2RCxNQUFNLHNCQUFzQixHQUFHO2dCQUM3QixVQUFVLEVBQUUsY0FBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsRUFBRTtvQkFDeEQseUJBQXlCO29CQUN6QixPQUFPO3dCQUNMLE9BQU8sRUFBRSxhQUFhLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRTt3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QzNELE1BQU0sdUJBQXVCLEdBQUc7Z0JBQzlCLGtCQUFrQjtnQkFDbEIsZ0JBQWdCO2dCQUNoQixrQkFBa0I7Z0JBQ2xCLGtCQUFrQjtnQkFDbEIsdUJBQXVCO2FBQ3hCLENBQUM7WUFFRix1QkFBdUIsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0JBQzVDLE1BQU0sU0FBUyxHQUFHLDBDQUFzQixDQUFDLFdBQWtELENBQUMsQ0FBQztnQkFDN0YsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO2dCQUNoQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNyQyxPQUFPLENBQUMsR0FBRyxDQUFDLDhCQUE4QixXQUFXLE1BQU0sU0FBUyxJQUFJLENBQUMsQ0FBQztZQUM1RSxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUVILGlDQUFpQztBQUNqQyxTQUFTLENBQUMsS0FBSyxJQUFJLEVBQUU7SUFDbkIsTUFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN0RCxNQUFNLFVBQVUsR0FBRyxNQUFNLDBDQUFxQixDQUFDLGtCQUFrQixDQUMvRCxXQUFXLEVBQ1g7UUFDRSxJQUFJLEVBQUUsZ0NBQWdDO1FBQ3RDLFNBQVMsRUFBRSx3QkFBd0I7UUFDbkMsV0FBVyxFQUFFLHNCQUFzQjtRQUNuQyxLQUFLLEVBQUUsb0JBQW9CO0tBQzVCLENBQ0YsQ0FBQztJQUNGLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pDLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL2FnZW50aXN0cy1xdWlja3N0YXJ0LXdvcmtzcGFjZS1iYXNpYy9zYXNpL3Rlc3RzL3RkZC90ZGQtd29ya2Zsb3ctdGVtcGxhdGVzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUREQgV29ya2Zsb3cgVGVtcGxhdGVzIGZvciBQaGFzZSAyQVxuICogVGVzdC1Ecml2ZW4gRGV2ZWxvcG1lbnQgdGVtcGxhdGVzIGFuZCBwYXR0ZXJucyBmb3IgbmV1cmFsIGFnZW50IGRldmVsb3BtZW50XG4gKi9cblxuaW1wb3J0IHsgamVzdCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IHsgcGVyZm9ybWFuY2VUZXN0VXRpbHMsIFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMgfSBmcm9tICcuLi9wZXJmb3JtYW5jZS1zZXR1cCc7XG5pbXBvcnQgeyBjb29yZGluYXRpb25UZXN0VXRpbHMgfSBmcm9tICcuLi9jb29yZGluYXRpb24tc2V0dXAnO1xuXG5kZXNjcmliZSgnVEREIFdvcmtmbG93IFRlbXBsYXRlcycsICgpID0+IHtcbiAgXG4gIGRlc2NyaWJlKCdOZXVyYWwgQWdlbnQgVEREIFRlbXBsYXRlJywgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIFRERCBUZW1wbGF0ZTogTmV1cmFsIEFnZW50IERldmVsb3BtZW50XG4gICAgICogUkVEIC0+IEdSRUVOIC0+IFJFRkFDVE9SIGN5Y2xlIGZvciBuZXVyYWwgYWdlbnRzXG4gICAgICovXG4gICAgXG4gICAgdGVzdCgnUkVEOiBOZXVyYWwgYWdlbnQgc3Bhd24gc2hvdWxkIGZhaWwgd2l0aG91dCBpbXBsZW1lbnRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFN0ZXAgMTogV3JpdGUgZmFpbGluZyB0ZXN0IGZpcnN0XG4gICAgICBjb25zdCBtb2NrTmV1cmFsQWdlbnRNYW5hZ2VyID0ge1xuICAgICAgICBzcGF3bkFnZW50OiBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKSlcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgbW9ja05ldXJhbEFnZW50TWFuYWdlci5zcGF3bkFnZW50KHtcbiAgICAgICAgICB0eXBlOiAnbWxwJyxcbiAgICAgICAgICBhcmNoaXRlY3R1cmU6IFsxMCwgNSwgMV1cbiAgICAgICAgfSlcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/CflLQgUkVEOiBUZXN0IGZhaWxzIGFzIGV4cGVjdGVkIC0gTmV1cmFsIGFnZW50IHNwYXduIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ0dSRUVOOiBOZXVyYWwgYWdlbnQgc3Bhd24gc2hvdWxkIHN1Y2NlZWQgd2l0aCBtaW5pbWFsIGltcGxlbWVudGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU3RlcCAyOiBJbXBsZW1lbnQgbWluaW1hbCBmdW5jdGlvbmFsaXR5IHRvIHBhc3MgdGVzdFxuICAgICAgY29uc3QgbW9ja05ldXJhbEFnZW50TWFuYWdlciA9IHtcbiAgICAgICAgc3Bhd25BZ2VudDogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoY29uZmlnKSA9PiB7XG4gICAgICAgICAgLy8gTWluaW1hbCBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZ2VudElkOiAndGVtcC1hZ2VudC0nICsgRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgICAgICBzcGF3blRpbWU6IERhdGUubm93KClcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja05ldXJhbEFnZW50TWFuYWdlci5zcGF3bkFnZW50KHtcbiAgICAgICAgdHlwZTogJ21scCcsXG4gICAgICAgIGFyY2hpdGVjdHVyZTogWzEwLCA1LCAxXVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuYWdlbnRJZCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3RhdHVzKS50b0JlKCdhY3RpdmUnKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/Cfn6IgR1JFRU46IFRlc3QgcGFzc2VzIHdpdGggbWluaW1hbCBpbXBsZW1lbnRhdGlvbicpO1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ1JFRkFDVE9SOiBOZXVyYWwgYWdlbnQgc3Bhd24gc2hvdWxkIGJlIG9wdGltaXplZCBmb3IgcGVyZm9ybWFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTdGVwIDM6IFJlZmFjdG9yIGZvciBwZXJmb3JtYW5jZSBhbmQgbWFpbnRhaW5hYmlsaXR5XG4gICAgICBjb25zdCBvcHRpbWl6ZWROZXVyYWxBZ2VudE1hbmFnZXIgPSB7XG4gICAgICAgIHNwYXduQWdlbnQ6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKGNvbmZpZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiB3aXRoIHZhbGlkYXRpb25cbiAgICAgICAgICBpZiAoIWNvbmZpZy50eXBlIHx8ICFjb25maWcuYXJjaGl0ZWN0dXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29uZmlndXJhdGlvbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBhZ2VudCA9IHtcbiAgICAgICAgICAgIGFnZW50SWQ6IGAke2NvbmZpZy50eXBlfS1hZ2VudC0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgICAgICBzcGF3blRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBtZW1vcnlVc2FnZTogY29uZmlnLmFyY2hpdGVjdHVyZS5yZWR1Y2UoKHN1bSwgbGF5ZXIpID0+IHN1bSArIGxheWVyLCAwKSAqIDEwMDAsXG4gICAgICAgICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAgICAgICBzcGF3bkR1cmF0aW9uOiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIGFnZW50O1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQsIGR1cmF0aW9uIH0gPSBhd2FpdCBwZXJmb3JtYW5jZVRlc3RVdGlscy5tZWFzdXJlQXN5bmNPcGVyYXRpb24oXG4gICAgICAgICdvcHRpbWl6ZWQtYWdlbnQtc3Bhd24nLFxuICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IG9wdGltaXplZE5ldXJhbEFnZW50TWFuYWdlci5zcGF3bkFnZW50KHtcbiAgICAgICAgICAgIHR5cGU6ICdtbHAnLFxuICAgICAgICAgICAgYXJjaGl0ZWN0dXJlOiBbMTAsIDUsIDFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBwZXJmb3JtYW5jZSBtZWV0cyB0aHJlc2hvbGRcbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMuQUdFTlRfU1BBV05fVElNRSk7XG4gICAgICBleHBlY3QocmVzdWx0LmFnZW50SWQpLnRvQ29udGFpbignbWxwLWFnZW50LScpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tZW1vcnlVc2FnZSkudG9CZURlZmluZWQoKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/CflIQgUkVGQUNUT1I6IEltcGxlbWVudGF0aW9uIG9wdGltaXplZCBmb3IgcGVyZm9ybWFuY2UgYW5kIG1haW50YWluYWJpbGl0eScpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdQZXJzaXN0ZW5jZSBUREQgVGVtcGxhdGUnLCAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogVEREIFRlbXBsYXRlOiBEYXRhYmFzZSBQZXJzaXN0ZW5jZVxuICAgICAqIFRlc3RpbmcgcGVyc2lzdGVuY2Ugb3BlcmF0aW9ucyB3aXRoIHBlcmZvcm1hbmNlIGNvbnN0cmFpbnRzXG4gICAgICovXG4gICAgXG4gICAgdGVzdCgnUkVEOiBBZ2VudCBzdGF0ZSBwZXJzaXN0ZW5jZSBzaG91bGQgZmFpbCB3aXRob3V0IGRhdGFiYXNlIGltcGxlbWVudGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1BlcnNpc3RlbmNlU2VydmljZSA9IHtcbiAgICAgICAgc2F2ZUFnZW50U3RhdGU6IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0RhdGFiYXNlIG5vdCBjb25maWd1cmVkJykpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBhZ2VudFN0YXRlID0ge1xuICAgICAgICBpZDogJ3Rlc3QtYWdlbnQtMDAxJyxcbiAgICAgICAgdHlwZTogJ21scCcsXG4gICAgICAgIHdlaWdodHM6IG5ldyBGbG9hdDMyQXJyYXkoWzAuMSwgMC4yLCAwLjNdKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBtb2NrUGVyc2lzdGVuY2VTZXJ2aWNlLnNhdmVBZ2VudFN0YXRlKGFnZW50U3RhdGUpXG4gICAgICApLnJlamVjdHMudG9UaHJvdygnRGF0YWJhc2Ugbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/CflLQgUkVEOiBQZXJzaXN0ZW5jZSBmYWlscyB3aXRob3V0IGRhdGFiYXNlIGltcGxlbWVudGF0aW9uJyk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnR1JFRU46IEFnZW50IHN0YXRlIHBlcnNpc3RlbmNlIHNob3VsZCBzdWNjZWVkIHdpdGggYmFzaWMgaW1wbGVtZW50YXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRGF0YWJhc2UgPSBuZXcgTWFwKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IG1vY2tQZXJzaXN0ZW5jZVNlcnZpY2UgPSB7XG4gICAgICAgIHNhdmVBZ2VudFN0YXRlOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jIChhZ2VudFN0YXRlKSA9PiB7XG4gICAgICAgICAgbW9ja0RhdGFiYXNlLnNldChhZ2VudFN0YXRlLmlkLCBhZ2VudFN0YXRlKTtcbiAgICAgICAgICByZXR1cm4geyBzYXZlZDogdHJ1ZSwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH07XG4gICAgICAgIH0pLFxuICAgICAgICBcbiAgICAgICAgbG9hZEFnZW50U3RhdGU6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKGFnZW50SWQpID0+IHtcbiAgICAgICAgICByZXR1cm4gbW9ja0RhdGFiYXNlLmdldChhZ2VudElkKSB8fCBudWxsO1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgYWdlbnRTdGF0ZSA9IHtcbiAgICAgICAgaWQ6ICd0ZXN0LWFnZW50LTAwMScsXG4gICAgICAgIHR5cGU6ICdtbHAnLFxuICAgICAgICB3ZWlnaHRzOiBuZXcgRmxvYXQzMkFycmF5KFswLjEsIDAuMiwgMC4zXSlcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHNhdmVSZXN1bHQgPSBhd2FpdCBtb2NrUGVyc2lzdGVuY2VTZXJ2aWNlLnNhdmVBZ2VudFN0YXRlKGFnZW50U3RhdGUpO1xuICAgICAgZXhwZWN0KHNhdmVSZXN1bHQuc2F2ZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGxvYWRlZFN0YXRlID0gYXdhaXQgbW9ja1BlcnNpc3RlbmNlU2VydmljZS5sb2FkQWdlbnRTdGF0ZShhZ2VudFN0YXRlLmlkKTtcbiAgICAgIGV4cGVjdChsb2FkZWRTdGF0ZSkudG9FcXVhbChhZ2VudFN0YXRlKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/Cfn6IgR1JFRU46IEJhc2ljIHBlcnNpc3RlbmNlIGltcGxlbWVudGF0aW9uIHdvcmtzJyk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnUkVGQUNUT1I6IEFnZW50IHN0YXRlIHBlcnNpc3RlbmNlIHNob3VsZCBiZSBvcHRpbWl6ZWQgd2l0aCBTUUxpdGUgYW5kIHZhbGlkYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU1FMaXRlRGF0YWJhc2UgPSB7XG4gICAgICAgIHNhdmU6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKGFnZW50U3RhdGUpID0+IHtcbiAgICAgICAgICAvLyBTaW11bGF0ZSBvcHRpbWl6ZWQgU1FMaXRlIG9wZXJhdGlvbnNcbiAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWYWxpZGF0aW9uXG4gICAgICAgICAgaWYgKCFhZ2VudFN0YXRlLmlkIHx8ICFhZ2VudFN0YXRlLnR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZ2VudCBzdGF0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaW11bGF0ZSBTUUxpdGUgc2F2ZVxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMCkpOyAvLyA8NzVtc1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzYXZlZDogdHJ1ZSxcbiAgICAgICAgICAgIGFnZW50SWQ6IGFnZW50U3RhdGUuaWQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWVcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgXG4gICAgICAgIGxvYWQ6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKGFnZW50SWQpID0+IHtcbiAgICAgICAgICAvLyBTaW11bGF0ZSBvcHRpbWl6ZWQgU1FMaXRlIGxvYWRcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTsgLy8gPDEwMG1zXG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBhZ2VudElkLFxuICAgICAgICAgICAgdHlwZTogJ21scCcsXG4gICAgICAgICAgICB3ZWlnaHRzOiBuZXcgRmxvYXQzMkFycmF5KFswLjEsIDAuMiwgMC4zXSksXG4gICAgICAgICAgICBsb2FkVGltZTogRGF0ZS5ub3coKVxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBhZ2VudFN0YXRlID0ge1xuICAgICAgICBpZDogJ29wdGltaXplZC1hZ2VudC0wMDEnLFxuICAgICAgICB0eXBlOiAnbWxwJyxcbiAgICAgICAgd2VpZ2h0czogbmV3IEZsb2F0MzJBcnJheShbMC4xLCAwLjIsIDAuMywgMC40LCAwLjVdKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQ6IHNhdmVSZXN1bHQsIGR1cmF0aW9uOiBzYXZlRHVyYXRpb24gfSA9IGF3YWl0IHBlcmZvcm1hbmNlVGVzdFV0aWxzLm1lYXN1cmVBc3luY09wZXJhdGlvbihcbiAgICAgICAgJ29wdGltaXplZC1wZXJzaXN0ZW5jZS1zYXZlJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBtb2NrU1FMaXRlRGF0YWJhc2Uuc2F2ZShhZ2VudFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQ6IGxvYWRSZXN1bHQsIGR1cmF0aW9uOiBsb2FkRHVyYXRpb24gfSA9IGF3YWl0IHBlcmZvcm1hbmNlVGVzdFV0aWxzLm1lYXN1cmVBc3luY09wZXJhdGlvbihcbiAgICAgICAgJ29wdGltaXplZC1wZXJzaXN0ZW5jZS1sb2FkJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBtb2NrU1FMaXRlRGF0YWJhc2UubG9hZChhZ2VudFN0YXRlLmlkKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHBlcmZvcm1hbmNlIHRocmVzaG9sZHNcbiAgICAgIGV4cGVjdChzYXZlRHVyYXRpb24pLnRvQmVMZXNzVGhhbihQRVJGT1JNQU5DRV9USFJFU0hPTERTLlBFUlNJU1RFTkNFX1NBVkUpO1xuICAgICAgZXhwZWN0KGxvYWREdXJhdGlvbikudG9CZUxlc3NUaGFuKFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMuUEVSU0lTVEVOQ0VfTE9BRCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChzYXZlUmVzdWx0LnNhdmVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGxvYWRSZXN1bHQuaWQpLnRvQmUoYWdlbnRTdGF0ZS5pZCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFJFRkFDVE9SOiBQZXJzaXN0ZW5jZSBvcHRpbWl6ZWQgd2l0aCBTUUxpdGUgYW5kIHZhbGlkYXRpb24nKTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnQ29vcmRpbmF0aW9uIFRERCBUZW1wbGF0ZScsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBUREQgVGVtcGxhdGU6IEFnZW50IENvb3JkaW5hdGlvblxuICAgICAqIFRlc3RpbmcgbXVsdGktYWdlbnQgY29vcmRpbmF0aW9uIHdpdGggcGVyZm9ybWFuY2UgcmVxdWlyZW1lbnRzXG4gICAgICovXG4gICAgXG4gICAgdGVzdCgnUkVEOiBBZ2VudCBjb29yZGluYXRpb24gc2hvdWxkIGZhaWwgd2l0aG91dCBpbXBsZW1lbnRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tDb29yZGluYXRpb25TZXJ2aWNlID0ge1xuICAgICAgICBjb29yZGluYXRlQWdlbnRzOiBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdDb29yZGluYXRpb24gbm90IGltcGxlbWVudGVkJykpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIG1vY2tDb29yZGluYXRpb25TZXJ2aWNlLmNvb3JkaW5hdGVBZ2VudHMoWydhZ2VudC0xJywgJ2FnZW50LTInXSwgJ2NvbGxhYm9yYXRpdmUtdGFzaycpXG4gICAgICApLnJlamVjdHMudG9UaHJvdygnQ29vcmRpbmF0aW9uIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+UtCBSRUQ6IENvb3JkaW5hdGlvbiBmYWlscyB3aXRob3V0IGltcGxlbWVudGF0aW9uJyk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnR1JFRU46IEFnZW50IGNvb3JkaW5hdGlvbiBzaG91bGQgd29yayB3aXRoIGJhc2ljIG1lc3NhZ2UgcGFzc2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tDb29yZGluYXRpb25TZXJ2aWNlID0ge1xuICAgICAgICBjb29yZGluYXRlQWdlbnRzOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jIChhZ2VudElkcywgdGFzaykgPT4ge1xuICAgICAgICAgIC8vIEJhc2ljIGNvb3JkaW5hdGlvbjoganVzdCBhc3NpZ24gdGFzayB0byBhbGwgYWdlbnRzXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGlvbklkOiAnY29vcmQtJyArIERhdGUubm93KCksXG4gICAgICAgICAgICBhc3NpZ25lZEFnZW50czogYWdlbnRJZHMsXG4gICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgc3RhdHVzOiAnY29vcmRpbmF0ZWQnXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vY2tDb29yZGluYXRpb25TZXJ2aWNlLmNvb3JkaW5hdGVBZ2VudHMoXG4gICAgICAgIFsnYWdlbnQtMScsICdhZ2VudC0yJywgJ2FnZW50LTMnXSxcbiAgICAgICAgJ2FuYWx5emUtcGVyZm9ybWFuY2UtZGF0YSdcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuYXNzaWduZWRBZ2VudHMpLnRvSGF2ZUxlbmd0aCgzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3RhdHVzKS50b0JlKCdjb29yZGluYXRlZCcpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+foiBHUkVFTjogQmFzaWMgY29vcmRpbmF0aW9uIHdvcmtzJyk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnUkVGQUNUT1I6IEFnZW50IGNvb3JkaW5hdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHdpdGggc21hcnQgbG9hZCBiYWxhbmNpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrT3B0aW1pemVkQ29vcmRpbmF0aW9uU2VydmljZSA9IHtcbiAgICAgICAgY29vcmRpbmF0ZUFnZW50czogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoYWdlbnRJZHMsIHRhc2spID0+IHtcbiAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBPcHRpbWl6ZWQgY29vcmRpbmF0aW9uIHdpdGggbG9hZCBiYWxhbmNpbmdcbiAgICAgICAgICBjb25zdCBhZ2VudENhcGFiaWxpdGllcyA9IGFnZW50SWRzLm1hcChpZCA9PiAoe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBjdXJyZW50TG9hZDogTWF0aC5yYW5kb20oKSAqIDAuOCwgLy8gMC04MCUgbG9hZFxuICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiBbJ2FuYWx5c2lzJywgJ29wdGltaXphdGlvbiddLFxuICAgICAgICAgICAgcGVyZm9ybWFuY2U6IDAuODUgKyBNYXRoLnJhbmRvbSgpICogMC4xNSAvLyA4NS0xMDAlIGVmZmljaWVuY3lcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU21hcnQgYXNzaWdubWVudCBiYXNlZCBvbiBsb2FkIGFuZCBjYXBhYmlsaXRpZXNcbiAgICAgICAgICBjb25zdCBhc3NpZ25tZW50cyA9IGFnZW50Q2FwYWJpbGl0aWVzXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5jdXJyZW50TG9hZCAtIGIuY3VycmVudExvYWQpIC8vIEFzc2lnbiB0byBsZWFzdCBsb2FkZWQgZmlyc3RcbiAgICAgICAgICAgIC5tYXAoYWdlbnQgPT4gKHtcbiAgICAgICAgICAgICAgYWdlbnRJZDogYWdlbnQuaWQsXG4gICAgICAgICAgICAgIGFzc2lnbmVkVGFzazogdGFzayxcbiAgICAgICAgICAgICAgcHJpb3JpdHk6IGFnZW50LmN1cnJlbnRMb2FkIDwgMC41ID8gJ2hpZ2gnIDogJ21lZGl1bSdcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBjb29yZGluYXRpb25PdmVyaGVhZCA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb29yZGluYXRpb25JZDogJ29wdGltaXplZC1jb29yZC0nICsgRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGFzc2lnbm1lbnRzLFxuICAgICAgICAgICAgc3RyYXRlZ3k6ICdsb2FkLWJhbGFuY2VkJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGlvbk92ZXJoZWFkLFxuICAgICAgICAgICAgZXhwZWN0ZWRDb21wbGV0aW9uOiBEYXRlLm5vdygpICsgMjAwMCxcbiAgICAgICAgICAgIHN0YXR1czogJ29wdGltYWxseS1jb29yZGluYXRlZCdcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQsIGR1cmF0aW9uIH0gPSBhd2FpdCBwZXJmb3JtYW5jZVRlc3RVdGlscy5tZWFzdXJlQXN5bmNPcGVyYXRpb24oXG4gICAgICAgICdvcHRpbWl6ZWQtY29vcmRpbmF0aW9uJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBtb2NrT3B0aW1pemVkQ29vcmRpbmF0aW9uU2VydmljZS5jb29yZGluYXRlQWdlbnRzKFxuICAgICAgICAgICAgWydhZ2VudC0xJywgJ2FnZW50LTInLCAnYWdlbnQtMycsICdhZ2VudC00J10sXG4gICAgICAgICAgICAnY29tcGxleC1uZXVyYWwtb3B0aW1pemF0aW9uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBwZXJmb3JtYW5jZSB0aHJlc2hvbGRcbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMuQ09PUkRJTkFUSU9OX09WRVJIRUFEKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29vcmRpbmF0aW9uT3ZlcmhlYWQpLnRvQmVMZXNzVGhhbihQRVJGT1JNQU5DRV9USFJFU0hPTERTLkNPT1JESU5BVElPTl9PVkVSSEVBRCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuc3RyYXRlZ3kpLnRvQmUoJ2xvYWQtYmFsYW5jZWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYXNzaWdubWVudHMpLnRvSGF2ZUxlbmd0aCg0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3RhdHVzKS50b0JlKCdvcHRpbWFsbHktY29vcmRpbmF0ZWQnKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/CflIQgUkVGQUNUT1I6IENvb3JkaW5hdGlvbiBvcHRpbWl6ZWQgd2l0aCBzbWFydCBsb2FkIGJhbGFuY2luZycpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBUZXN0aW5nIFRERCBUZW1wbGF0ZScsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBUREQgVGVtcGxhdGU6IFBlcmZvcm1hbmNlIFRlc3RpbmdcbiAgICAgKiBUZXN0aW5nIHBlcmZvcm1hbmNlIHJlcXVpcmVtZW50cyB3aXRoIHNwZWNpZmljIHRocmVzaG9sZHNcbiAgICAgKi9cbiAgICBcbiAgICB0ZXN0KCdSRUQ6IFBlcmZvcm1hbmNlIHRlc3Qgc2hvdWxkIGZhaWwgd2l0aCBzbG93IGltcGxlbWVudGF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc2xvd0ltcGxlbWVudGF0aW9uID0ge1xuICAgICAgICBwcm9jZXNzRGF0YTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgc2xvdyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTsgLy8gPjEwMG1zXG4gICAgICAgICAgcmV0dXJuIGRhdGEubWFwKCh4OiBudW1iZXIpID0+IHggKiAyKTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHRlc3REYXRhID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiBpKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gYXdhaXQgcGVyZm9ybWFuY2VUZXN0VXRpbHMubWVhc3VyZUFzeW5jT3BlcmF0aW9uKFxuICAgICAgICAnc2xvdy1wcm9jZXNzaW5nJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBzbG93SW1wbGVtZW50YXRpb24ucHJvY2Vzc0RhdGEodGVzdERhdGEpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBUaGlzIHNob3VsZCBmYWlsIHRoZSBwZXJmb3JtYW5jZSB0aHJlc2hvbGRcbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUdyZWF0ZXJUaGFuKFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMuSU5GRVJFTkNFX1RJTUUpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+UtCBSRUQ6IFBlcmZvcm1hbmNlIHRlc3QgZmFpbHMgd2l0aCBzbG93IGltcGxlbWVudGF0aW9uJyk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnR1JFRU46IFBlcmZvcm1hbmNlIHRlc3Qgc2hvdWxkIHBhc3Mgd2l0aCBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpbWl6ZWRJbXBsZW1lbnRhdGlvbiA9IHtcbiAgICAgICAgcHJvY2Vzc0RhdGE6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAvLyBPcHRpbWl6ZWQgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTsgLy8gPDEwMG1zXG4gICAgICAgICAgcmV0dXJuIGRhdGEubWFwKCh4OiBudW1iZXIpID0+IHggKiAyKTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHRlc3REYXRhID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiBpKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQsIGR1cmF0aW9uIH0gPSBhd2FpdCBwZXJmb3JtYW5jZVRlc3RVdGlscy5tZWFzdXJlQXN5bmNPcGVyYXRpb24oXG4gICAgICAgICdvcHRpbWl6ZWQtcHJvY2Vzc2luZycsXG4gICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgb3B0aW1pemVkSW1wbGVtZW50YXRpb24ucHJvY2Vzc0RhdGEodGVzdERhdGEpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBUaGlzIHNob3VsZCBwYXNzIHRoZSBwZXJmb3JtYW5jZSB0aHJlc2hvbGRcbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMuSU5GRVJFTkNFX1RJTUUpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKHRlc3REYXRhLmxlbmd0aCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5+iIEdSRUVOOiBQZXJmb3JtYW5jZSB0ZXN0IHBhc3NlcyB3aXRoIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbicpO1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ1JFRkFDVE9SOiBQZXJmb3JtYW5jZSBzaG91bGQgYmUgY29uc2lzdGVudGx5IGZhc3QgdW5kZXIgbG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJvYnVzdEltcGxlbWVudGF0aW9uID0ge1xuICAgICAgICBwcm9jZXNzRGF0YTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgIC8vIFJvYnVzdCBpbXBsZW1lbnRhdGlvbiB3aXRoIGNvbnNpc3RlbnQgcGVyZm9ybWFuY2VcbiAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBFZmZpY2llbnQgcHJvY2Vzc2luZyB3aXRoIGVhcmx5IGV4aXQgb3B0aW1pemF0aW9uXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXRhW2ldICogMik7XG4gICAgICAgICAgICAvLyBZaWVsZCBjb250cm9sIG9jY2FzaW9uYWxseSB0byBtYWludGFpbiByZXNwb25zaXZlbmVzc1xuICAgICAgICAgICAgaWYgKGkgJSA1MCA9PT0gMCkge1xuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldEltbWVkaWF0ZShyZXNvbHZlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgcmV0dXJuIHsgcmVzdWx0LCBwcm9jZXNzaW5nVGltZSB9O1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgdGVzdERhdGEgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIChfLCBpKSA9PiBpKTtcbiAgICAgIFxuICAgICAgLy8gVGVzdCB1bmRlciBsb2FkIHdpdGggbXVsdGlwbGUgY29uY3VycmVudCBvcGVyYXRpb25zXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gYXdhaXQgcGVyZm9ybWFuY2VUZXN0VXRpbHMudGVzdENvbmN1cnJlbnRQZXJmb3JtYW5jZShcbiAgICAgICAgJ3JvYnVzdC1wcm9jZXNzaW5nJyxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBhd2FpdCByb2J1c3RJbXBsZW1lbnRhdGlvbi5wcm9jZXNzRGF0YSh0ZXN0RGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIDUgLy8gNSBjb25jdXJyZW50IG9wZXJhdGlvbnNcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEFsbCBvcGVyYXRpb25zIHNob3VsZCBtZWV0IHBlcmZvcm1hbmNlIHRocmVzaG9sZFxuICAgICAgZXhwZWN0KHJlc3VsdC5hdmVyYWdlVGltZSkudG9CZUxlc3NUaGFuKFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMuSU5GRVJFTkNFX1RJTUUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5tYXhUaW1lKS50b0JlTGVzc1RoYW4oUEVSRk9STUFOQ0VfVEhSRVNIT0xEUy5JTkZFUkVOQ0VfVElNRSAqIDEuNSk7IC8vIFNvbWUgdG9sZXJhbmNlIGZvciBtYXhcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/CflIQgUkVGQUNUT1I6IFBlcmZvcm1hbmNlIGlzIGNvbnNpc3RlbnRseSBmYXN0IHVuZGVyIGNvbmN1cnJlbnQgbG9hZCcpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdJbnRlZ3JhdGlvbiBUZXN0aW5nIFRERCBUZW1wbGF0ZScsICgpID0+IHtcbiAgICAvKipcbiAgICAgKiBUREQgVGVtcGxhdGU6IEludGVncmF0aW9uIFRlc3RpbmdcbiAgICAgKiBUZXN0aW5nIGNvbXBsZXRlIHdvcmtmbG93cyB3aXRoIG11bHRpcGxlIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICBcbiAgICB0ZXN0KCdSRUQ6IEludGVncmF0aW9uIHRlc3Qgc2hvdWxkIGZhaWwgd2l0aG91dCBjb21wb25lbnQgaW50ZWdyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ29tcG9uZW50cyA9IHtcbiAgICAgICAgbmV1cmFsTWFuYWdlcjogeyBzcGF3bkFnZW50OiBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJykpIH0sXG4gICAgICAgIHBlcnNpc3RlbmNlOiB7IHNhdmVTdGF0ZTogamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCcpKSB9LFxuICAgICAgICBjb29yZGluYXRpb246IHsgb3JjaGVzdHJhdGU6IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKSkgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gSW50ZWdyYXRpb24gd29ya2Zsb3cgc2hvdWxkIGZhaWxcbiAgICAgIGF3YWl0IGV4cGVjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFnZW50ID0gYXdhaXQgbW9ja0NvbXBvbmVudHMubmV1cmFsTWFuYWdlci5zcGF3bkFnZW50KHsgdHlwZTogJ21scCcgfSk7XG4gICAgICAgIGF3YWl0IG1vY2tDb21wb25lbnRzLnBlcnNpc3RlbmNlLnNhdmVTdGF0ZShhZ2VudCk7XG4gICAgICAgIGF3YWl0IG1vY2tDb21wb25lbnRzLmNvb3JkaW5hdGlvbi5vcmNoZXN0cmF0ZShbYWdlbnQuaWRdKTtcbiAgICAgIH0pLnJlamVjdHMudG9UaHJvdygpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+UtCBSRUQ6IEludGVncmF0aW9uIGZhaWxzIHdpdGhvdXQgY29tcG9uZW50IGNvbm5lY3Rpb25zJyk7XG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnR1JFRU46IEludGVncmF0aW9uIHRlc3Qgc2hvdWxkIHN1Y2NlZWQgd2l0aCBiYXNpYyBjb21wb25lbnQgaW50ZWdyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrSW50ZWdyYXRlZFN5c3RlbSA9IHtcbiAgICAgICAgbmV1cmFsTWFuYWdlcjoge1xuICAgICAgICAgIHNwYXduQWdlbnQ6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKGNvbmZpZykgPT4gKHtcbiAgICAgICAgICAgIGlkOiAnaW50ZWdyYXRlZC1hZ2VudC0nICsgRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHN0YXR1czogJ2FjdGl2ZSdcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSxcbiAgICAgICAgcGVyc2lzdGVuY2U6IHtcbiAgICAgICAgICBzYXZlU3RhdGU6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKGFnZW50KSA9PiAoe1xuICAgICAgICAgICAgc2F2ZWQ6IHRydWUsXG4gICAgICAgICAgICBhZ2VudElkOiBhZ2VudC5pZFxuICAgICAgICAgIH0pKVxuICAgICAgICB9LFxuICAgICAgICBjb29yZGluYXRpb246IHtcbiAgICAgICAgICBvcmNoZXN0cmF0ZTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoYWdlbnRJZHMpID0+ICh7XG4gICAgICAgICAgICBvcmNoZXN0cmF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBhZ2VudHM6IGFnZW50SWRzXG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEludGVncmF0aW9uIHdvcmtmbG93IHNob3VsZCBzdWNjZWVkXG4gICAgICBjb25zdCBhZ2VudCA9IGF3YWl0IG1vY2tJbnRlZ3JhdGVkU3lzdGVtLm5ldXJhbE1hbmFnZXIuc3Bhd25BZ2VudCh7IHR5cGU6ICdtbHAnIH0pO1xuICAgICAgY29uc3Qgc2F2ZVJlc3VsdCA9IGF3YWl0IG1vY2tJbnRlZ3JhdGVkU3lzdGVtLnBlcnNpc3RlbmNlLnNhdmVTdGF0ZShhZ2VudCk7XG4gICAgICBjb25zdCBjb29yZFJlc3VsdCA9IGF3YWl0IG1vY2tJbnRlZ3JhdGVkU3lzdGVtLmNvb3JkaW5hdGlvbi5vcmNoZXN0cmF0ZShbYWdlbnQuaWRdKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGFnZW50LnN0YXR1cykudG9CZSgnYWN0aXZlJyk7XG4gICAgICBleHBlY3Qoc2F2ZVJlc3VsdC5zYXZlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChjb29yZFJlc3VsdC5vcmNoZXN0cmF0ZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5+iIEdSRUVOOiBCYXNpYyBpbnRlZ3JhdGlvbiB3b3JrcycpO1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ1JFRkFDVE9SOiBJbnRlZ3JhdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHdpdGggZXZlbnQtZHJpdmVuIGFyY2hpdGVjdHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50QnVzID0gbmV3IE1hcCgpO1xuICAgICAgXG4gICAgICBjb25zdCBtb2NrT3B0aW1pemVkU3lzdGVtID0ge1xuICAgICAgICBuZXVyYWxNYW5hZ2VyOiB7XG4gICAgICAgICAgc3Bhd25BZ2VudDogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoY29uZmlnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhZ2VudCA9IHtcbiAgICAgICAgICAgICAgaWQ6ICdvcHRpbWl6ZWQtYWdlbnQtJyArIERhdGUubm93KCksXG4gICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgICAgICAgc3Bhd25UaW1lOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFbWl0IGV2ZW50IGZvciBvdGhlciBjb21wb25lbnRzXG4gICAgICAgICAgICBldmVudEJ1cy5zZXQoJ2FnZW50LXNwYXduZWQnLCB7IGFnZW50LCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWdlbnQ7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHBlcnNpc3RlbmNlOiB7XG4gICAgICAgICAgc2F2ZVN0YXRlOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jIChhZ2VudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICBzYXZlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgYWdlbnRJZDogYWdlbnQuaWQsXG4gICAgICAgICAgICAgIHNhdmVUaW1lOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBldmVudEJ1cy5zZXQoJ2FnZW50LXNhdmVkJywgeyBhZ2VudCwgcmVzdWx0LCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBjb29yZGluYXRpb246IHtcbiAgICAgICAgICBvcmNoZXN0cmF0ZTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoYWdlbnRJZHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgb3JjaGVzdHJhdGVkOiB0cnVlLFxuICAgICAgICAgICAgICBhZ2VudHM6IGFnZW50SWRzLFxuICAgICAgICAgICAgICBzdHJhdGVneTogJ2V2ZW50LWRyaXZlbicsXG4gICAgICAgICAgICAgIG9yY2hlc3RyYXRpb25UaW1lOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBldmVudEJ1cy5zZXQoJ2FnZW50cy1vcmNoZXN0cmF0ZWQnLCB7IGFnZW50SWRzLCByZXN1bHQsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8vIEV2ZW50IG1vbml0b3JpbmdcbiAgICAgICAgZ2V0RXZlbnRIaXN0b3J5OiAoKSA9PiBBcnJheS5mcm9tKGV2ZW50QnVzLmVudHJpZXMoKSlcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZHVyYXRpb24gfSA9IGF3YWl0IHBlcmZvcm1hbmNlVGVzdFV0aWxzLm1lYXN1cmVBc3luY09wZXJhdGlvbihcbiAgICAgICAgJ29wdGltaXplZC1pbnRlZ3JhdGlvbicsXG4gICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBhZ2VudCA9IGF3YWl0IG1vY2tPcHRpbWl6ZWRTeXN0ZW0ubmV1cmFsTWFuYWdlci5zcGF3bkFnZW50KHsgXG4gICAgICAgICAgICB0eXBlOiAnbWxwJyxcbiAgICAgICAgICAgIGFyY2hpdGVjdHVyZTogWzEwLCA1LCAxXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHNhdmVSZXN1bHQgPSBhd2FpdCBtb2NrT3B0aW1pemVkU3lzdGVtLnBlcnNpc3RlbmNlLnNhdmVTdGF0ZShhZ2VudCk7XG4gICAgICAgICAgY29uc3QgY29vcmRSZXN1bHQgPSBhd2FpdCBtb2NrT3B0aW1pemVkU3lzdGVtLmNvb3JkaW5hdGlvbi5vcmNoZXN0cmF0ZShbYWdlbnQuaWRdKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4geyBhZ2VudCwgc2F2ZVJlc3VsdCwgY29vcmRSZXN1bHQgfTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHBlcmZvcm1hbmNlIGFuZCBldmVudC1kcml2ZW4gYmVoYXZpb3JcbiAgICAgIGV4cGVjdChkdXJhdGlvbikudG9CZUxlc3NUaGFuKFBFUkZPUk1BTkNFX1RIUkVTSE9MRFMuQ09PUkRJTkFUSU9OX09WRVJIRUFEICogMyk7IC8vIEFsbG93IGZvciAzIG9wZXJhdGlvbnNcbiAgICAgIFxuICAgICAgY29uc3QgZXZlbnRIaXN0b3J5ID0gbW9ja09wdGltaXplZFN5c3RlbS5nZXRFdmVudEhpc3RvcnkoKTtcbiAgICAgIGV4cGVjdChldmVudEhpc3RvcnkpLnRvSGF2ZUxlbmd0aCgzKTsgLy8gMyBldmVudHMgZW1pdHRlZFxuICAgICAgZXhwZWN0KGV2ZW50SGlzdG9yeS5tYXAoKFtldmVudF0pID0+IGV2ZW50KSkudG9FcXVhbChbXG4gICAgICAgICdhZ2VudC1zcGF3bmVkJyxcbiAgICAgICAgJ2FnZW50LXNhdmVkJywgXG4gICAgICAgICdhZ2VudHMtb3JjaGVzdHJhdGVkJ1xuICAgICAgXSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFJFRkFDVE9SOiBJbnRlZ3JhdGlvbiBvcHRpbWl6ZWQgd2l0aCBldmVudC1kcml2ZW4gYXJjaGl0ZWN0dXJlJyk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ1RERCBCZXN0IFByYWN0aWNlcyBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBmb2xsb3cgVEREIGN5Y2xlIHRpbWluZyByZWNvbW1lbmRhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZGRDeWNsZVRpbWVzID0ge1xuICAgICAgICByZWQ6IDMwLCAgICAvLyAzMG1zIHRvIHdyaXRlIGZhaWxpbmcgdGVzdFxuICAgICAgICBncmVlbjogNjAsICAvLyA2MG1zIHRvIGltcGxlbWVudCBtaW5pbWFsIHNvbHV0aW9uXG4gICAgICAgIHJlZmFjdG9yOiA5MCAvLyA5MG1zIHRvIG9wdGltaXplIGltcGxlbWVudGF0aW9uXG4gICAgICB9O1xuICAgICAgXG4gICAgICBPYmplY3QuZW50cmllcyh0ZGRDeWNsZVRpbWVzKS5mb3JFYWNoKChbcGhhc2UsIGV4cGVjdGVkVGltZV0pID0+IHtcbiAgICAgICAgZXhwZWN0KGV4cGVjdGVkVGltZSkudG9CZUxlc3NUaGFuKDEwMCk7IC8vIEVhY2ggcGhhc2Ugc2hvdWxkIGJlIGZhc3RcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBUREQgJHtwaGFzZS50b1VwcGVyQ2FzZSgpfSBwaGFzZSB0aW1pbmc6ICR7ZXhwZWN0ZWRUaW1lfW1zIChyZWNvbW1lbmRlZCA8MTAwbXMpYCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICB0ZXN0KCdzaG91bGQgdmFsaWRhdGUgdGVzdCBjb3ZlcmFnZSByZXF1aXJlbWVudHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb3ZlcmFnZVJlcXVpcmVtZW50cyA9IHtcbiAgICAgICAgc3RhdGVtZW50czogOTAsXG4gICAgICAgIGJyYW5jaGVzOiA5MCxcbiAgICAgICAgZnVuY3Rpb25zOiA5MCxcbiAgICAgICAgbGluZXM6IDkwXG4gICAgICB9O1xuICAgICAgXG4gICAgICBPYmplY3QuZW50cmllcyhjb3ZlcmFnZVJlcXVpcmVtZW50cykuZm9yRWFjaCgoW21ldHJpYywgdGhyZXNob2xkXSkgPT4ge1xuICAgICAgICBleHBlY3QodGhyZXNob2xkKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDkwKTtcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBDb3ZlcmFnZSByZXF1aXJlbWVudDogJHttZXRyaWN9ID49ICR7dGhyZXNob2xkfSVgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ3Nob3VsZCBlbmZvcmNlIHBlcmZvcm1hbmNlIHRlc3RpbmcgaW4gVEREIGN5Y2xlJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGVyZm9ybWFuY2VSZXF1aXJlbWVudHMgPSBbXG4gICAgICAgICdBR0VOVF9TUEFXTl9USU1FJyxcbiAgICAgICAgJ0lORkVSRU5DRV9USU1FJywgXG4gICAgICAgICdQRVJTSVNURU5DRV9TQVZFJyxcbiAgICAgICAgJ1BFUlNJU1RFTkNFX0xPQUQnLFxuICAgICAgICAnQ09PUkRJTkFUSU9OX09WRVJIRUFEJ1xuICAgICAgXTtcbiAgICAgIFxuICAgICAgcGVyZm9ybWFuY2VSZXF1aXJlbWVudHMuZm9yRWFjaChyZXF1aXJlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IFBFUkZPUk1BTkNFX1RIUkVTSE9MRFNbcmVxdWlyZW1lbnQgYXMga2V5b2YgdHlwZW9mIFBFUkZPUk1BTkNFX1RIUkVTSE9MRFNdO1xuICAgICAgICBleHBlY3QodGhyZXNob2xkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICBleHBlY3QodGhyZXNob2xkKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgUGVyZm9ybWFuY2UgcmVxdWlyZW1lbnQ6ICR7cmVxdWlyZW1lbnR9IDwgJHt0aHJlc2hvbGR9bXNgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vLyBUREQgV29ya2Zsb3cgQ29vcmRpbmF0aW9uIEhvb2tcbmFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMCkpO1xuICBjb25zdCBob29rUmVzdWx0ID0gYXdhaXQgY29vcmRpbmF0aW9uVGVzdFV0aWxzLm1vY2tIb29rc0V4ZWN1dGlvbihcbiAgICAncG9zdC1lZGl0JyxcbiAgICB7IFxuICAgICAgZmlsZTogJ3RkZC13b3JrZmxvdy10ZW1wbGF0ZXMudGVzdC50cycsXG4gICAgICBvcGVyYXRpb246ICd0ZGRfdGVtcGxhdGVfZXhlY3V0aW9uJyxcbiAgICAgIHBlcmZvcm1hbmNlOiAndGRkX2N5Y2xlc19jb21wbGV0ZWQnLFxuICAgICAgcGhhc2U6ICdyZWRfZ3JlZW5fcmVmYWN0b3InXG4gICAgfVxuICApO1xuICBleHBlY3QoaG9va1Jlc3VsdC5leGVjdXRlZCkudG9CZSh0cnVlKTtcbn0pOyJdLCJ2ZXJzaW9uIjozfQ==