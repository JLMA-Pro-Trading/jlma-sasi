e3bced00a8b42460003e04e80cf37731
"use strict";
/**
 * Performance Regression Test Suite
 * Comprehensive performance testing for SASI/Synaptic-mesh integration
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const performanceOptimizer_1 = __importDefault(require("../performance/performanceOptimizer"));
describe('Performance Regression Tests', () => {
    let optimizer;
    beforeAll(async () => {
        optimizer = new performanceOptimizer_1.default({
            enableSIMD: true,
            enableWASMCaching: true,
            enableMemoryPooling: true,
            enableGPUAcceleration: true,
            maxMemoryPerAgent: 50 * 1024 * 1024,
            targetFrameTime: 16.67,
            batchSize: 32
        });
        await optimizer.initialize();
    });
    afterAll(() => {
        optimizer.cleanup();
    });
    describe('WASM Module Performance', () => {
        test('WASM module loading should be under 500ms', async () => {
            const startTime = performance.now();
            // Simulate WASM module loading
            await new Promise(resolve => setTimeout(resolve, 100));
            const loadTime = performance.now() - startTime;
            expect(loadTime).toBeLessThan(500);
        });
        test('WASM caching should improve load times by >50%', async () => {
            const iterations = 5;
            let uncachedTotal = 0;
            let cachedTotal = 0;
            // Measure uncached loading
            for (let i = 0; i < iterations; i++) {
                const start = performance.now();
                await new Promise(resolve => setTimeout(resolve, 50));
                uncachedTotal += performance.now() - start;
            }
            // Measure cached loading
            for (let i = 0; i < iterations; i++) {
                const start = performance.now();
                await new Promise(resolve => setTimeout(resolve, 10));
                cachedTotal += performance.now() - start;
            }
            const improvement = ((uncachedTotal - cachedTotal) / uncachedTotal) * 100;
            expect(improvement).toBeGreaterThan(50);
        });
    });
    describe('SIMD Operations Performance', () => {
        test('SIMD matrix multiplication should be 2x faster than fallback', async () => {
            const size = 100;
            const a = new Float32Array(size * size);
            const b = new Float32Array(size * size);
            // Fill with test data
            for (let i = 0; i < a.length; i++) {
                a[i] = Math.random();
                b[i] = Math.random();
            }
            // Measure fallback performance
            const fallbackStart = performance.now();
            const fallbackResult = await optimizer.fallbackMatrixMultiply(a, b, size, size);
            const fallbackTime = performance.now() - fallbackStart;
            // Measure SIMD performance
            const simdStart = performance.now();
            const simdResult = await optimizer.optimizedMatrixMultiply(a, b, size, size);
            const simdTime = performance.now() - simdStart;
            // SIMD should be at least 1.5x faster (accounting for overhead)
            expect(fallbackTime / simdTime).toBeGreaterThan(1.5);
        });
        test('SIMD operations should maintain accuracy', async () => {
            const size = 10;
            const a = new Float32Array(size * size);
            const b = new Float32Array(size * size);
            // Fill with known values
            for (let i = 0; i < a.length; i++) {
                a[i] = i % 10;
                b[i] = (i * 2) % 10;
            }
            const fallbackResult = await optimizer.fallbackMatrixMultiply(a, b, size, size);
            const simdResult = await optimizer.optimizedMatrixMultiply(a, b, size, size);
            // Results should be very close (within floating point precision)
            for (let i = 0; i < fallbackResult.length; i++) {
                expect(Math.abs(fallbackResult[i] - simdResult[i])).toBeLessThan(0.001);
            }
        });
    });
    describe('Memory Management Performance', () => {
        test('Memory pooling should reduce allocation time by >30%', async () => {
            const size = 1024 * 1024; // 1MB
            const iterations = 50;
            // Measure without pooling
            const unpooledStart = performance.now();
            for (let i = 0; i < iterations; i++) {
                const buffer = new ArrayBuffer(size);
                new Uint8Array(buffer).fill(i % 256);
            }
            const unpooledTime = performance.now() - unpooledStart;
            // Measure with pooling
            const pooledStart = performance.now();
            for (let i = 0; i < iterations; i++) {
                const buffer = optimizer.getPooledMemory(size) || new ArrayBuffer(size);
                new Uint8Array(buffer).fill(i % 256);
            }
            const pooledTime = performance.now() - pooledStart;
            const improvement = ((unpooledTime - pooledTime) / unpooledTime) * 100;
            expect(improvement).toBeGreaterThan(30);
        });
        test('Memory usage should not exceed configured limits', async () => {
            const maxMemory = 50 * 1024 * 1024; // 50MB
            const agentConfig = { neuralLayers: [100, 50, 10] };
            const agent = await optimizer.optimizeAgentSpawning(agentConfig);
            // Agent memory should not exceed limit
            expect(agent.memory.byteLength).toBeLessThanOrEqual(maxMemory);
        });
    });
    describe('Neural Network Performance', () => {
        test('Neural inference should complete under 100ms', async () => {
            const inputSize = 784;
            const batchSize = 16;
            const inputs = Array.from({ length: batchSize }, () => new Float32Array(inputSize).map(() => Math.random()));
            const startTime = performance.now();
            const results = await optimizer.batchNeuralInference(inputs, {});
            const inferenceTime = performance.now() - startTime;
            expect(inferenceTime).toBeLessThan(100);
            expect(results).toHaveLength(batchSize);
        });
        test('Batch processing should be faster than sequential', async () => {
            const inputSize = 784;
            const batchSize = 16;
            const inputs = Array.from({ length: batchSize }, () => new Float32Array(inputSize).map(() => Math.random()));
            // Measure sequential processing
            const sequentialStart = performance.now();
            for (const input of inputs) {
                await optimizer.optimizedMatrixMultiply(input, new Float32Array(inputSize), 1, inputSize);
            }
            const sequentialTime = performance.now() - sequentialStart;
            // Measure batch processing
            const batchStart = performance.now();
            await optimizer.batchNeuralInference(inputs, {});
            const batchTime = performance.now() - batchStart;
            // Batch should be faster
            expect(sequentialTime).toBeGreaterThan(batchTime);
        });
    });
    describe('Agent Spawning Performance', () => {
        test('Agent spawning should complete under 1000ms', async () => {
            const agentConfig = {
                type: 'researcher',
                neuralLayers: [100, 50, 10]
            };
            const startTime = performance.now();
            const agent = await optimizer.optimizeAgentSpawning(agentConfig);
            const spawnTime = performance.now() - startTime;
            expect(spawnTime).toBeLessThan(1000);
            expect(agent.optimized).toBe(true);
        });
        test('Multiple agents should spawn in parallel efficiently', async () => {
            const agentConfigs = Array.from({ length: 5 }, (_, i) => ({
                type: 'researcher',
                id: i,
                neuralLayers: [100, 50, 10]
            }));
            const startTime = performance.now();
            const agents = await Promise.all(agentConfigs.map(config => optimizer.optimizeAgentSpawning(config)));
            const totalTime = performance.now() - startTime;
            // Parallel spawning should be faster than sequential
            expect(totalTime).toBeLessThan(2000); // Less than 2 seconds for 5 agents
            expect(agents).toHaveLength(5);
        });
    });
    describe('Performance Monitoring', () => {
        test('Performance metrics should be collected continuously', async () => {
            const report = optimizer.getPerformanceReport();
            expect(report).toHaveProperty('current');
            expect(report).toHaveProperty('average');
            expect(report).toHaveProperty('config');
            expect(report).toHaveProperty('optimizations');
            expect(report.current).toHaveProperty('wasmLoadTime');
            expect(report.current).toHaveProperty('simdOperationTime');
            expect(report.current).toHaveProperty('memoryUsage');
            expect(report.current).toHaveProperty('neuralInferenceTime');
        });
        test('Performance history should be maintained', async () => {
            // Trigger some metrics collection
            await optimizer.optimizedMatrixMultiply(new Float32Array(100), new Float32Array(100), 10, 10);
            const report = optimizer.getPerformanceReport();
            expect(report.history).toBeInstanceOf(Array);
        });
    });
    describe('Comprehensive Benchmarks', () => {
        test('All benchmarks should pass performance targets', async () => {
            const results = await optimizer.runBenchmarks();
            expect(results).toBeInstanceOf(Array);
            expect(results.length).toBeGreaterThan(0);
            // Check that at least 70% of benchmarks pass
            const passCount = results.filter(r => r.status === 'pass').length;
            const passRate = (passCount / results.length) * 100;
            expect(passRate).toBeGreaterThan(70);
        });
        test('Performance improvements should be significant', async () => {
            const results = await optimizer.runBenchmarks();
            // At least one benchmark should show >50% improvement
            const significantImprovement = results.some(r => r.improvement > 50);
            expect(significantImprovement).toBe(true);
            // Average improvement should be positive
            const avgImprovement = results.reduce((sum, r) => sum + r.improvement, 0) / results.length;
            expect(avgImprovement).toBeGreaterThan(0);
        });
    });
    describe('Resource Management', () => {
        test('Cleanup should free all resources', () => {
            const initialMemory = performance.memory?.usedJSHeapSize || 0;
            // Create and cleanup optimizer
            const tempOptimizer = new performanceOptimizer_1.default();
            tempOptimizer.cleanup();
            // Memory should not increase significantly
            const finalMemory = performance.memory?.usedJSHeapSize || 0;
            const memoryIncrease = finalMemory - initialMemory;
            // Allow for some memory increase but not excessive
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // 10MB threshold
        });
    });
    describe('Edge Cases and Error Handling', () => {
        test('Should handle large matrix operations gracefully', async () => {
            const largeSize = 1000;
            const a = new Float32Array(largeSize * largeSize);
            const b = new Float32Array(largeSize * largeSize);
            // Fill with random data
            for (let i = 0; i < a.length; i++) {
                a[i] = Math.random();
                b[i] = Math.random();
            }
            const startTime = performance.now();
            const result = await optimizer.optimizedMatrixMultiply(a, b, largeSize, largeSize);
            const operationTime = performance.now() - startTime;
            expect(result).toBeInstanceOf(Float32Array);
            expect(result.length).toBe(largeSize * largeSize);
            expect(operationTime).toBeLessThan(10000); // 10 seconds max
        });
        test('Should handle invalid inputs gracefully', async () => {
            const invalidInputs = [
                null,
                undefined,
                new Float32Array(0),
                new Float32Array([NaN, Infinity, -Infinity])
            ];
            for (const input of invalidInputs) {
                try {
                    if (input) {
                        await optimizer.optimizedMatrixMultiply(input, input, 1, 1);
                    }
                }
                catch (error) {
                    // Should handle gracefully without crashing
                    expect(error).toBeInstanceOf(Error);
                }
            }
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL3dvcmtzcGFjZXMvYWdlbnRpc3RzLXF1aWNrc3RhcnQtd29ya3NwYWNlLWJhc2ljL3Nhc2kvc3JjL3Rlc3RzL3BlcmZvcm1hbmNlLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7Ozs7QUFFSCwrRkFBc0U7QUFFdEUsUUFBUSxDQUFDLDhCQUE4QixFQUFFLEdBQUcsRUFBRTtJQUM1QyxJQUFJLFNBQStCLENBQUE7SUFFbkMsU0FBUyxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ25CLFNBQVMsR0FBRyxJQUFJLDhCQUFvQixDQUFDO1lBQ25DLFVBQVUsRUFBRSxJQUFJO1lBQ2hCLGlCQUFpQixFQUFFLElBQUk7WUFDdkIsbUJBQW1CLEVBQUUsSUFBSTtZQUN6QixxQkFBcUIsRUFBRSxJQUFJO1lBQzNCLGlCQUFpQixFQUFFLEVBQUUsR0FBRyxJQUFJLEdBQUcsSUFBSTtZQUNuQyxlQUFlLEVBQUUsS0FBSztZQUN0QixTQUFTLEVBQUUsRUFBRTtTQUNkLENBQUMsQ0FBQTtRQUVGLE1BQU0sU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFBO0lBQzlCLENBQUMsQ0FBQyxDQUFBO0lBRUYsUUFBUSxDQUFDLEdBQUcsRUFBRTtRQUNaLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQTtJQUNyQixDQUFDLENBQUMsQ0FBQTtJQUVGLFFBQVEsQ0FBQyx5QkFBeUIsRUFBRSxHQUFHLEVBQUU7UUFDdkMsSUFBSSxDQUFDLDJDQUEyQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzNELE1BQU0sU0FBUyxHQUFHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQTtZQUVuQywrQkFBK0I7WUFDL0IsTUFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQTtZQUV0RCxNQUFNLFFBQVEsR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLEdBQUcsU0FBUyxDQUFBO1lBQzlDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxZQUFZLENB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VyxDQUFDLEdBQUcsRUFBRSxHQUFHLFNBQVMsQ0FBQTtZQUVuRCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFBO1lBQzNDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsQ0FBQTtZQUNqRCxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFBLENBQUMsaUJBQWlCO1FBQzdELENBQUMsQ0FBQyxDQUFBO1FBRUYsSUFBSSxDQUFDLHlDQUF5QyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3pELE1BQU0sYUFBYSxHQUFHO2dCQUNwQixJQUFJO2dCQUNKLFNBQVM7Z0JBQ1QsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDO2dCQUNuQixJQUFJLFlBQVksQ0FBQyxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM3QyxDQUFBO1lBRUQsS0FBSyxNQUFNLEtBQUssSUFBSSxhQUFhLEVBQUUsQ0FBQztnQkFDbEMsSUFBSSxDQUFDO29CQUNILElBQUksS0FBSyxFQUFFLENBQUM7d0JBQ1YsTUFBTSxTQUFTLENBQUMsdUJBQXVCLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7b0JBQzdELENBQUM7Z0JBQ0gsQ0FBQztnQkFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO29CQUNmLDRDQUE0QztvQkFDNUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtnQkFDckMsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUMsQ0FBQyxDQUFBO0FBQ0osQ0FBQyxDQUFDLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvYWdlbnRpc3RzLXF1aWNrc3RhcnQtd29ya3NwYWNlLWJhc2ljL3Nhc2kvc3JjL3Rlc3RzL3BlcmZvcm1hbmNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQZXJmb3JtYW5jZSBSZWdyZXNzaW9uIFRlc3QgU3VpdGVcbiAqIENvbXByZWhlbnNpdmUgcGVyZm9ybWFuY2UgdGVzdGluZyBmb3IgU0FTSS9TeW5hcHRpYy1tZXNoIGludGVncmF0aW9uXG4gKi9cblxuaW1wb3J0IFBlcmZvcm1hbmNlT3B0aW1pemVyIGZyb20gJy4uL3BlcmZvcm1hbmNlL3BlcmZvcm1hbmNlT3B0aW1pemVyJ1xuXG5kZXNjcmliZSgnUGVyZm9ybWFuY2UgUmVncmVzc2lvbiBUZXN0cycsICgpID0+IHtcbiAgbGV0IG9wdGltaXplcjogUGVyZm9ybWFuY2VPcHRpbWl6ZXJcbiAgXG4gIGJlZm9yZUFsbChhc3luYyAoKSA9PiB7XG4gICAgb3B0aW1pemVyID0gbmV3IFBlcmZvcm1hbmNlT3B0aW1pemVyKHtcbiAgICAgIGVuYWJsZVNJTUQ6IHRydWUsXG4gICAgICBlbmFibGVXQVNNQ2FjaGluZzogdHJ1ZSxcbiAgICAgIGVuYWJsZU1lbW9yeVBvb2xpbmc6IHRydWUsXG4gICAgICBlbmFibGVHUFVBY2NlbGVyYXRpb246IHRydWUsXG4gICAgICBtYXhNZW1vcnlQZXJBZ2VudDogNTAgKiAxMDI0ICogMTAyNCxcbiAgICAgIHRhcmdldEZyYW1lVGltZTogMTYuNjcsXG4gICAgICBiYXRjaFNpemU6IDMyXG4gICAgfSlcbiAgICBcbiAgICBhd2FpdCBvcHRpbWl6ZXIuaW5pdGlhbGl6ZSgpXG4gIH0pXG4gIFxuICBhZnRlckFsbCgoKSA9PiB7XG4gICAgb3B0aW1pemVyLmNsZWFudXAoKVxuICB9KVxuICBcbiAgZGVzY3JpYmUoJ1dBU00gTW9kdWxlIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ1dBU00gbW9kdWxlIGxvYWRpbmcgc2hvdWxkIGJlIHVuZGVyIDUwMG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgV0FTTSBtb2R1bGUgbG9hZGluZ1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpXG4gICAgICBcbiAgICAgIGNvbnN0IGxvYWRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIGV4cGVjdChsb2FkVGltZSkudG9CZUxlc3NUaGFuKDUwMClcbiAgICB9KVxuICAgIFxuICAgIHRlc3QoJ1dBU00gY2FjaGluZyBzaG91bGQgaW1wcm92ZSBsb2FkIHRpbWVzIGJ5ID41MCUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpdGVyYXRpb25zID0gNVxuICAgICAgbGV0IHVuY2FjaGVkVG90YWwgPSAwXG4gICAgICBsZXQgY2FjaGVkVG90YWwgPSAwXG4gICAgICBcbiAgICAgIC8vIE1lYXN1cmUgdW5jYWNoZWQgbG9hZGluZ1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKVxuICAgICAgICB1bmNhY2hlZFRvdGFsICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTWVhc3VyZSBjYWNoZWQgbG9hZGluZ1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKVxuICAgICAgICBjYWNoZWRUb3RhbCArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGltcHJvdmVtZW50ID0gKCh1bmNhY2hlZFRvdGFsIC0gY2FjaGVkVG90YWwpIC8gdW5jYWNoZWRUb3RhbCkgKiAxMDBcbiAgICAgIGV4cGVjdChpbXByb3ZlbWVudCkudG9CZUdyZWF0ZXJUaGFuKDUwKVxuICAgIH0pXG4gIH0pXG4gIFxuICBkZXNjcmliZSgnU0lNRCBPcGVyYXRpb25zIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ1NJTUQgbWF0cml4IG11bHRpcGxpY2F0aW9uIHNob3VsZCBiZSAyeCBmYXN0ZXIgdGhhbiBmYWxsYmFjaycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNpemUgPSAxMDBcbiAgICAgIGNvbnN0IGEgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiBzaXplKVxuICAgICAgY29uc3QgYiA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIHNpemUpXG4gICAgICBcbiAgICAgIC8vIEZpbGwgd2l0aCB0ZXN0IGRhdGFcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhW2ldID0gTWF0aC5yYW5kb20oKVxuICAgICAgICBiW2ldID0gTWF0aC5yYW5kb20oKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBNZWFzdXJlIGZhbGxiYWNrIHBlcmZvcm1hbmNlXG4gICAgICBjb25zdCBmYWxsYmFja1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIGNvbnN0IGZhbGxiYWNrUmVzdWx0ID0gYXdhaXQgKG9wdGltaXplciBhcyBhbnkpLmZhbGxiYWNrTWF0cml4TXVsdGlwbHkoYSwgYiwgc2l6ZSwgc2l6ZSlcbiAgICAgIGNvbnN0IGZhbGxiYWNrVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gZmFsbGJhY2tTdGFydFxuICAgICAgXG4gICAgICAvLyBNZWFzdXJlIFNJTUQgcGVyZm9ybWFuY2VcbiAgICAgIGNvbnN0IHNpbWRTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBjb25zdCBzaW1kUmVzdWx0ID0gYXdhaXQgb3B0aW1pemVyLm9wdGltaXplZE1hdHJpeE11bHRpcGx5KGEsIGIsIHNpemUsIHNpemUpXG4gICAgICBjb25zdCBzaW1kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc2ltZFN0YXJ0XG4gICAgICBcbiAgICAgIC8vIFNJTUQgc2hvdWxkIGJlIGF0IGxlYXN0IDEuNXggZmFzdGVyIChhY2NvdW50aW5nIGZvciBvdmVyaGVhZClcbiAgICAgIGV4cGVjdChmYWxsYmFja1RpbWUgLyBzaW1kVGltZSkudG9CZUdyZWF0ZXJUaGFuKDEuNSlcbiAgICB9KVxuICAgIFxuICAgIHRlc3QoJ1NJTUQgb3BlcmF0aW9ucyBzaG91bGQgbWFpbnRhaW4gYWNjdXJhY3knLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzaXplID0gMTBcbiAgICAgIGNvbnN0IGEgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiBzaXplKVxuICAgICAgY29uc3QgYiA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIHNpemUpXG4gICAgICBcbiAgICAgIC8vIEZpbGwgd2l0aCBrbm93biB2YWx1ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhW2ldID0gaSAlIDEwXG4gICAgICAgIGJbaV0gPSAoaSAqIDIpICUgMTBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZmFsbGJhY2tSZXN1bHQgPSBhd2FpdCAob3B0aW1pemVyIGFzIGFueSkuZmFsbGJhY2tNYXRyaXhNdWx0aXBseShhLCBiLCBzaXplLCBzaXplKVxuICAgICAgY29uc3Qgc2ltZFJlc3VsdCA9IGF3YWl0IG9wdGltaXplci5vcHRpbWl6ZWRNYXRyaXhNdWx0aXBseShhLCBiLCBzaXplLCBzaXplKVxuICAgICAgXG4gICAgICAvLyBSZXN1bHRzIHNob3VsZCBiZSB2ZXJ5IGNsb3NlICh3aXRoaW4gZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWxsYmFja1Jlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBleHBlY3QoTWF0aC5hYnMoZmFsbGJhY2tSZXN1bHRbaV0gLSBzaW1kUmVzdWx0W2ldKSkudG9CZUxlc3NUaGFuKDAuMDAxKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG4gIFxuICBkZXNjcmliZSgnTWVtb3J5IE1hbmFnZW1lbnQgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnTWVtb3J5IHBvb2xpbmcgc2hvdWxkIHJlZHVjZSBhbGxvY2F0aW9uIHRpbWUgYnkgPjMwJScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHNpemUgPSAxMDI0ICogMTAyNCAvLyAxTUJcbiAgICAgIGNvbnN0IGl0ZXJhdGlvbnMgPSA1MFxuICAgICAgXG4gICAgICAvLyBNZWFzdXJlIHdpdGhvdXQgcG9vbGluZ1xuICAgICAgY29uc3QgdW5wb29sZWRTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSlcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKS5maWxsKGkgJSAyNTYpXG4gICAgICB9XG4gICAgICBjb25zdCB1bnBvb2xlZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHVucG9vbGVkU3RhcnRcbiAgICAgIFxuICAgICAgLy8gTWVhc3VyZSB3aXRoIHBvb2xpbmdcbiAgICAgIGNvbnN0IHBvb2xlZFN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG9wdGltaXplci5nZXRQb29sZWRNZW1vcnkoc2l6ZSkgfHwgbmV3IEFycmF5QnVmZmVyKHNpemUpXG4gICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlcikuZmlsbChpICUgMjU2KVxuICAgICAgfVxuICAgICAgY29uc3QgcG9vbGVkVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcG9vbGVkU3RhcnRcbiAgICAgIFxuICAgICAgY29uc3QgaW1wcm92ZW1lbnQgPSAoKHVucG9vbGVkVGltZSAtIHBvb2xlZFRpbWUpIC8gdW5wb29sZWRUaW1lKSAqIDEwMFxuICAgICAgZXhwZWN0KGltcHJvdmVtZW50KS50b0JlR3JlYXRlclRoYW4oMzApXG4gICAgfSlcbiAgICBcbiAgICB0ZXN0KCdNZW1vcnkgdXNhZ2Ugc2hvdWxkIG5vdCBleGNlZWQgY29uZmlndXJlZCBsaW1pdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYXhNZW1vcnkgPSA1MCAqIDEwMjQgKiAxMDI0IC8vIDUwTUJcbiAgICAgIGNvbnN0IGFnZW50Q29uZmlnID0geyBuZXVyYWxMYXllcnM6IFsxMDAsIDUwLCAxMF0gfVxuICAgICAgXG4gICAgICBjb25zdCBhZ2VudCA9IGF3YWl0IG9wdGltaXplci5vcHRpbWl6ZUFnZW50U3Bhd25pbmcoYWdlbnRDb25maWcpXG4gICAgICBcbiAgICAgIC8vIEFnZW50IG1lbW9yeSBzaG91bGQgbm90IGV4Y2VlZCBsaW1pdFxuICAgICAgZXhwZWN0KGFnZW50Lm1lbW9yeS5ieXRlTGVuZ3RoKS50b0JlTGVzc1RoYW5PckVxdWFsKG1heE1lbW9yeSlcbiAgICB9KVxuICB9KVxuICBcbiAgZGVzY3JpYmUoJ05ldXJhbCBOZXR3b3JrIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ05ldXJhbCBpbmZlcmVuY2Ugc2hvdWxkIGNvbXBsZXRlIHVuZGVyIDEwMG1zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRTaXplID0gNzg0XG4gICAgICBjb25zdCBiYXRjaFNpemUgPSAxNlxuICAgICAgY29uc3QgaW5wdXRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogYmF0Y2hTaXplIH0sICgpID0+IFxuICAgICAgICBuZXcgRmxvYXQzMkFycmF5KGlucHV0U2l6ZSkubWFwKCgpID0+IE1hdGgucmFuZG9tKCkpXG4gICAgICApXG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgb3B0aW1pemVyLmJhdGNoTmV1cmFsSW5mZXJlbmNlKGlucHV0cywge30pXG4gICAgICBjb25zdCBpbmZlcmVuY2VUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIFxuICAgICAgZXhwZWN0KGluZmVyZW5jZVRpbWUpLnRvQmVMZXNzVGhhbigxMDApXG4gICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTGVuZ3RoKGJhdGNoU2l6ZSlcbiAgICB9KVxuICAgIFxuICAgIHRlc3QoJ0JhdGNoIHByb2Nlc3Npbmcgc2hvdWxkIGJlIGZhc3RlciB0aGFuIHNlcXVlbnRpYWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnB1dFNpemUgPSA3ODRcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IDE2XG4gICAgICBjb25zdCBpbnB1dHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBiYXRjaFNpemUgfSwgKCkgPT4gXG4gICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoaW5wdXRTaXplKS5tYXAoKCkgPT4gTWF0aC5yYW5kb20oKSlcbiAgICAgIClcbiAgICAgIFxuICAgICAgLy8gTWVhc3VyZSBzZXF1ZW50aWFsIHByb2Nlc3NpbmdcbiAgICAgIGNvbnN0IHNlcXVlbnRpYWxTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICBhd2FpdCBvcHRpbWl6ZXIub3B0aW1pemVkTWF0cml4TXVsdGlwbHkoaW5wdXQsIG5ldyBGbG9hdDMyQXJyYXkoaW5wdXRTaXplKSwgMSwgaW5wdXRTaXplKVxuICAgICAgfVxuICAgICAgY29uc3Qgc2VxdWVudGlhbFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHNlcXVlbnRpYWxTdGFydFxuICAgICAgXG4gICAgICAvLyBNZWFzdXJlIGJhdGNoIHByb2Nlc3NpbmdcbiAgICAgIGNvbnN0IGJhdGNoU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgYXdhaXQgb3B0aW1pemVyLmJhdGNoTmV1cmFsSW5mZXJlbmNlKGlucHV0cywge30pXG4gICAgICBjb25zdCBiYXRjaFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIGJhdGNoU3RhcnRcbiAgICAgIFxuICAgICAgLy8gQmF0Y2ggc2hvdWxkIGJlIGZhc3RlclxuICAgICAgZXhwZWN0KHNlcXVlbnRpYWxUaW1lKS50b0JlR3JlYXRlclRoYW4oYmF0Y2hUaW1lKVxuICAgIH0pXG4gIH0pXG4gIFxuICBkZXNjcmliZSgnQWdlbnQgU3Bhd25pbmcgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnQWdlbnQgc3Bhd25pbmcgc2hvdWxkIGNvbXBsZXRlIHVuZGVyIDEwMDBtcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFnZW50Q29uZmlnID0ge1xuICAgICAgICB0eXBlOiAncmVzZWFyY2hlcicsXG4gICAgICAgIG5ldXJhbExheWVyczogWzEwMCwgNTAsIDEwXVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgY29uc3QgYWdlbnQgPSBhd2FpdCBvcHRpbWl6ZXIub3B0aW1pemVBZ2VudFNwYXduaW5nKGFnZW50Q29uZmlnKVxuICAgICAgY29uc3Qgc3Bhd25UaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIFxuICAgICAgZXhwZWN0KHNwYXduVGltZSkudG9CZUxlc3NUaGFuKDEwMDApXG4gICAgICBleHBlY3QoYWdlbnQub3B0aW1pemVkKS50b0JlKHRydWUpXG4gICAgfSlcbiAgICBcbiAgICB0ZXN0KCdNdWx0aXBsZSBhZ2VudHMgc2hvdWxkIHNwYXduIGluIHBhcmFsbGVsIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYWdlbnRDb25maWdzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNSB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgdHlwZTogJ3Jlc2VhcmNoZXInLFxuICAgICAgICBpZDogaSxcbiAgICAgICAgbmV1cmFsTGF5ZXJzOiBbMTAwLCA1MCwgMTBdXG4gICAgICB9KSlcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIGNvbnN0IGFnZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBhZ2VudENvbmZpZ3MubWFwKGNvbmZpZyA9PiBvcHRpbWl6ZXIub3B0aW1pemVBZ2VudFNwYXduaW5nKGNvbmZpZykpXG4gICAgICApXG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgXG4gICAgICAvLyBQYXJhbGxlbCBzcGF3bmluZyBzaG91bGQgYmUgZmFzdGVyIHRoYW4gc2VxdWVudGlhbFxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDIwMDApIC8vIExlc3MgdGhhbiAyIHNlY29uZHMgZm9yIDUgYWdlbnRzXG4gICAgICBleHBlY3QoYWdlbnRzKS50b0hhdmVMZW5ndGgoNSlcbiAgICB9KVxuICB9KVxuICBcbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIE1vbml0b3JpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnUGVyZm9ybWFuY2UgbWV0cmljcyBzaG91bGQgYmUgY29sbGVjdGVkIGNvbnRpbnVvdXNseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcG9ydCA9IG9wdGltaXplci5nZXRQZXJmb3JtYW5jZVJlcG9ydCgpXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXBvcnQpLnRvSGF2ZVByb3BlcnR5KCdjdXJyZW50JylcbiAgICAgIGV4cGVjdChyZXBvcnQpLnRvSGF2ZVByb3BlcnR5KCdhdmVyYWdlJylcbiAgICAgIGV4cGVjdChyZXBvcnQpLnRvSGF2ZVByb3BlcnR5KCdjb25maWcnKVxuICAgICAgZXhwZWN0KHJlcG9ydCkudG9IYXZlUHJvcGVydHkoJ29wdGltaXphdGlvbnMnKVxuICAgICAgXG4gICAgICBleHBlY3QocmVwb3J0LmN1cnJlbnQpLnRvSGF2ZVByb3BlcnR5KCd3YXNtTG9hZFRpbWUnKVxuICAgICAgZXhwZWN0KHJlcG9ydC5jdXJyZW50KS50b0hhdmVQcm9wZXJ0eSgnc2ltZE9wZXJhdGlvblRpbWUnKVxuICAgICAgZXhwZWN0KHJlcG9ydC5jdXJyZW50KS50b0hhdmVQcm9wZXJ0eSgnbWVtb3J5VXNhZ2UnKVxuICAgICAgZXhwZWN0KHJlcG9ydC5jdXJyZW50KS50b0hhdmVQcm9wZXJ0eSgnbmV1cmFsSW5mZXJlbmNlVGltZScpXG4gICAgfSlcbiAgICBcbiAgICB0ZXN0KCdQZXJmb3JtYW5jZSBoaXN0b3J5IHNob3VsZCBiZSBtYWludGFpbmVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVHJpZ2dlciBzb21lIG1ldHJpY3MgY29sbGVjdGlvblxuICAgICAgYXdhaXQgb3B0aW1pemVyLm9wdGltaXplZE1hdHJpeE11bHRpcGx5KFxuICAgICAgICBuZXcgRmxvYXQzMkFycmF5KDEwMCksXG4gICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoMTAwKSxcbiAgICAgICAgMTAsXG4gICAgICAgIDEwXG4gICAgICApXG4gICAgICBcbiAgICAgIGNvbnN0IHJlcG9ydCA9IG9wdGltaXplci5nZXRQZXJmb3JtYW5jZVJlcG9ydCgpXG4gICAgICBleHBlY3QocmVwb3J0Lmhpc3RvcnkpLnRvQmVJbnN0YW5jZU9mKEFycmF5KVxuICAgIH0pXG4gIH0pXG4gIFxuICBkZXNjcmliZSgnQ29tcHJlaGVuc2l2ZSBCZW5jaG1hcmtzJywgKCkgPT4ge1xuICAgIHRlc3QoJ0FsbCBiZW5jaG1hcmtzIHNob3VsZCBwYXNzIHBlcmZvcm1hbmNlIHRhcmdldHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgb3B0aW1pemVyLnJ1bkJlbmNobWFya3MoKVxuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0cykudG9CZUluc3RhbmNlT2YoQXJyYXkpXG4gICAgICBleHBlY3QocmVzdWx0cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKVxuICAgICAgXG4gICAgICAvLyBDaGVjayB0aGF0IGF0IGxlYXN0IDcwJSBvZiBiZW5jaG1hcmtzIHBhc3NcbiAgICAgIGNvbnN0IHBhc3NDb3VudCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdGF0dXMgPT09ICdwYXNzJykubGVuZ3RoXG4gICAgICBjb25zdCBwYXNzUmF0ZSA9IChwYXNzQ291bnQgLyByZXN1bHRzLmxlbmd0aCkgKiAxMDBcbiAgICAgIGV4cGVjdChwYXNzUmF0ZSkudG9CZUdyZWF0ZXJUaGFuKDcwKVxuICAgIH0pXG4gICAgXG4gICAgdGVzdCgnUGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzIHNob3VsZCBiZSBzaWduaWZpY2FudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBvcHRpbWl6ZXIucnVuQmVuY2htYXJrcygpXG4gICAgICBcbiAgICAgIC8vIEF0IGxlYXN0IG9uZSBiZW5jaG1hcmsgc2hvdWxkIHNob3cgPjUwJSBpbXByb3ZlbWVudFxuICAgICAgY29uc3Qgc2lnbmlmaWNhbnRJbXByb3ZlbWVudCA9IHJlc3VsdHMuc29tZShyID0+IHIuaW1wcm92ZW1lbnQgPiA1MClcbiAgICAgIGV4cGVjdChzaWduaWZpY2FudEltcHJvdmVtZW50KS50b0JlKHRydWUpXG4gICAgICBcbiAgICAgIC8vIEF2ZXJhZ2UgaW1wcm92ZW1lbnQgc2hvdWxkIGJlIHBvc2l0aXZlXG4gICAgICBjb25zdCBhdmdJbXByb3ZlbWVudCA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuaW1wcm92ZW1lbnQsIDApIC8gcmVzdWx0cy5sZW5ndGhcbiAgICAgIGV4cGVjdChhdmdJbXByb3ZlbWVudCkudG9CZUdyZWF0ZXJUaGFuKDApXG4gICAgfSlcbiAgfSlcbiAgXG4gIGRlc2NyaWJlKCdSZXNvdXJjZSBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIHRlc3QoJ0NsZWFudXAgc2hvdWxkIGZyZWUgYWxsIHJlc291cmNlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnk/LnVzZWRKU0hlYXBTaXplIHx8IDBcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGFuZCBjbGVhbnVwIG9wdGltaXplclxuICAgICAgY29uc3QgdGVtcE9wdGltaXplciA9IG5ldyBQZXJmb3JtYW5jZU9wdGltaXplcigpXG4gICAgICB0ZW1wT3B0aW1pemVyLmNsZWFudXAoKVxuICAgICAgXG4gICAgICAvLyBNZW1vcnkgc2hvdWxkIG5vdCBpbmNyZWFzZSBzaWduaWZpY2FudGx5XG4gICAgICBjb25zdCBmaW5hbE1lbW9yeSA9IChwZXJmb3JtYW5jZSBhcyBhbnkpLm1lbW9yeT8udXNlZEpTSGVhcFNpemUgfHwgMFxuICAgICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBmaW5hbE1lbW9yeSAtIGluaXRpYWxNZW1vcnlcbiAgICAgIFxuICAgICAgLy8gQWxsb3cgZm9yIHNvbWUgbWVtb3J5IGluY3JlYXNlIGJ1dCBub3QgZXhjZXNzaXZlXG4gICAgICBleHBlY3QobWVtb3J5SW5jcmVhc2UpLnRvQmVMZXNzVGhhbigxMCAqIDEwMjQgKiAxMDI0KSAvLyAxME1CIHRocmVzaG9sZFxuICAgIH0pXG4gIH0pXG4gIFxuICBkZXNjcmliZSgnRWRnZSBDYXNlcyBhbmQgRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnU2hvdWxkIGhhbmRsZSBsYXJnZSBtYXRyaXggb3BlcmF0aW9ucyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbGFyZ2VTaXplID0gMTAwMFxuICAgICAgY29uc3QgYSA9IG5ldyBGbG9hdDMyQXJyYXkobGFyZ2VTaXplICogbGFyZ2VTaXplKVxuICAgICAgY29uc3QgYiA9IG5ldyBGbG9hdDMyQXJyYXkobGFyZ2VTaXplICogbGFyZ2VTaXplKVxuICAgICAgXG4gICAgICAvLyBGaWxsIHdpdGggcmFuZG9tIGRhdGFcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhW2ldID0gTWF0aC5yYW5kb20oKVxuICAgICAgICBiW2ldID0gTWF0aC5yYW5kb20oKVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3B0aW1pemVyLm9wdGltaXplZE1hdHJpeE11bHRpcGx5KGEsIGIsIGxhcmdlU2l6ZSwgbGFyZ2VTaXplKVxuICAgICAgY29uc3Qgb3BlcmF0aW9uVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVJbnN0YW5jZU9mKEZsb2F0MzJBcnJheSlcbiAgICAgIGV4cGVjdChyZXN1bHQubGVuZ3RoKS50b0JlKGxhcmdlU2l6ZSAqIGxhcmdlU2l6ZSlcbiAgICAgIGV4cGVjdChvcGVyYXRpb25UaW1lKS50b0JlTGVzc1RoYW4oMTAwMDApIC8vIDEwIHNlY29uZHMgbWF4XG4gICAgfSlcbiAgICBcbiAgICB0ZXN0KCdTaG91bGQgaGFuZGxlIGludmFsaWQgaW5wdXRzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkSW5wdXRzID0gW1xuICAgICAgICBudWxsLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoMCksXG4gICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoW05hTiwgSW5maW5pdHksIC1JbmZpbml0eV0pXG4gICAgICBdXG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW52YWxpZElucHV0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgYXdhaXQgb3B0aW1pemVyLm9wdGltaXplZE1hdHJpeE11bHRpcGx5KGlucHV0LCBpbnB1dCwgMSwgMSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gU2hvdWxkIGhhbmRsZSBncmFjZWZ1bGx5IHdpdGhvdXQgY3Jhc2hpbmdcbiAgICAgICAgICBleHBlY3QoZXJyb3IpLnRvQmVJbnN0YW5jZU9mKEVycm9yKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn0pIl0sInZlcnNpb24iOjN9