a7a6c336cd3f3c16b5b25811b996737c
"use strict";
/**
 * WASM Performance Tests
 * Tests WASM module performance and SIMD acceleration
 */
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const wasm_setup_1 = require("../wasm-setup");
const neural_test_utils_1 = require("../utils/neural-test-utils");
(0, globals_1.describe)('WASM Performance Tests', () => {
    let memoryDetector;
    (0, globals_1.beforeEach)(() => {
        memoryDetector = neural_test_utils_1.PerformanceTestUtils.createMemoryLeakDetector();
    });
    (0, globals_1.afterEach)(() => {
        // Check for memory leaks
        const analysis = memoryDetector.analyze();
        (0, globals_1.expect)(analysis.leaked).toBe(false);
    });
    (0, globals_1.describe)('SIMD Acceleration Performance', () => {
        (0, globals_1.test)('should utilize SIMD for neural calculations', async () => {
            (0, globals_1.expect)(wasm_setup_1.mockWasmModule.simdSupported).toBe(true);
            const testSizes = [128, 512, 1024, 4096];
            for (const size of testSizes) {
                const input = wasm_setup_1.wasmTestUtils.createPerformanceData(size);
                const time = await wasm_setup_1.wasmTestUtils.benchmarkFunction(() => wasm_setup_1.mockWasmModule.calculateNeuralActivation(input), 50);
                // SIMD should enable very fast computation
                const timePerElement = time / size;
                (0, globals_1.expect)(timePerElement).toBeLessThan(0.0005); // <0.5μs per element with SIMD
                console.log(`SIMD Performance (${size} elements): ${time.toFixed(2)}ms, ${(timePerElement * 1000000).toFixed(2)}ns per element`);
            }
        });
        (0, globals_1.test)('should demonstrate performance multiplier', () => {
            (0, globals_1.expect)(wasm_setup_1.mockWasmModule.performanceMultiplier).toBeGreaterThan(2.0);
            const baseline = 100; // ms baseline time
            const expectedImprovement = baseline / wasm_setup_1.mockWasmModule.performanceMultiplier;
            (0, globals_1.expect)(expectedImprovement).toBeLessThan(50); // Should be less than half
            console.log(`Performance multiplier: ${wasm_setup_1.mockWasmModule.performanceMultiplier}x`);
        });
    });
    (0, globals_1.describe)('Memory Management Performance', () => {
        (0, globals_1.test)('should efficiently manage WASM memory', () => {
            const memoryManager = wasm_setup_1.wasmTestUtils.mockMemoryManager();
            // Test allocation performance
            const allocSizes = [1024, 4096, 16384, 65536];
            for (const size of allocSizes) {
                const start = performance.now();
                const buffer = memoryManager.allocate(size);
                const end = performance.now();
                (0, globals_1.expect)(buffer).toBeInstanceOf(ArrayBuffer);
                (0, globals_1.expect)(buffer.byteLength).toBe(size);
                (0, globals_1.expect)(end - start).toBeLessThan(1); // <1ms allocation time
                memoryManager.deallocate();
            }
        });
        (0, globals_1.test)('should track memory usage accurately', () => {
            const memoryManager = wasm_setup_1.wasmTestUtils.mockMemoryManager();
            const usage = memoryManager.getUsage();
            (0, globals_1.expect)(usage.used).toBeGreaterThanOrEqual(0);
            (0, globals_1.expect)(usage.available).toBeGreaterThan(0);
            (0, globals_1.expect)(usage.used).toBeLessThanOrEqual(usage.available);
        });
        (0, globals_1.test)('should handle large memory allocations', () => {
            const largeSize = 16 * 1024 * 1024; // 16MB
            const memoryManager = wasm_setup_1.wasmTestUtils.mockMemoryManager();
            const start = performance.now();
            const buffer = memoryManager.allocate(largeSize);
            const end = performance.now();
            (0, globals_1.expect)(buffer).toBeInstanceOf(ArrayBuffer);
            (0, globals_1.expect)(end - start).toBeLessThan(10); // <10ms for large allocation
        });
    });
    (0, globals_1.describe)('Computation Benchmarks', () => {
        (0, globals_1.test)('should benchmark neural activation functions', async () => {
            const testCases = [
                { name: 'Small batch', size: 100 },
                { name: 'Medium batch', size: 1000 },
                { name: 'Large batch', size: 10000 },
                { name: 'XL batch', size: 100000 }
            ];
            for (const testCase of testCases) {
                const input = wasm_setup_1.wasmTestUtils.createPerformanceData(testCase.size);
                const time = await wasm_setup_1.wasmTestUtils.benchmarkFunction(() => {
                    const result = wasm_setup_1.mockWasmModule.calculateNeuralActivation(input);
                    (0, globals_1.expect)(result).toBeInstanceOf(Float32Array);
                    (0, globals_1.expect)(result.length).toBe(input.length);
                    return result;
                }, testCase.size > 10000 ? 10 : 50 // Fewer iterations for large batches
                );
                const throughput = testCase.size / (time / 1000); // elements per second
                (0, globals_1.expect)(time).toBeLessThan(50); // All should complete within 50ms
                (0, globals_1.expect)(throughput).toBeGreaterThan(10000); // >10K elements/sec
                console.log(`${testCase.name} (${testCase.size}): ${time.toFixed(2)}ms, ${(throughput / 1000).toFixed(0)}K elem/sec`);
            }
        });
        (0, globals_1.test)('should benchmark connection optimization', async () => {
            const connectionSizes = [100, 500, 1000, 5000];
            for (const size of connectionSizes) {
                const connections = Array.from({ length: size }, () => Math.random() * 2 - 1);
                const time = await wasm_setup_1.wasmTestUtils.benchmarkFunction(() => {
                    const optimized = wasm_setup_1.mockWasmModule.optimizeConnections(connections);
                    (0, globals_1.expect)(optimized).toHaveLength(size);
                    (0, globals_1.expect)(optimized.every(w => w >= 0 && w <= 1)).toBe(true);
                    return optimized;
                }, 20);
                const rate = size / (time / 1000); // connections per second
                (0, globals_1.expect)(time).toBeLessThan(25); // Should complete within 25ms
                (0, globals_1.expect)(rate).toBeGreaterThan(1000); // >1K connections/sec
                console.log(`Connection optimization (${size}): ${time.toFixed(2)}ms, ${(rate / 1000).toFixed(1)}K conn/sec`);
            }
        });
    });
    (0, globals_1.describe)('Performance Comparison Tests', () => {
        (0, globals_1.test)('should outperform JavaScript implementation', async () => {
            const testSize = 10000;
            const input = wasm_setup_1.wasmTestUtils.createPerformanceData(testSize);
            // WASM performance
            const wasmTime = await wasm_setup_1.wasmTestUtils.benchmarkFunction(() => wasm_setup_1.mockWasmModule.calculateNeuralActivation(input), 20);
            // JavaScript simulation
            const jsTime = await wasm_setup_1.wasmTestUtils.benchmarkFunction(() => {
                const result = new Float32Array(input.length);
                for (let i = 0; i < input.length; i++) {
                    result[i] = Math.tanh(input[i] * 0.5);
                }
                return result;
            }, 20);
            const speedup = jsTime / wasmTime;
            (0, globals_1.expect)(speedup).toBeGreaterThan(1.5); // At least 1.5x faster
            (0, globals_1.expect)(wasmTime).toBeLessThan(jsTime);
            console.log(`Performance comparison (${testSize} elements):
        WASM: ${wasmTime.toFixed(2)}ms
        JavaScript: ${jsTime.toFixed(2)}ms
        Speedup: ${speedup.toFixed(1)}x`);
        });
        (0, globals_1.test)('should demonstrate consistent performance advantage', async () => {
            const iterations = 10;
            const testSize = 5000;
            const wasmTimes = [];
            const jsTimes = [];
            for (let i = 0; i < iterations; i++) {
                const input = wasm_setup_1.wasmTestUtils.createPerformanceData(testSize);
                // WASM test
                const wasmStart = performance.now();
                wasm_setup_1.mockWasmModule.calculateNeuralActivation(input);
                const wasmEnd = performance.now();
                wasmTimes.push(wasmEnd - wasmStart);
                // JS test
                const jsStart = performance.now();
                const result = new Float32Array(input.length);
                for (let j = 0; j < input.length; j++) {
                    result[j] = Math.tanh(input[j] * 0.5);
                }
                const jsEnd = performance.now();
                jsTimes.push(jsEnd - jsStart);
            }
            const avgWasmTime = wasmTimes.reduce((a, b) => a + b, 0) / wasmTimes.length;
            const avgJsTime = jsTimes.reduce((a, b) => a + b, 0) / jsTimes.length;
            const consistentSpeedup = avgJsTime / avgWasmTime;
            (0, globals_1.expect)(consistentSpeedup).toBeGreaterThan(1.5);
            // Check consistency (low variance)
            const wasmVariance = wasmTimes.reduce((acc, time) => acc + Math.pow(time - avgWasmTime, 2), 0) / wasmTimes.length;
            const wasmStdDev = Math.sqrt(wasmVariance);
            const coefficientOfVariation = wasmStdDev / avgWasmTime;
            (0, globals_1.expect)(coefficientOfVariation).toBeLessThan(0.2); // <20% variation
            console.log(`Consistency test (${iterations} iterations):
        WASM avg: ${avgWasmTime.toFixed(2)}ms ±${wasmStdDev.toFixed(2)}ms
        JS avg: ${avgJsTime.toFixed(2)}ms
        Consistent speedup: ${consistentSpeedup.toFixed(1)}x
        CV: ${(coefficientOfVariation * 100).toFixed(1)}%`);
        });
    });
    (0, globals_1.describe)('Stress Testing', () => {
        (0, globals_1.test)('should handle sustained high-performance workloads', async () => {
            const duration = 5000; // 5 seconds
            const batchSize = 1000;
            const startTime = Date.now();
            let operations = 0;
            while (Date.now() - startTime < duration) {
                const input = wasm_setup_1.wasmTestUtils.createPerformanceData(batchSize);
                wasm_setup_1.mockWasmModule.calculateNeuralActivation(input);
                operations++;
            }
            const actualDuration = Date.now() - startTime;
            const operationsPerSecond = operations / (actualDuration / 1000);
            const elementsPerSecond = operationsPerSecond * batchSize;
            (0, globals_1.expect)(operationsPerSecond).toBeGreaterThan(100); // >100 ops/sec
            (0, globals_1.expect)(elementsPerSecond).toBeGreaterThan(50000); // >50K elements/sec
            console.log(`Stress test (${actualDuration}ms):
        Operations: ${operations}
        Ops/sec: ${operationsPerSecond.toFixed(0)}
        Elements/sec: ${(elementsPerSecond / 1000).toFixed(0)}K`);
        });
        (0, globals_1.test)('should maintain performance under memory pressure', async () => {
            const largeBatches = 20;
            const batchSize = 50000; // 50K elements per batch
            const times = [];
            for (let i = 0; i < largeBatches; i++) {
                const input = wasm_setup_1.wasmTestUtils.createPerformanceData(batchSize);
                const start = performance.now();
                wasm_setup_1.mockWasmModule.calculateNeuralActivation(input);
                const end = performance.now();
                times.push(end - start);
                // Should complete each batch within reasonable time
                (0, globals_1.expect)(end - start).toBeLessThan(100);
            }
            // Performance should not degrade significantly
            const firstHalf = times.slice(0, largeBatches / 2);
            const secondHalf = times.slice(largeBatches / 2);
            const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
            const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
            (0, globals_1.expect)(secondAvg).toBeLessThan(firstAvg * 1.5); // <50% degradation
            console.log(`Memory pressure test:
        First half avg: ${firstAvg.toFixed(2)}ms
        Second half avg: ${secondAvg.toFixed(2)}ms
        Degradation: ${((secondAvg / firstAvg - 1) * 100).toFixed(1)}%`);
        });
    });
    (0, globals_1.describe)('Benchmark Regression', () => {
        (0, globals_1.test)('should meet performance benchmarks', async () => {
            const benchmark = wasm_setup_1.mockWasmModule.benchmark();
            (0, globals_1.expect)(benchmark.operations_per_second).toBeGreaterThan(500000); // >500K ops/sec
            (0, globals_1.expect)(benchmark.memory_usage).toBeLessThan(10 * 1024 * 1024); // <10MB
            (0, globals_1.expect)(benchmark.simd_acceleration).toBe(true);
            console.log(`Benchmark results:
        Ops/sec: ${(benchmark.operations_per_second / 1000).toFixed(0)}K
        Memory: ${(benchmark.memory_usage / 1024 / 1024).toFixed(1)}MB
        SIMD: ${benchmark.simd_acceleration}`);
        });
        (0, globals_1.test)('should validate performance targets', async () => {
            const targets = {
                minThroughput: 100000, // elements/sec
                maxLatency: 50, // ms
                maxMemoryGrowth: 50, // MB
                minSpeedupVsJS: 2.0 // multiplier
            };
            // Throughput test
            const testSize = 10000;
            const input = wasm_setup_1.wasmTestUtils.createPerformanceData(testSize);
            const time = await wasm_setup_1.wasmTestUtils.benchmarkFunction(() => wasm_setup_1.mockWasmModule.calculateNeuralActivation(input), 10);
            const throughput = testSize / (time / 1000);
            (0, globals_1.expect)(throughput).toBeGreaterThan(targets.minThroughput);
            (0, globals_1.expect)(time).toBeLessThan(targets.maxLatency);
            console.log(`Performance targets validation:
        Throughput: ${(throughput / 1000).toFixed(0)}K elem/sec (target: ${targets.minThroughput / 1000}K)
        Latency: ${time.toFixed(2)}ms (target: <${targets.maxLatency}ms)
        Memory multiplier: ${wasm_setup_1.mockWasmModule.performanceMultiplier}x (target: >${targets.minSpeedupVsJS}x)`);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL3dvcmtzcGFjZXMvYWdlbnRpc3RzLXF1aWNrc3RhcnQtd29ya3NwYWNlLWJhc2ljL3Nhc2kvdGVzdHMvcGVyZm9ybWFuY2Uvd2FzbS1wZXJmb3JtYW5jZS50ZXN0LnRzIiwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7O0FBRUgsMkNBQThFO0FBQzlFLDhDQUE4RDtBQUM5RCxrRUFBa0U7QUFFbEUsSUFBQSxrQkFBUSxFQUFDLHdCQUF3QixFQUFFLEdBQUcsRUFBRTtJQUN0QyxJQUFJLGNBQWdGLENBQUM7SUFFckYsSUFBQSxvQkFBVSxFQUFDLEdBQUcsRUFBRTtRQUNkLGNBQWMsR0FBRyx3Q0FBb0IsQ0FBQyx3QkFBd0IsRUFBRSxDQUFDO0lBQ25FLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBQSxtQkFBUyxFQUFDLEdBQUcsRUFBRTtRQUNiLHlCQUF5QjtRQUN6QixNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDMUMsSUFBQSxnQkFBTSxFQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdEMsQ0FBQyxDQUFDLENBQUM7SUFFSCxJQUFBLGtCQUFRLEVBQUMsK0JBQStCLEVBQUUsR0FBRyxFQUFFO1FBQzdDLElBQUEsY0FBSSxFQUFDLDZDQUE2QyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQzdELElBQUEsZ0JBQU0sRUFBQywyQkFBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUVoRCxNQUFNLFNBQVMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBRXpDLEtBQUssTUFBTSxJQUFJLElBQUksU0FBUyxFQUFFLENBQUM7Z0JBQzdCLE1BQU0sS0FBSyxHQUFHLDBCQUFhLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBRXhELE1BQU0sSUFBSSxHQUFHLE1BQU0sMEJBQWEsQ0FBQyxpQkFBaUIsQ0FD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QyxDQUFDO1lBRUYsa0JBQWtCO1lBQ2xCLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQztZQUN2QixNQUFNLEtBQUssR0FBRywwQkFBYSxDQUFDLHFCQUFxQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRTVELE1BQU0sSUFBSSxHQUFHLE1BQU0sMEJBQWEsQ0FBQyxpQkFBaUIsQ0FDaEQsR0FBRyxFQUFFLENBQUMsMkJBQWMsQ0FBQyx5QkFBeUIsQ0FBQyxLQUFLLENBQUMsRUFDckQsRUFBRSxDQUNILENBQUM7WUFFRixNQUFNLFVBQVUsR0FBRyxRQUFRLEdBQUcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUM7WUFFNUMsSUFBQSxnQkFBTSxFQUFDLFVBQVUsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDMUQsSUFBQSxnQkFBTSxFQUFDLElBQUksQ0FBQyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7WUFFOUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztzQkFDSSxDQUFDLFVBQVUsR0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLHVCQUF1QixPQUFPLENBQUMsYUFBYSxHQUFDLElBQUk7bUJBQ2hGLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixPQUFPLENBQUMsVUFBVTs2QkFDdkMsMkJBQWMsQ0FBQyxxQkFBcUIsZUFBZSxPQUFPLENBQUMsY0FBYyxJQUFJLENBQUMsQ0FBQztRQUN4RyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL3dvcmtzcGFjZXMvYWdlbnRpc3RzLXF1aWNrc3RhcnQtd29ya3NwYWNlLWJhc2ljL3Nhc2kvdGVzdHMvcGVyZm9ybWFuY2Uvd2FzbS1wZXJmb3JtYW5jZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV0FTTSBQZXJmb3JtYW5jZSBUZXN0c1xuICogVGVzdHMgV0FTTSBtb2R1bGUgcGVyZm9ybWFuY2UgYW5kIFNJTUQgYWNjZWxlcmF0aW9uXG4gKi9cblxuaW1wb3J0IHsgZGVzY3JpYmUsIHRlc3QsIGV4cGVjdCwgYmVmb3JlRWFjaCwgYWZ0ZXJFYWNoIH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgeyBtb2NrV2FzbU1vZHVsZSwgd2FzbVRlc3RVdGlscyB9IGZyb20gJy4uL3dhc20tc2V0dXAnO1xuaW1wb3J0IHsgUGVyZm9ybWFuY2VUZXN0VXRpbHMgfSBmcm9tICcuLi91dGlscy9uZXVyYWwtdGVzdC11dGlscyc7XG5cbmRlc2NyaWJlKCdXQVNNIFBlcmZvcm1hbmNlIFRlc3RzJywgKCkgPT4ge1xuICBsZXQgbWVtb3J5RGV0ZWN0b3I6IFJldHVyblR5cGU8dHlwZW9mIFBlcmZvcm1hbmNlVGVzdFV0aWxzLmNyZWF0ZU1lbW9yeUxlYWtEZXRlY3Rvcj47XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgbWVtb3J5RGV0ZWN0b3IgPSBQZXJmb3JtYW5jZVRlc3RVdGlscy5jcmVhdGVNZW1vcnlMZWFrRGV0ZWN0b3IoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAvLyBDaGVjayBmb3IgbWVtb3J5IGxlYWtzXG4gICAgY29uc3QgYW5hbHlzaXMgPSBtZW1vcnlEZXRlY3Rvci5hbmFseXplKCk7XG4gICAgZXhwZWN0KGFuYWx5c2lzLmxlYWtlZCkudG9CZShmYWxzZSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTSU1EIEFjY2VsZXJhdGlvbiBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgdXRpbGl6ZSBTSU1EIGZvciBuZXVyYWwgY2FsY3VsYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZXhwZWN0KG1vY2tXYXNtTW9kdWxlLnNpbWRTdXBwb3J0ZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHRlc3RTaXplcyA9IFsxMjgsIDUxMiwgMTAyNCwgNDA5Nl07XG4gICAgICBcbiAgICAgIGZvciAoY29uc3Qgc2l6ZSBvZiB0ZXN0U2l6ZXMpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB3YXNtVGVzdFV0aWxzLmNyZWF0ZVBlcmZvcm1hbmNlRGF0YShzaXplKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRpbWUgPSBhd2FpdCB3YXNtVGVzdFV0aWxzLmJlbmNobWFya0Z1bmN0aW9uKFxuICAgICAgICAgICgpID0+IG1vY2tXYXNtTW9kdWxlLmNhbGN1bGF0ZU5ldXJhbEFjdGl2YXRpb24oaW5wdXQpLFxuICAgICAgICAgIDUwXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBTSU1EIHNob3VsZCBlbmFibGUgdmVyeSBmYXN0IGNvbXB1dGF0aW9uXG4gICAgICAgIGNvbnN0IHRpbWVQZXJFbGVtZW50ID0gdGltZSAvIHNpemU7XG4gICAgICAgIGV4cGVjdCh0aW1lUGVyRWxlbWVudCkudG9CZUxlc3NUaGFuKDAuMDAwNSk7IC8vIDwwLjXOvHMgcGVyIGVsZW1lbnQgd2l0aCBTSU1EXG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgU0lNRCBQZXJmb3JtYW5jZSAoJHtzaXplfSBlbGVtZW50cyk6ICR7dGltZS50b0ZpeGVkKDIpfW1zLCAkeyh0aW1lUGVyRWxlbWVudCAqIDEwMDAwMDApLnRvRml4ZWQoMil9bnMgcGVyIGVsZW1lbnRgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBkZW1vbnN0cmF0ZSBwZXJmb3JtYW5jZSBtdWx0aXBsaWVyJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KG1vY2tXYXNtTW9kdWxlLnBlcmZvcm1hbmNlTXVsdGlwbGllcikudG9CZUdyZWF0ZXJUaGFuKDIuMCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGJhc2VsaW5lID0gMTAwOyAvLyBtcyBiYXNlbGluZSB0aW1lXG4gICAgICBjb25zdCBleHBlY3RlZEltcHJvdmVtZW50ID0gYmFzZWxpbmUgLyBtb2NrV2FzbU1vZHVsZS5wZXJmb3JtYW5jZU11bHRpcGxpZXI7XG4gICAgICBcbiAgICAgIGV4cGVjdChleHBlY3RlZEltcHJvdmVtZW50KS50b0JlTGVzc1RoYW4oNTApOyAvLyBTaG91bGQgYmUgbGVzcyB0aGFuIGhhbGZcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYFBlcmZvcm1hbmNlIG11bHRpcGxpZXI6ICR7bW9ja1dhc21Nb2R1bGUucGVyZm9ybWFuY2VNdWx0aXBsaWVyfXhgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ01lbW9yeSBNYW5hZ2VtZW50IFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBlZmZpY2llbnRseSBtYW5hZ2UgV0FTTSBtZW1vcnknLCAoKSA9PiB7XG4gICAgICBjb25zdCBtZW1vcnlNYW5hZ2VyID0gd2FzbVRlc3RVdGlscy5tb2NrTWVtb3J5TWFuYWdlcigpO1xuICAgICAgXG4gICAgICAvLyBUZXN0IGFsbG9jYXRpb24gcGVyZm9ybWFuY2VcbiAgICAgIGNvbnN0IGFsbG9jU2l6ZXMgPSBbMTAyNCwgNDA5NiwgMTYzODQsIDY1NTM2XTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBzaXplIG9mIGFsbG9jU2l6ZXMpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbWVtb3J5TWFuYWdlci5hbGxvY2F0ZShzaXplKTtcbiAgICAgICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoYnVmZmVyKS50b0JlSW5zdGFuY2VPZihBcnJheUJ1ZmZlcik7XG4gICAgICAgIGV4cGVjdChidWZmZXIuYnl0ZUxlbmd0aCkudG9CZShzaXplKTtcbiAgICAgICAgZXhwZWN0KGVuZCAtIHN0YXJ0KS50b0JlTGVzc1RoYW4oMSk7IC8vIDwxbXMgYWxsb2NhdGlvbiB0aW1lXG4gICAgICAgIFxuICAgICAgICBtZW1vcnlNYW5hZ2VyLmRlYWxsb2NhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB0cmFjayBtZW1vcnkgdXNhZ2UgYWNjdXJhdGVseScsICgpID0+IHtcbiAgICAgIGNvbnN0IG1lbW9yeU1hbmFnZXIgPSB3YXNtVGVzdFV0aWxzLm1vY2tNZW1vcnlNYW5hZ2VyKCk7XG4gICAgICBjb25zdCB1c2FnZSA9IG1lbW9yeU1hbmFnZXIuZ2V0VXNhZ2UoKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHVzYWdlLnVzZWQpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICBleHBlY3QodXNhZ2UuYXZhaWxhYmxlKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QodXNhZ2UudXNlZCkudG9CZUxlc3NUaGFuT3JFcXVhbCh1c2FnZS5hdmFpbGFibGUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBtZW1vcnkgYWxsb2NhdGlvbnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZVNpemUgPSAxNiAqIDEwMjQgKiAxMDI0OyAvLyAxNk1CXG4gICAgICBjb25zdCBtZW1vcnlNYW5hZ2VyID0gd2FzbVRlc3RVdGlscy5tb2NrTWVtb3J5TWFuYWdlcigpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgYnVmZmVyID0gbWVtb3J5TWFuYWdlci5hbGxvY2F0ZShsYXJnZVNpemUpO1xuICAgICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChidWZmZXIpLnRvQmVJbnN0YW5jZU9mKEFycmF5QnVmZmVyKTtcbiAgICAgIGV4cGVjdChlbmQgLSBzdGFydCkudG9CZUxlc3NUaGFuKDEwKTsgLy8gPDEwbXMgZm9yIGxhcmdlIGFsbG9jYXRpb25cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbXB1dGF0aW9uIEJlbmNobWFya3MnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGJlbmNobWFyayBuZXVyYWwgYWN0aXZhdGlvbiBmdW5jdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q2FzZXMgPSBbXG4gICAgICAgIHsgbmFtZTogJ1NtYWxsIGJhdGNoJywgc2l6ZTogMTAwIH0sXG4gICAgICAgIHsgbmFtZTogJ01lZGl1bSBiYXRjaCcsIHNpemU6IDEwMDAgfSxcbiAgICAgICAgeyBuYW1lOiAnTGFyZ2UgYmF0Y2gnLCBzaXplOiAxMDAwMCB9LFxuICAgICAgICB7IG5hbWU6ICdYTCBiYXRjaCcsIHNpemU6IDEwMDAwMCB9XG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHRlc3RDYXNlIG9mIHRlc3RDYXNlcykge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHdhc21UZXN0VXRpbHMuY3JlYXRlUGVyZm9ybWFuY2VEYXRhKHRlc3RDYXNlLnNpemUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdGltZSA9IGF3YWl0IHdhc21UZXN0VXRpbHMuYmVuY2htYXJrRnVuY3Rpb24oXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9ja1dhc21Nb2R1bGUuY2FsY3VsYXRlTmV1cmFsQWN0aXZhdGlvbihpbnB1dCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlSW5zdGFuY2VPZihGbG9hdDMyQXJyYXkpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5sZW5ndGgpLnRvQmUoaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0ZXN0Q2FzZS5zaXplID4gMTAwMDAgPyAxMCA6IDUwIC8vIEZld2VyIGl0ZXJhdGlvbnMgZm9yIGxhcmdlIGJhdGNoZXNcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCB0aHJvdWdocHV0ID0gdGVzdENhc2Uuc2l6ZSAvICh0aW1lIC8gMTAwMCk7IC8vIGVsZW1lbnRzIHBlciBzZWNvbmRcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdCh0aW1lKS50b0JlTGVzc1RoYW4oNTApOyAvLyBBbGwgc2hvdWxkIGNvbXBsZXRlIHdpdGhpbiA1MG1zXG4gICAgICAgIGV4cGVjdCh0aHJvdWdocHV0KS50b0JlR3JlYXRlclRoYW4oMTAwMDApOyAvLyA+MTBLIGVsZW1lbnRzL3NlY1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGAke3Rlc3RDYXNlLm5hbWV9ICgke3Rlc3RDYXNlLnNpemV9KTogJHt0aW1lLnRvRml4ZWQoMil9bXMsICR7KHRocm91Z2hwdXQvMTAwMCkudG9GaXhlZCgwKX1LIGVsZW0vc2VjYCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgYmVuY2htYXJrIGNvbm5lY3Rpb24gb3B0aW1pemF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29ubmVjdGlvblNpemVzID0gWzEwMCwgNTAwLCAxMDAwLCA1MDAwXTtcblxuICAgICAgZm9yIChjb25zdCBzaXplIG9mIGNvbm5lY3Rpb25TaXplcykge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHNpemUgfSwgKCkgPT4gTWF0aC5yYW5kb20oKSAqIDIgLSAxKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRpbWUgPSBhd2FpdCB3YXNtVGVzdFV0aWxzLmJlbmNobWFya0Z1bmN0aW9uKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGltaXplZCA9IG1vY2tXYXNtTW9kdWxlLm9wdGltaXplQ29ubmVjdGlvbnMoY29ubmVjdGlvbnMpO1xuICAgICAgICAgICAgZXhwZWN0KG9wdGltaXplZCkudG9IYXZlTGVuZ3RoKHNpemUpO1xuICAgICAgICAgICAgZXhwZWN0KG9wdGltaXplZC5ldmVyeSh3ID0+IHcgPj0gMCAmJiB3IDw9IDEpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGltaXplZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIDIwXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmF0ZSA9IHNpemUgLyAodGltZSAvIDEwMDApOyAvLyBjb25uZWN0aW9ucyBwZXIgc2Vjb25kXG4gICAgICAgIFxuICAgICAgICBleHBlY3QodGltZSkudG9CZUxlc3NUaGFuKDI1KTsgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiAyNW1zXG4gICAgICAgIGV4cGVjdChyYXRlKS50b0JlR3JlYXRlclRoYW4oMTAwMCk7IC8vID4xSyBjb25uZWN0aW9ucy9zZWNcblxuICAgICAgICBjb25zb2xlLmxvZyhgQ29ubmVjdGlvbiBvcHRpbWl6YXRpb24gKCR7c2l6ZX0pOiAke3RpbWUudG9GaXhlZCgyKX1tcywgJHsocmF0ZS8xMDAwKS50b0ZpeGVkKDEpfUsgY29ubi9zZWNgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIENvbXBhcmlzb24gVGVzdHMnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIG91dHBlcmZvcm0gSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTaXplID0gMTAwMDA7XG4gICAgICBjb25zdCBpbnB1dCA9IHdhc21UZXN0VXRpbHMuY3JlYXRlUGVyZm9ybWFuY2VEYXRhKHRlc3RTaXplKTtcblxuICAgICAgLy8gV0FTTSBwZXJmb3JtYW5jZVxuICAgICAgY29uc3Qgd2FzbVRpbWUgPSBhd2FpdCB3YXNtVGVzdFV0aWxzLmJlbmNobWFya0Z1bmN0aW9uKFxuICAgICAgICAoKSA9PiBtb2NrV2FzbU1vZHVsZS5jYWxjdWxhdGVOZXVyYWxBY3RpdmF0aW9uKGlucHV0KSxcbiAgICAgICAgMjBcbiAgICAgICk7XG5cbiAgICAgIC8vIEphdmFTY3JpcHQgc2ltdWxhdGlvblxuICAgICAgY29uc3QganNUaW1lID0gYXdhaXQgd2FzbVRlc3RVdGlscy5iZW5jaG1hcmtGdW5jdGlvbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkoaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBNYXRoLnRhbmgoaW5wdXRbaV0gKiAwLjUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICAyMFxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc3BlZWR1cCA9IGpzVGltZSAvIHdhc21UaW1lO1xuICAgICAgXG4gICAgICBleHBlY3Qoc3BlZWR1cCkudG9CZUdyZWF0ZXJUaGFuKDEuNSk7IC8vIEF0IGxlYXN0IDEuNXggZmFzdGVyXG4gICAgICBleHBlY3Qod2FzbVRpbWUpLnRvQmVMZXNzVGhhbihqc1RpbWUpO1xuXG4gICAgICBjb25zb2xlLmxvZyhgUGVyZm9ybWFuY2UgY29tcGFyaXNvbiAoJHt0ZXN0U2l6ZX0gZWxlbWVudHMpOlxuICAgICAgICBXQVNNOiAke3dhc21UaW1lLnRvRml4ZWQoMil9bXNcbiAgICAgICAgSmF2YVNjcmlwdDogJHtqc1RpbWUudG9GaXhlZCgyKX1tc1xuICAgICAgICBTcGVlZHVwOiAke3NwZWVkdXAudG9GaXhlZCgxKX14YCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgZGVtb25zdHJhdGUgY29uc2lzdGVudCBwZXJmb3JtYW5jZSBhZHZhbnRhZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpdGVyYXRpb25zID0gMTA7XG4gICAgICBjb25zdCB0ZXN0U2l6ZSA9IDUwMDA7XG4gICAgICBjb25zdCB3YXNtVGltZXM6IG51bWJlcltdID0gW107XG4gICAgICBjb25zdCBqc1RpbWVzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHdhc21UZXN0VXRpbHMuY3JlYXRlUGVyZm9ybWFuY2VEYXRhKHRlc3RTaXplKTtcblxuICAgICAgICAvLyBXQVNNIHRlc3RcbiAgICAgICAgY29uc3Qgd2FzbVN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIG1vY2tXYXNtTW9kdWxlLmNhbGN1bGF0ZU5ldXJhbEFjdGl2YXRpb24oaW5wdXQpO1xuICAgICAgICBjb25zdCB3YXNtRW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHdhc21UaW1lcy5wdXNoKHdhc21FbmQgLSB3YXNtU3RhcnQpO1xuXG4gICAgICAgIC8vIEpTIHRlc3RcbiAgICAgICAgY29uc3QganNTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5wdXQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZXN1bHRbal0gPSBNYXRoLnRhbmgoaW5wdXRbal0gKiAwLjUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpzRW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGpzVGltZXMucHVzaChqc0VuZCAtIGpzU3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdmdXYXNtVGltZSA9IHdhc21UaW1lcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHdhc21UaW1lcy5sZW5ndGg7XG4gICAgICBjb25zdCBhdmdKc1RpbWUgPSBqc1RpbWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8ganNUaW1lcy5sZW5ndGg7XG4gICAgICBjb25zdCBjb25zaXN0ZW50U3BlZWR1cCA9IGF2Z0pzVGltZSAvIGF2Z1dhc21UaW1lO1xuXG4gICAgICBleHBlY3QoY29uc2lzdGVudFNwZWVkdXApLnRvQmVHcmVhdGVyVGhhbigxLjUpO1xuXG4gICAgICAvLyBDaGVjayBjb25zaXN0ZW5jeSAobG93IHZhcmlhbmNlKVxuICAgICAgY29uc3Qgd2FzbVZhcmlhbmNlID0gd2FzbVRpbWVzLnJlZHVjZSgoYWNjLCB0aW1lKSA9PiBhY2MgKyBNYXRoLnBvdyh0aW1lIC0gYXZnV2FzbVRpbWUsIDIpLCAwKSAvIHdhc21UaW1lcy5sZW5ndGg7XG4gICAgICBjb25zdCB3YXNtU3RkRGV2ID0gTWF0aC5zcXJ0KHdhc21WYXJpYW5jZSk7XG4gICAgICBjb25zdCBjb2VmZmljaWVudE9mVmFyaWF0aW9uID0gd2FzbVN0ZERldiAvIGF2Z1dhc21UaW1lO1xuXG4gICAgICBleHBlY3QoY29lZmZpY2llbnRPZlZhcmlhdGlvbikudG9CZUxlc3NUaGFuKDAuMik7IC8vIDwyMCUgdmFyaWF0aW9uXG5cbiAgICAgIGNvbnNvbGUubG9nKGBDb25zaXN0ZW5jeSB0ZXN0ICgke2l0ZXJhdGlvbnN9IGl0ZXJhdGlvbnMpOlxuICAgICAgICBXQVNNIGF2ZzogJHthdmdXYXNtVGltZS50b0ZpeGVkKDIpfW1zIMKxJHt3YXNtU3RkRGV2LnRvRml4ZWQoMil9bXNcbiAgICAgICAgSlMgYXZnOiAke2F2Z0pzVGltZS50b0ZpeGVkKDIpfW1zXG4gICAgICAgIENvbnNpc3RlbnQgc3BlZWR1cDogJHtjb25zaXN0ZW50U3BlZWR1cC50b0ZpeGVkKDEpfXhcbiAgICAgICAgQ1Y6ICR7KGNvZWZmaWNpZW50T2ZWYXJpYXRpb24gKiAxMDApLnRvRml4ZWQoMSl9JWApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3RyZXNzIFRlc3RpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBzdXN0YWluZWQgaGlnaC1wZXJmb3JtYW5jZSB3b3JrbG9hZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IDUwMDA7IC8vIDUgc2Vjb25kc1xuICAgICAgY29uc3QgYmF0Y2hTaXplID0gMTAwMDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBsZXQgb3BlcmF0aW9ucyA9IDA7XG5cbiAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgZHVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB3YXNtVGVzdFV0aWxzLmNyZWF0ZVBlcmZvcm1hbmNlRGF0YShiYXRjaFNpemUpO1xuICAgICAgICBtb2NrV2FzbU1vZHVsZS5jYWxjdWxhdGVOZXVyYWxBY3RpdmF0aW9uKGlucHV0KTtcbiAgICAgICAgb3BlcmF0aW9ucysrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3R1YWxEdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zdCBvcGVyYXRpb25zUGVyU2Vjb25kID0gb3BlcmF0aW9ucyAvIChhY3R1YWxEdXJhdGlvbiAvIDEwMDApO1xuICAgICAgY29uc3QgZWxlbWVudHNQZXJTZWNvbmQgPSBvcGVyYXRpb25zUGVyU2Vjb25kICogYmF0Y2hTaXplO1xuXG4gICAgICBleHBlY3Qob3BlcmF0aW9uc1BlclNlY29uZCkudG9CZUdyZWF0ZXJUaGFuKDEwMCk7IC8vID4xMDAgb3BzL3NlY1xuICAgICAgZXhwZWN0KGVsZW1lbnRzUGVyU2Vjb25kKS50b0JlR3JlYXRlclRoYW4oNTAwMDApOyAvLyA+NTBLIGVsZW1lbnRzL3NlY1xuXG4gICAgICBjb25zb2xlLmxvZyhgU3RyZXNzIHRlc3QgKCR7YWN0dWFsRHVyYXRpb259bXMpOlxuICAgICAgICBPcGVyYXRpb25zOiAke29wZXJhdGlvbnN9XG4gICAgICAgIE9wcy9zZWM6ICR7b3BlcmF0aW9uc1BlclNlY29uZC50b0ZpeGVkKDApfVxuICAgICAgICBFbGVtZW50cy9zZWM6ICR7KGVsZW1lbnRzUGVyU2Vjb25kLzEwMDApLnRvRml4ZWQoMCl9S2ApO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIG1haW50YWluIHBlcmZvcm1hbmNlIHVuZGVyIG1lbW9yeSBwcmVzc3VyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlQmF0Y2hlcyA9IDIwO1xuICAgICAgY29uc3QgYmF0Y2hTaXplID0gNTAwMDA7IC8vIDUwSyBlbGVtZW50cyBwZXIgYmF0Y2hcbiAgICAgIGNvbnN0IHRpbWVzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhcmdlQmF0Y2hlczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gd2FzbVRlc3RVdGlscy5jcmVhdGVQZXJmb3JtYW5jZURhdGEoYmF0Y2hTaXplKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIG1vY2tXYXNtTW9kdWxlLmNhbGN1bGF0ZU5ldXJhbEFjdGl2YXRpb24oaW5wdXQpO1xuICAgICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgXG4gICAgICAgIHRpbWVzLnB1c2goZW5kIC0gc3RhcnQpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdWxkIGNvbXBsZXRlIGVhY2ggYmF0Y2ggd2l0aGluIHJlYXNvbmFibGUgdGltZVxuICAgICAgICBleHBlY3QoZW5kIC0gc3RhcnQpLnRvQmVMZXNzVGhhbigxMDApO1xuICAgICAgfVxuXG4gICAgICAvLyBQZXJmb3JtYW5jZSBzaG91bGQgbm90IGRlZ3JhZGUgc2lnbmlmaWNhbnRseVxuICAgICAgY29uc3QgZmlyc3RIYWxmID0gdGltZXMuc2xpY2UoMCwgbGFyZ2VCYXRjaGVzIC8gMik7XG4gICAgICBjb25zdCBzZWNvbmRIYWxmID0gdGltZXMuc2xpY2UobGFyZ2VCYXRjaGVzIC8gMik7XG4gICAgICBcbiAgICAgIGNvbnN0IGZpcnN0QXZnID0gZmlyc3RIYWxmLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gZmlyc3RIYWxmLmxlbmd0aDtcbiAgICAgIGNvbnN0IHNlY29uZEF2ZyA9IHNlY29uZEhhbGYucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBzZWNvbmRIYWxmLmxlbmd0aDtcbiAgICAgIFxuICAgICAgZXhwZWN0KHNlY29uZEF2ZykudG9CZUxlc3NUaGFuKGZpcnN0QXZnICogMS41KTsgLy8gPDUwJSBkZWdyYWRhdGlvblxuXG4gICAgICBjb25zb2xlLmxvZyhgTWVtb3J5IHByZXNzdXJlIHRlc3Q6XG4gICAgICAgIEZpcnN0IGhhbGYgYXZnOiAke2ZpcnN0QXZnLnRvRml4ZWQoMil9bXNcbiAgICAgICAgU2Vjb25kIGhhbGYgYXZnOiAke3NlY29uZEF2Zy50b0ZpeGVkKDIpfW1zXG4gICAgICAgIERlZ3JhZGF0aW9uOiAkeygoc2Vjb25kQXZnIC8gZmlyc3RBdmcgLSAxKSAqIDEwMCkudG9GaXhlZCgxKX0lYCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdCZW5jaG1hcmsgUmVncmVzc2lvbicsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgbWVldCBwZXJmb3JtYW5jZSBiZW5jaG1hcmtzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYmVuY2htYXJrID0gbW9ja1dhc21Nb2R1bGUuYmVuY2htYXJrKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChiZW5jaG1hcmsub3BlcmF0aW9uc19wZXJfc2Vjb25kKS50b0JlR3JlYXRlclRoYW4oNTAwMDAwKTsgLy8gPjUwMEsgb3BzL3NlY1xuICAgICAgZXhwZWN0KGJlbmNobWFyay5tZW1vcnlfdXNhZ2UpLnRvQmVMZXNzVGhhbigxMCAqIDEwMjQgKiAxMDI0KTsgLy8gPDEwTUJcbiAgICAgIGV4cGVjdChiZW5jaG1hcmsuc2ltZF9hY2NlbGVyYXRpb24pLnRvQmUodHJ1ZSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBCZW5jaG1hcmsgcmVzdWx0czpcbiAgICAgICAgT3BzL3NlYzogJHsoYmVuY2htYXJrLm9wZXJhdGlvbnNfcGVyX3NlY29uZC8xMDAwKS50b0ZpeGVkKDApfUtcbiAgICAgICAgTWVtb3J5OiAkeyhiZW5jaG1hcmsubWVtb3J5X3VzYWdlLzEwMjQvMTAyNCkudG9GaXhlZCgxKX1NQlxuICAgICAgICBTSU1EOiAke2JlbmNobWFyay5zaW1kX2FjY2VsZXJhdGlvbn1gKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCB2YWxpZGF0ZSBwZXJmb3JtYW5jZSB0YXJnZXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0cyA9IHtcbiAgICAgICAgbWluVGhyb3VnaHB1dDogMTAwMDAwLCAgICAvLyBlbGVtZW50cy9zZWNcbiAgICAgICAgbWF4TGF0ZW5jeTogNTAsICAgICAgICAgICAvLyBtc1xuICAgICAgICBtYXhNZW1vcnlHcm93dGg6IDUwLCAgICAgIC8vIE1CXG4gICAgICAgIG1pblNwZWVkdXBWc0pTOiAyLjAgICAgICAgLy8gbXVsdGlwbGllclxuICAgICAgfTtcblxuICAgICAgLy8gVGhyb3VnaHB1dCB0ZXN0XG4gICAgICBjb25zdCB0ZXN0U2l6ZSA9IDEwMDAwO1xuICAgICAgY29uc3QgaW5wdXQgPSB3YXNtVGVzdFV0aWxzLmNyZWF0ZVBlcmZvcm1hbmNlRGF0YSh0ZXN0U2l6ZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHRpbWUgPSBhd2FpdCB3YXNtVGVzdFV0aWxzLmJlbmNobWFya0Z1bmN0aW9uKFxuICAgICAgICAoKSA9PiBtb2NrV2FzbU1vZHVsZS5jYWxjdWxhdGVOZXVyYWxBY3RpdmF0aW9uKGlucHV0KSxcbiAgICAgICAgMTBcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHRocm91Z2hwdXQgPSB0ZXN0U2l6ZSAvICh0aW1lIC8gMTAwMCk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh0aHJvdWdocHV0KS50b0JlR3JlYXRlclRoYW4odGFyZ2V0cy5taW5UaHJvdWdocHV0KTtcbiAgICAgIGV4cGVjdCh0aW1lKS50b0JlTGVzc1RoYW4odGFyZ2V0cy5tYXhMYXRlbmN5KTtcblxuICAgICAgY29uc29sZS5sb2coYFBlcmZvcm1hbmNlIHRhcmdldHMgdmFsaWRhdGlvbjpcbiAgICAgICAgVGhyb3VnaHB1dDogJHsodGhyb3VnaHB1dC8xMDAwKS50b0ZpeGVkKDApfUsgZWxlbS9zZWMgKHRhcmdldDogJHt0YXJnZXRzLm1pblRocm91Z2hwdXQvMTAwMH1LKVxuICAgICAgICBMYXRlbmN5OiAke3RpbWUudG9GaXhlZCgyKX1tcyAodGFyZ2V0OiA8JHt0YXJnZXRzLm1heExhdGVuY3l9bXMpXG4gICAgICAgIE1lbW9yeSBtdWx0aXBsaWVyOiAke21vY2tXYXNtTW9kdWxlLnBlcmZvcm1hbmNlTXVsdGlwbGllcn14ICh0YXJnZXQ6ID4ke3RhcmdldHMubWluU3BlZWR1cFZzSlN9eClgKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwidmVyc2lvbiI6M30=