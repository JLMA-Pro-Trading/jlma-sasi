7ef173c85f2c1352a03e4128989e9c9d
"use strict";

// Performance tests for WASM modules in SASI/Synaptic integration
const {
  describe,
  test,
  expect,
  beforeAll,
  afterAll,
  beforeEach,
  afterEach
} = require('@jest/globals');
describe('WASM Performance Tests', () => {
  let wasmModule;
  let performanceCollector;
  let benchmarkSuite;
  beforeAll(async () => {
    // Initialize WASM performance testing environment
    wasmModule = {
      init: jest.fn(),
      process: jest.fn(),
      benchmark: jest.fn(),
      profile: jest.fn(),
      memory: new WebAssembly.Memory({
        initial: 1
      })
    };
    performanceCollector = {
      start: jest.fn(),
      stop: jest.fn(),
      measure: jest.fn(),
      report: jest.fn(),
      metrics: new Map()
    };
    benchmarkSuite = {
      run: jest.fn(),
      compare: jest.fn(),
      analyze: jest.fn(),
      optimize: jest.fn()
    };
    await wasmModule.init();
  });
  afterAll(async () => {
    // Cleanup WASM resources
    if (wasmModule.memory) {
      wasmModule.memory = null;
    }
  });
  beforeEach(() => {
    performanceCollector.start();
  });
  afterEach(() => {
    performanceCollector.stop();
    jest.clearAllMocks();
  });
  describe('Neural Network WASM Performance', () => {
    test('should benchmark neural network inference performance', async () => {
      const neuralBenchmark = {
        setup: jest.fn(),
        run: jest.fn(),
        cleanup: jest.fn(),
        results: jest.fn()
      };
      const benchmarkConfig = {
        iterations: 1000,
        inputSize: 784,
        hiddenLayers: [256, 128, 64],
        outputSize: 10,
        batchSize: 32
      };
      await neuralBenchmark.setup(benchmarkConfig);
      const startTime = performance.now();

      // Simulate neural network inference
      for (let i = 0; i < benchmarkConfig.iterations; i++) {
        const input = new Float32Array(benchmarkConfig.inputSize);
        input.fill(Math.random());
        await wasmModule.process(input);
      }
      const endTime = performance.now();
      const duration = endTime - startTime;
      await neuralBenchmark.run(benchmarkConfig);
      expect(neuralBenchmark.setup).toHaveBeenCalledWith(benchmarkConfig);
      expect(neuralBenchmark.run).toHaveBeenCalledWith(benchmarkConfig);
      expect(duration).toBeLessThan(10000); // Should complete within 10 seconds
    });
    test('should measure memory usage efficiency', async () => {
      const memoryProfiler = {
        profile: jest.fn(),
        analyze: jest.fn(),
        optimize: jest.fn(),
        report: jest.fn()
      };
      const memoryTest = {
        initialMemory: 1024 * 1024,
        // 1MB
        maxMemory: 10 * 1024 * 1024,
        // 10MB
        iterations: 100
      };
      const memoryUsage = [];
      for (let i = 0; i < memoryTest.iterations; i++) {
        const data = new Float32Array(1000);
        data.fill(Math.random());
        await wasmModule.process(data);

        // Simulate memory usage measurement
        const currentMemory = memoryTest.initialMemory + i * 1024;
        memoryUsage.push(currentMemory);
      }
      await memoryProfiler.profile(memoryUsage);
      expect(memoryProfiler.profile).toHaveBeenCalledWith(memoryUsage);
      expect(Math.max(...memoryUsage)).toBeLessThan(memoryTest.maxMemory);
    });
  });
  describe('SIMD Performance Optimization', () => {
    test('should benchmark SIMD operations', async () => {
      const simdBenchmark = {
        vectorAdd: jest.fn(),
        vectorMultiply: jest.fn(),
        matrixMultiply: jest.fn(),
        convolution: jest.fn()
      };
      const simdConfig = {
        vectorSize: 1024,
        matrixSize: 128,
        iterations: 10000
      };
      const vector1 = new Float32Array(simdConfig.vectorSize);
      const vector2 = new Float32Array(simdConfig.vectorSize);
      vector1.fill(Math.random());
      vector2.fill(Math.random());
      const startTime = performance.now();
      for (let i = 0; i < simdConfig.iterations; i++) {
        await simdBenchmark.vectorAdd(vector1, vector2);
      }
      const endTime = performance.now();
      const throughput = simdConfig.iterations / (endTime - startTime) * 1000;
      expect(simdBenchmark.vectorAdd).toHaveBeenCalledTimes(simdConfig.iterations);
      expect(throughput).toBeGreaterThan(1000); // Should achieve > 1000 ops/sec
    });
    test('should compare SIMD vs scalar performance', async () => {
      const performanceComparator = {
        simdImplementation: jest.fn(),
        scalarImplementation: jest.fn(),
        compare: jest.fn(),
        report: jest.fn()
      };
      const comparisonData = {
        dataSize: 10000,
        iterations: 1000,
        operations: ['add', 'multiply', 'divide']
      };
      const testData = new Float32Array(comparisonData.dataSize);
      testData.fill(Math.random());

      // SIMD performance
      const simdStartTime = performance.now();
      await performanceComparator.simdImplementation(testData);
      const simdEndTime = performance.now();
      const simdDuration = simdEndTime - simdStartTime;

      // Scalar performance
      const scalarStartTime = performance.now();
      await performanceComparator.scalarImplementation(testData);
      const scalarEndTime = performance.now();
      const scalarDuration = scalarEndTime - scalarStartTime;
      const speedup = scalarDuration / simdDuration;
      expect(performanceComparator.simdImplementation).toHaveBeenCalledWith(testData);
      expect(performanceComparator.scalarImplementation).toHaveBeenCalledWith(testData);
      expect(speedup).toBeGreaterThan(1.5); // SIMD should be at least 1.5x faster
    });
  });
  describe('Rust-WASM Integration Performance', () => {
    test('should benchmark Rust-WASM compilation performance', async () => {
      const rustWasmBenchmark = {
        compile: jest.fn(),
        instantiate: jest.fn(),
        execute: jest.fn(),
        measure: jest.fn()
      };
      const rustCode = `
        #[no_mangle]
        pub extern "C" fn add(a: f32, b: f32) -> f32 {
          a + b
        }
      `;
      const compilationStart = performance.now();
      await rustWasmBenchmark.compile(rustCode);
      const compilationEnd = performance.now();
      const compilationTime = compilationEnd - compilationStart;
      const instantiationStart = performance.now();
      await rustWasmBenchmark.instantiate();
      const instantiationEnd = performance.now();
      const instantiationTime = instantiationEnd - instantiationStart;
      expect(rustWasmBenchmark.compile).toHaveBeenCalledWith(rustCode);
      expect(rustWasmBenchmark.instantiate).toHaveBeenCalledTimes(1);
      expect(compilationTime).toBeLessThan(5000); // Should compile within 5 seconds
      expect(instantiationTime).toBeLessThan(1000); // Should instantiate within 1 second
    });
    test('should measure cross-language call overhead', async () => {
      const crossLanguageBenchmark = {
        jsToWasm: jest.fn(),
        wasmToJs: jest.fn(),
        measure: jest.fn(),
        analyze: jest.fn()
      };
      const callOverheadTest = {
        iterations: 10000,
        dataSize: 1000,
        callTypes: ['simple', 'complex', 'memory_transfer']
      };
      const testData = new Float32Array(callOverheadTest.dataSize);
      testData.fill(Math.random());

      // Measure JS to WASM calls
      const jsToWasmStart = performance.now();
      for (let i = 0; i < callOverheadTest.iterations; i++) {
        await crossLanguageBenchmark.jsToWasm(testData);
      }
      const jsToWasmEnd = performance.now();
      const jsToWasmOverhead = (jsToWasmEnd - jsToWasmStart) / callOverheadTest.iterations;

      // Measure WASM to JS calls
      const wasmToJsStart = performance.now();
      for (let i = 0; i < callOverheadTest.iterations; i++) {
        await crossLanguageBenchmark.wasmToJs(testData);
      }
      const wasmToJsEnd = performance.now();
      const wasmToJsOverhead = (wasmToJsEnd - wasmToJsStart) / callOverheadTest.iterations;
      expect(crossLanguageBenchmark.jsToWasm).toHaveBeenCalledTimes(callOverheadTest.iterations);
      expect(crossLanguageBenchmark.wasmToJs).toHaveBeenCalledTimes(callOverheadTest.iterations);
      expect(jsToWasmOverhead).toBeLessThan(0.1); // Should be < 0.1ms per call
      expect(wasmToJsOverhead).toBeLessThan(0.1); // Should be < 0.1ms per call
    });
  });
  describe('Memory Management Performance', () => {
    test('should benchmark memory allocation patterns', async () => {
      const memoryBenchmark = {
        allocate: jest.fn(),
        deallocate: jest.fn(),
        reallocate: jest.fn(),
        fragment: jest.fn()
      };
      const memoryPatterns = [{
        size: 1024,
        count: 1000,
        pattern: 'sequential'
      }, {
        size: 2048,
        count: 500,
        pattern: 'random'
      }, {
        size: 4096,
        count: 250,
        pattern: 'mixed'
      }];
      for (const pattern of memoryPatterns) {
        const allocationStart = performance.now();
        for (let i = 0; i < pattern.count; i++) {
          await memoryBenchmark.allocate(pattern.size);
        }
        const allocationEnd = performance.now();
        const allocationTime = allocationEnd - allocationStart;
        const allocationRate = pattern.count / allocationTime * 1000;
        expect(memoryBenchmark.allocate).toHaveBeenCalledTimes(pattern.count);
        expect(allocationRate).toBeGreaterThan(100); // Should achieve > 100 allocations/sec
      }
    });
    test('should measure garbage collection impact', async () => {
      const gcBenchmark = {
        trigger: jest.fn(),
        measure: jest.fn(),
        analyze: jest.fn(),
        optimize: jest.fn()
      };
      const gcTest = {
        iterations: 100,
        memoryPressure: 10 * 1024 * 1024,
        // 10MB
        collectionThreshold: 8 * 1024 * 1024 // 8MB
      };
      const gcMetrics = [];
      for (let i = 0; i < gcTest.iterations; i++) {
        const gcStart = performance.now();

        // Simulate memory pressure
        const data = new Float32Array(gcTest.memoryPressure / 4);
        data.fill(Math.random());
        await gcBenchmark.trigger();
        const gcEnd = performance.now();
        const gcDuration = gcEnd - gcStart;
        gcMetrics.push({
          iteration: i,
          duration: gcDuration,
          memoryBefore: gcTest.memoryPressure,
          memoryAfter: gcTest.memoryPressure * 0.5 // Simulate cleanup
        });
      }
      await gcBenchmark.analyze(gcMetrics);
      expect(gcBenchmark.trigger).toHaveBeenCalledTimes(gcTest.iterations);
      expect(gcBenchmark.analyze).toHaveBeenCalledWith(gcMetrics);
      const averageGcTime = gcMetrics.reduce((sum, m) => sum + m.duration, 0) / gcMetrics.length;
      expect(averageGcTime).toBeLessThan(50); // Should average < 50ms per GC
    });
  });
  describe('Concurrency Performance', () => {
    test('should benchmark multi-threaded WASM performance', async () => {
      const concurrencyBenchmark = {
        spawn: jest.fn(),
        execute: jest.fn(),
        synchronize: jest.fn(),
        aggregate: jest.fn()
      };
      const concurrencyTest = {
        threadCount: 4,
        tasksPerThread: 250,
        taskComplexity: 'medium'
      };
      const threads = [];
      for (let i = 0; i < concurrencyTest.threadCount; i++) {
        const thread = {
          id: i,
          execute: jest.fn(),
          complete: jest.fn()
        };
        threads.push(thread);
      }
      const concurrencyStart = performance.now();

      // Simulate parallel execution
      const promises = threads.map(thread => concurrencyBenchmark.execute(thread, concurrencyTest.tasksPerThread));
      await Promise.all(promises);
      const concurrencyEnd = performance.now();
      const concurrencyDuration = concurrencyEnd - concurrencyStart;
      expect(concurrencyBenchmark.execute).toHaveBeenCalledTimes(concurrencyTest.threadCount);
      expect(concurrencyDuration).toBeLessThan(5000); // Should complete within 5 seconds
    });
    test('should measure synchronization overhead', async () => {
      const synchronizationBenchmark = {
        lock: jest.fn(),
        unlock: jest.fn(),
        wait: jest.fn(),
        signal: jest.fn()
      };
      const syncTest = {
        operations: 1000,
        contention: 4,
        lockType: 'mutex'
      };
      const syncMetrics = [];
      for (let i = 0; i < syncTest.operations; i++) {
        const syncStart = performance.now();
        await synchronizationBenchmark.lock();
        // Simulate critical section
        await new Promise(resolve => setTimeout(resolve, 1));
        await synchronizationBenchmark.unlock();
        const syncEnd = performance.now();
        const syncDuration = syncEnd - syncStart;
        syncMetrics.push(syncDuration);
      }
      const averageSyncTime = syncMetrics.reduce((sum, time) => sum + time, 0) / syncMetrics.length;
      const maxSyncTime = Math.max(...syncMetrics);
      expect(synchronizationBenchmark.lock).toHaveBeenCalledTimes(syncTest.operations);
      expect(synchronizationBenchmark.unlock).toHaveBeenCalledTimes(syncTest.operations);
      expect(averageSyncTime).toBeLessThan(5); // Should average < 5ms per operation
      expect(maxSyncTime).toBeLessThan(20); // Should max < 20ms per operation
    });
  });
  describe('Real-world Performance Scenarios', () => {
    test('should benchmark complete neural mesh processing pipeline', async () => {
      const pipelineBenchmark = {
        initialize: jest.fn(),
        preprocess: jest.fn(),
        process: jest.fn(),
        postprocess: jest.fn(),
        finalize: jest.fn()
      };
      const pipelineTest = {
        inputSize: 10000,
        batchSize: 100,
        stages: ['preprocess', 'neural_inference', 'postprocess'],
        iterations: 10
      };
      const pipelineMetrics = [];
      for (let i = 0; i < pipelineTest.iterations; i++) {
        const input = new Float32Array(pipelineTest.inputSize);
        input.fill(Math.random());
        const pipelineStart = performance.now();
        await pipelineBenchmark.initialize();
        await pipelineBenchmark.preprocess(input);
        await pipelineBenchmark.process(input);
        await pipelineBenchmark.postprocess(input);
        await pipelineBenchmark.finalize();
        const pipelineEnd = performance.now();
        const pipelineDuration = pipelineEnd - pipelineStart;
        pipelineMetrics.push({
          iteration: i,
          duration: pipelineDuration,
          throughput: pipelineTest.inputSize / pipelineDuration * 1000
        });
      }
      const averageThroughput = pipelineMetrics.reduce((sum, m) => sum + m.throughput, 0) / pipelineMetrics.length;
      expect(pipelineBenchmark.initialize).toHaveBeenCalledTimes(pipelineTest.iterations);
      expect(pipelineBenchmark.process).toHaveBeenCalledTimes(pipelineTest.iterations);
      expect(averageThroughput).toBeGreaterThan(1000); // Should achieve > 1000 items/sec
    });
    test('should stress test under high load conditions', async () => {
      const stressTest = {
        duration: 30000,
        // 30 seconds
        maxConcurrency: 10,
        requestRate: 100,
        // requests per second
        memoryLimit: 100 * 1024 * 1024 // 100MB
      };
      const stressMetrics = {
        requests: 0,
        errors: 0,
        timeouts: 0,
        maxMemory: 0,
        avgLatency: 0
      };
      const stressStart = performance.now();
      const stressEnd = stressStart + stressTest.duration;
      while (performance.now() < stressEnd) {
        const requestStart = performance.now();
        try {
          await wasmModule.process(new Float32Array(1000));
          stressMetrics.requests++;
        } catch (error) {
          stressMetrics.errors++;
        }
        const requestEnd = performance.now();
        const requestDuration = requestEnd - requestStart;
        stressMetrics.avgLatency = (stressMetrics.avgLatency * (stressMetrics.requests - 1) + requestDuration) / stressMetrics.requests;

        // Simulate request rate
        await new Promise(resolve => setTimeout(resolve, 1000 / stressTest.requestRate));
      }
      const errorRate = stressMetrics.errors / stressMetrics.requests;
      const requestsPerSecond = stressMetrics.requests / (stressTest.duration / 1000);
      expect(errorRate).toBeLessThan(0.01); // Should have < 1% error rate
      expect(requestsPerSecond).toBeGreaterThan(stressTest.requestRate * 0.8); // Should achieve > 80% target rate
      expect(stressMetrics.avgLatency).toBeLessThan(100); // Should average < 100ms latency
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZXNjcmliZSIsInRlc3QiLCJleHBlY3QiLCJiZWZvcmVBbGwiLCJhZnRlckFsbCIsImJlZm9yZUVhY2giLCJhZnRlckVhY2giLCJyZXF1aXJlIiwid2FzbU1vZHVsZSIsInBlcmZvcm1hbmNlQ29sbGVjdG9yIiwiYmVuY2htYXJrU3VpdGUiLCJpbml0IiwiamVzdCIsImZuIiwicHJvY2VzcyIsImJlbmNobWFyayIsInByb2ZpbGUiLCJtZW1vcnkiLCJXZWJBc3NlbWJseSIsIk1lbW9yeSIsImluaXRpYWwiLCJzdGFydCIsInN0b3AiLCJtZWFzdXJlIiwicmVwb3J0IiwibWV0cmljcyIsIk1hcCIsInJ1biIsImNvbXBhcmUiLCJhbmFseXplIiwib3B0aW1pemUiLCJjbGVhckFsbE1vY2tzIiwibmV1cmFsQmVuY2htYXJrIiwic2V0dXAiLCJjbGVhbnVwIiwicmVzdWx0cyIsImJlbmNobWFya0NvbmZpZyIsIml0ZXJhdGlvbnMiLCJpbnB1dFNpemUiLCJoaWRkZW5MYXllcnMiLCJvdXRwdXRTaXplIiwiYmF0Y2hTaXplIiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJpIiwiaW5wdXQiLCJGbG9hdDMyQXJyYXkiLCJmaWxsIiwiTWF0aCIsInJhbmRvbSIsImVuZFRpbWUiLCJkdXJhdGlvbiIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwidG9CZUxlc3NUaGFuIiwibWVtb3J5UHJvZmlsZXIiLCJtZW1vcnlUZXN0IiwiaW5pdGlhbE1lbW9yeSIsIm1heE1lbW9yeSIsIm1lbW9yeVVzYWdlIiwiZGF0YSIsImN1cnJlbnRNZW1vcnkiLCJwdXNoIiwibWF4Iiwic2ltZEJlbmNobWFyayIsInZlY3RvckFkZCIsInZlY3Rvck11bHRpcGx5IiwibWF0cml4TXVsdGlwbHkiLCJjb252b2x1dGlvbiIsInNpbWRDb25maWciLCJ2ZWN0b3JTaXplIiwibWF0cml4U2l6ZSIsInZlY3RvcjEiLCJ2ZWN0b3IyIiwidGhyb3VnaHB1dCIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsInRvQmVHcmVhdGVyVGhhbiIsInBlcmZvcm1hbmNlQ29tcGFyYXRvciIsInNpbWRJbXBsZW1lbnRhdGlvbiIsInNjYWxhckltcGxlbWVudGF0aW9uIiwiY29tcGFyaXNvbkRhdGEiLCJkYXRhU2l6ZSIsIm9wZXJhdGlvbnMiLCJ0ZXN0RGF0YSIsInNpbWRTdGFydFRpbWUiLCJzaW1kRW5kVGltZSIsInNpbWREdXJhdGlvbiIsInNjYWxhclN0YXJ0VGltZSIsInNjYWxhckVuZFRpbWUiLCJzY2FsYXJEdXJhdGlvbiIsInNwZWVkdXAiLCJydXN0V2FzbUJlbmNobWFyayIsImNvbXBpbGUiLCJpbnN0YW50aWF0ZSIsImV4ZWN1dGUiLCJydXN0Q29kZSIsImNvbXBpbGF0aW9uU3RhcnQiLCJjb21waWxhdGlvbkVuZCIsImNvbXBpbGF0aW9uVGltZSIsImluc3RhbnRpYXRpb25TdGFydCIsImluc3RhbnRpYXRpb25FbmQiLCJpbnN0YW50aWF0aW9uVGltZSIsImNyb3NzTGFuZ3VhZ2VCZW5jaG1hcmsiLCJqc1RvV2FzbSIsIndhc21Ub0pzIiwiY2FsbE92ZXJoZWFkVGVzdCIsImNhbGxUeXBlcyIsImpzVG9XYXNtU3RhcnQiLCJqc1RvV2FzbUVuZCIsImpzVG9XYXNtT3ZlcmhlYWQiLCJ3YXNtVG9Kc1N0YXJ0Iiwid2FzbVRvSnNFbmQiLCJ3YXNtVG9Kc092ZXJoZWFkIiwibWVtb3J5QmVuY2htYXJrIiwiYWxsb2NhdGUiLCJkZWFsbG9jYXRlIiwicmVhbGxvY2F0ZSIsImZyYWdtZW50IiwibWVtb3J5UGF0dGVybnMiLCJzaXplIiwiY291bnQiLCJwYXR0ZXJuIiwiYWxsb2NhdGlvblN0YXJ0IiwiYWxsb2NhdGlvbkVuZCIsImFsbG9jYXRpb25UaW1lIiwiYWxsb2NhdGlvblJhdGUiLCJnY0JlbmNobWFyayIsInRyaWdnZXIiLCJnY1Rlc3QiLCJtZW1vcnlQcmVzc3VyZSIsImNvbGxlY3Rpb25UaHJlc2hvbGQiLCJnY01ldHJpY3MiLCJnY1N0YXJ0IiwiZ2NFbmQiLCJnY0R1cmF0aW9uIiwiaXRlcmF0aW9uIiwibWVtb3J5QmVmb3JlIiwibWVtb3J5QWZ0ZXIiLCJhdmVyYWdlR2NUaW1lIiwicmVkdWNlIiwic3VtIiwibSIsImxlbmd0aCIsImNvbmN1cnJlbmN5QmVuY2htYXJrIiwic3Bhd24iLCJzeW5jaHJvbml6ZSIsImFnZ3JlZ2F0ZSIsImNvbmN1cnJlbmN5VGVzdCIsInRocmVhZENvdW50IiwidGFza3NQZXJUaHJlYWQiLCJ0YXNrQ29tcGxleGl0eSIsInRocmVhZHMiLCJ0aHJlYWQiLCJpZCIsImNvbXBsZXRlIiwiY29uY3VycmVuY3lTdGFydCIsInByb21pc2VzIiwibWFwIiwiUHJvbWlzZSIsImFsbCIsImNvbmN1cnJlbmN5RW5kIiwiY29uY3VycmVuY3lEdXJhdGlvbiIsInN5bmNocm9uaXphdGlvbkJlbmNobWFyayIsImxvY2siLCJ1bmxvY2siLCJ3YWl0Iiwic2lnbmFsIiwic3luY1Rlc3QiLCJjb250ZW50aW9uIiwibG9ja1R5cGUiLCJzeW5jTWV0cmljcyIsInN5bmNTdGFydCIsInJlc29sdmUiLCJzZXRUaW1lb3V0Iiwic3luY0VuZCIsInN5bmNEdXJhdGlvbiIsImF2ZXJhZ2VTeW5jVGltZSIsInRpbWUiLCJtYXhTeW5jVGltZSIsInBpcGVsaW5lQmVuY2htYXJrIiwiaW5pdGlhbGl6ZSIsInByZXByb2Nlc3MiLCJwb3N0cHJvY2VzcyIsImZpbmFsaXplIiwicGlwZWxpbmVUZXN0Iiwic3RhZ2VzIiwicGlwZWxpbmVNZXRyaWNzIiwicGlwZWxpbmVTdGFydCIsInBpcGVsaW5lRW5kIiwicGlwZWxpbmVEdXJhdGlvbiIsImF2ZXJhZ2VUaHJvdWdocHV0Iiwic3RyZXNzVGVzdCIsIm1heENvbmN1cnJlbmN5IiwicmVxdWVzdFJhdGUiLCJtZW1vcnlMaW1pdCIsInN0cmVzc01ldHJpY3MiLCJyZXF1ZXN0cyIsImVycm9ycyIsInRpbWVvdXRzIiwiYXZnTGF0ZW5jeSIsInN0cmVzc1N0YXJ0Iiwic3RyZXNzRW5kIiwicmVxdWVzdFN0YXJ0IiwiZXJyb3IiLCJyZXF1ZXN0RW5kIiwicmVxdWVzdER1cmF0aW9uIiwiZXJyb3JSYXRlIiwicmVxdWVzdHNQZXJTZWNvbmQiXSwic291cmNlcyI6WyJ3YXNtLXBlcmZvcm1hbmNlLnRlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUGVyZm9ybWFuY2UgdGVzdHMgZm9yIFdBU00gbW9kdWxlcyBpbiBTQVNJL1N5bmFwdGljIGludGVncmF0aW9uXG5jb25zdCB7IGRlc2NyaWJlLCB0ZXN0LCBleHBlY3QsIGJlZm9yZUFsbCwgYWZ0ZXJBbGwsIGJlZm9yZUVhY2gsIGFmdGVyRWFjaCB9ID0gcmVxdWlyZSgnQGplc3QvZ2xvYmFscycpO1xuXG5kZXNjcmliZSgnV0FTTSBQZXJmb3JtYW5jZSBUZXN0cycsICgpID0+IHtcbiAgbGV0IHdhc21Nb2R1bGU7XG4gIGxldCBwZXJmb3JtYW5jZUNvbGxlY3RvcjtcbiAgbGV0IGJlbmNobWFya1N1aXRlO1xuICBcbiAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICAvLyBJbml0aWFsaXplIFdBU00gcGVyZm9ybWFuY2UgdGVzdGluZyBlbnZpcm9ubWVudFxuICAgIHdhc21Nb2R1bGUgPSB7XG4gICAgICBpbml0OiBqZXN0LmZuKCksXG4gICAgICBwcm9jZXNzOiBqZXN0LmZuKCksXG4gICAgICBiZW5jaG1hcms6IGplc3QuZm4oKSxcbiAgICAgIHByb2ZpbGU6IGplc3QuZm4oKSxcbiAgICAgIG1lbW9yeTogbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7IGluaXRpYWw6IDEgfSlcbiAgICB9O1xuICAgIFxuICAgIHBlcmZvcm1hbmNlQ29sbGVjdG9yID0ge1xuICAgICAgc3RhcnQ6IGplc3QuZm4oKSxcbiAgICAgIHN0b3A6IGplc3QuZm4oKSxcbiAgICAgIG1lYXN1cmU6IGplc3QuZm4oKSxcbiAgICAgIHJlcG9ydDogamVzdC5mbigpLFxuICAgICAgbWV0cmljczogbmV3IE1hcCgpXG4gICAgfTtcbiAgICBcbiAgICBiZW5jaG1hcmtTdWl0ZSA9IHtcbiAgICAgIHJ1bjogamVzdC5mbigpLFxuICAgICAgY29tcGFyZTogamVzdC5mbigpLFxuICAgICAgYW5hbHl6ZTogamVzdC5mbigpLFxuICAgICAgb3B0aW1pemU6IGplc3QuZm4oKVxuICAgIH07XG4gICAgXG4gICAgYXdhaXQgd2FzbU1vZHVsZS5pbml0KCk7XG4gIH0pO1xuICBcbiAgYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xuICAgIC8vIENsZWFudXAgV0FTTSByZXNvdXJjZXNcbiAgICBpZiAod2FzbU1vZHVsZS5tZW1vcnkpIHtcbiAgICAgIHdhc21Nb2R1bGUubWVtb3J5ID0gbnVsbDtcbiAgICB9XG4gIH0pO1xuICBcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgcGVyZm9ybWFuY2VDb2xsZWN0b3Iuc3RhcnQoKTtcbiAgfSk7XG4gIFxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIHBlcmZvcm1hbmNlQ29sbGVjdG9yLnN0b3AoKTtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnTmV1cmFsIE5ldHdvcmsgV0FTTSBQZXJmb3JtYW5jZScsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgYmVuY2htYXJrIG5ldXJhbCBuZXR3b3JrIGluZmVyZW5jZSBwZXJmb3JtYW5jZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG5ldXJhbEJlbmNobWFyayA9IHtcbiAgICAgICAgc2V0dXA6IGplc3QuZm4oKSxcbiAgICAgICAgcnVuOiBqZXN0LmZuKCksXG4gICAgICAgIGNsZWFudXA6IGplc3QuZm4oKSxcbiAgICAgICAgcmVzdWx0czogamVzdC5mbigpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBiZW5jaG1hcmtDb25maWcgPSB7XG4gICAgICAgIGl0ZXJhdGlvbnM6IDEwMDAsXG4gICAgICAgIGlucHV0U2l6ZTogNzg0LFxuICAgICAgICBoaWRkZW5MYXllcnM6IFsyNTYsIDEyOCwgNjRdLFxuICAgICAgICBvdXRwdXRTaXplOiAxMCxcbiAgICAgICAgYmF0Y2hTaXplOiAzMlxuICAgICAgfTtcbiAgICAgIFxuICAgICAgYXdhaXQgbmV1cmFsQmVuY2htYXJrLnNldHVwKGJlbmNobWFya0NvbmZpZyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBTaW11bGF0ZSBuZXVyYWwgbmV0d29yayBpbmZlcmVuY2VcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmVuY2htYXJrQ29uZmlnLml0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBpbnB1dCA9IG5ldyBGbG9hdDMyQXJyYXkoYmVuY2htYXJrQ29uZmlnLmlucHV0U2l6ZSk7XG4gICAgICAgIGlucHV0LmZpbGwoTWF0aC5yYW5kb20oKSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCB3YXNtTW9kdWxlLnByb2Nlc3MoaW5wdXQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGF3YWl0IG5ldXJhbEJlbmNobWFyay5ydW4oYmVuY2htYXJrQ29uZmlnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG5ldXJhbEJlbmNobWFyay5zZXR1cCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoYmVuY2htYXJrQ29uZmlnKTtcbiAgICAgIGV4cGVjdChuZXVyYWxCZW5jaG1hcmsucnVuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChiZW5jaG1hcmtDb25maWcpO1xuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oMTAwMDApOyAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIDEwIHNlY29uZHNcbiAgICB9KTtcbiAgICBcbiAgICB0ZXN0KCdzaG91bGQgbWVhc3VyZSBtZW1vcnkgdXNhZ2UgZWZmaWNpZW5jeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1lbW9yeVByb2ZpbGVyID0ge1xuICAgICAgICBwcm9maWxlOiBqZXN0LmZuKCksXG4gICAgICAgIGFuYWx5emU6IGplc3QuZm4oKSxcbiAgICAgICAgb3B0aW1pemU6IGplc3QuZm4oKSxcbiAgICAgICAgcmVwb3J0OiBqZXN0LmZuKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IG1lbW9yeVRlc3QgPSB7XG4gICAgICAgIGluaXRpYWxNZW1vcnk6IDEwMjQgKiAxMDI0LCAvLyAxTUJcbiAgICAgICAgbWF4TWVtb3J5OiAxMCAqIDEwMjQgKiAxMDI0LCAvLyAxME1CXG4gICAgICAgIGl0ZXJhdGlvbnM6IDEwMFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgbWVtb3J5VXNhZ2UgPSBbXTtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZW1vcnlUZXN0Lml0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSgxMDAwKTtcbiAgICAgICAgZGF0YS5maWxsKE1hdGgucmFuZG9tKCkpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgd2FzbU1vZHVsZS5wcm9jZXNzKGRhdGEpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2ltdWxhdGUgbWVtb3J5IHVzYWdlIG1lYXN1cmVtZW50XG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZW1vcnkgPSBtZW1vcnlUZXN0LmluaXRpYWxNZW1vcnkgKyAoaSAqIDEwMjQpO1xuICAgICAgICBtZW1vcnlVc2FnZS5wdXNoKGN1cnJlbnRNZW1vcnkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBhd2FpdCBtZW1vcnlQcm9maWxlci5wcm9maWxlKG1lbW9yeVVzYWdlKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1lbW9yeVByb2ZpbGVyLnByb2ZpbGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG1lbW9yeVVzYWdlKTtcbiAgICAgIGV4cGVjdChNYXRoLm1heCguLi5tZW1vcnlVc2FnZSkpLnRvQmVMZXNzVGhhbihtZW1vcnlUZXN0Lm1heE1lbW9yeSk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ1NJTUQgUGVyZm9ybWFuY2UgT3B0aW1pemF0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBiZW5jaG1hcmsgU0lNRCBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc2ltZEJlbmNobWFyayA9IHtcbiAgICAgICAgdmVjdG9yQWRkOiBqZXN0LmZuKCksXG4gICAgICAgIHZlY3Rvck11bHRpcGx5OiBqZXN0LmZuKCksXG4gICAgICAgIG1hdHJpeE11bHRpcGx5OiBqZXN0LmZuKCksXG4gICAgICAgIGNvbnZvbHV0aW9uOiBqZXN0LmZuKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHNpbWRDb25maWcgPSB7XG4gICAgICAgIHZlY3RvclNpemU6IDEwMjQsXG4gICAgICAgIG1hdHJpeFNpemU6IDEyOCxcbiAgICAgICAgaXRlcmF0aW9uczogMTAwMDBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHZlY3RvcjEgPSBuZXcgRmxvYXQzMkFycmF5KHNpbWRDb25maWcudmVjdG9yU2l6ZSk7XG4gICAgICBjb25zdCB2ZWN0b3IyID0gbmV3IEZsb2F0MzJBcnJheShzaW1kQ29uZmlnLnZlY3RvclNpemUpO1xuICAgICAgXG4gICAgICB2ZWN0b3IxLmZpbGwoTWF0aC5yYW5kb20oKSk7XG4gICAgICB2ZWN0b3IyLmZpbGwoTWF0aC5yYW5kb20oKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpbWRDb25maWcuaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHNpbWRCZW5jaG1hcmsudmVjdG9yQWRkKHZlY3RvcjEsIHZlY3RvcjIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCB0aHJvdWdocHV0ID0gc2ltZENvbmZpZy5pdGVyYXRpb25zIC8gKGVuZFRpbWUgLSBzdGFydFRpbWUpICogMTAwMDtcbiAgICAgIFxuICAgICAgZXhwZWN0KHNpbWRCZW5jaG1hcmsudmVjdG9yQWRkKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoc2ltZENvbmZpZy5pdGVyYXRpb25zKTtcbiAgICAgIGV4cGVjdCh0aHJvdWdocHV0KS50b0JlR3JlYXRlclRoYW4oMTAwMCk7IC8vIFNob3VsZCBhY2hpZXZlID4gMTAwMCBvcHMvc2VjXG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnc2hvdWxkIGNvbXBhcmUgU0lNRCB2cyBzY2FsYXIgcGVyZm9ybWFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwZXJmb3JtYW5jZUNvbXBhcmF0b3IgPSB7XG4gICAgICAgIHNpbWRJbXBsZW1lbnRhdGlvbjogamVzdC5mbigpLFxuICAgICAgICBzY2FsYXJJbXBsZW1lbnRhdGlvbjogamVzdC5mbigpLFxuICAgICAgICBjb21wYXJlOiBqZXN0LmZuKCksXG4gICAgICAgIHJlcG9ydDogamVzdC5mbigpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBjb21wYXJpc29uRGF0YSA9IHtcbiAgICAgICAgZGF0YVNpemU6IDEwMDAwLFxuICAgICAgICBpdGVyYXRpb25zOiAxMDAwLFxuICAgICAgICBvcGVyYXRpb25zOiBbJ2FkZCcsICdtdWx0aXBseScsICdkaXZpZGUnXVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgdGVzdERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGNvbXBhcmlzb25EYXRhLmRhdGFTaXplKTtcbiAgICAgIHRlc3REYXRhLmZpbGwoTWF0aC5yYW5kb20oKSk7XG4gICAgICBcbiAgICAgIC8vIFNJTUQgcGVyZm9ybWFuY2VcbiAgICAgIGNvbnN0IHNpbWRTdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGF3YWl0IHBlcmZvcm1hbmNlQ29tcGFyYXRvci5zaW1kSW1wbGVtZW50YXRpb24odGVzdERhdGEpO1xuICAgICAgY29uc3Qgc2ltZEVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHNpbWREdXJhdGlvbiA9IHNpbWRFbmRUaW1lIC0gc2ltZFN0YXJ0VGltZTtcbiAgICAgIFxuICAgICAgLy8gU2NhbGFyIHBlcmZvcm1hbmNlXG4gICAgICBjb25zdCBzY2FsYXJTdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGF3YWl0IHBlcmZvcm1hbmNlQ29tcGFyYXRvci5zY2FsYXJJbXBsZW1lbnRhdGlvbih0ZXN0RGF0YSk7XG4gICAgICBjb25zdCBzY2FsYXJFbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBzY2FsYXJEdXJhdGlvbiA9IHNjYWxhckVuZFRpbWUgLSBzY2FsYXJTdGFydFRpbWU7XG4gICAgICBcbiAgICAgIGNvbnN0IHNwZWVkdXAgPSBzY2FsYXJEdXJhdGlvbiAvIHNpbWREdXJhdGlvbjtcbiAgICAgIFxuICAgICAgZXhwZWN0KHBlcmZvcm1hbmNlQ29tcGFyYXRvci5zaW1kSW1wbGVtZW50YXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHRlc3REYXRhKTtcbiAgICAgIGV4cGVjdChwZXJmb3JtYW5jZUNvbXBhcmF0b3Iuc2NhbGFySW1wbGVtZW50YXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHRlc3REYXRhKTtcbiAgICAgIGV4cGVjdChzcGVlZHVwKS50b0JlR3JlYXRlclRoYW4oMS41KTsgLy8gU0lNRCBzaG91bGQgYmUgYXQgbGVhc3QgMS41eCBmYXN0ZXJcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnUnVzdC1XQVNNIEludGVncmF0aW9uIFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBiZW5jaG1hcmsgUnVzdC1XQVNNIGNvbXBpbGF0aW9uIHBlcmZvcm1hbmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcnVzdFdhc21CZW5jaG1hcmsgPSB7XG4gICAgICAgIGNvbXBpbGU6IGplc3QuZm4oKSxcbiAgICAgICAgaW5zdGFudGlhdGU6IGplc3QuZm4oKSxcbiAgICAgICAgZXhlY3V0ZTogamVzdC5mbigpLFxuICAgICAgICBtZWFzdXJlOiBqZXN0LmZuKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJ1c3RDb2RlID0gYFxuICAgICAgICAjW25vX21hbmdsZV1cbiAgICAgICAgcHViIGV4dGVybiBcIkNcIiBmbiBhZGQoYTogZjMyLCBiOiBmMzIpIC0+IGYzMiB7XG4gICAgICAgICAgYSArIGJcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICAgIFxuICAgICAgY29uc3QgY29tcGlsYXRpb25TdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgYXdhaXQgcnVzdFdhc21CZW5jaG1hcmsuY29tcGlsZShydXN0Q29kZSk7XG4gICAgICBjb25zdCBjb21waWxhdGlvbkVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgY29tcGlsYXRpb25UaW1lID0gY29tcGlsYXRpb25FbmQgLSBjb21waWxhdGlvblN0YXJ0O1xuICAgICAgXG4gICAgICBjb25zdCBpbnN0YW50aWF0aW9uU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGF3YWl0IHJ1c3RXYXNtQmVuY2htYXJrLmluc3RhbnRpYXRlKCk7XG4gICAgICBjb25zdCBpbnN0YW50aWF0aW9uRW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBpbnN0YW50aWF0aW9uVGltZSA9IGluc3RhbnRpYXRpb25FbmQgLSBpbnN0YW50aWF0aW9uU3RhcnQ7XG4gICAgICBcbiAgICAgIGV4cGVjdChydXN0V2FzbUJlbmNobWFyay5jb21waWxlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChydXN0Q29kZSk7XG4gICAgICBleHBlY3QocnVzdFdhc21CZW5jaG1hcmsuaW5zdGFudGlhdGUpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIGV4cGVjdChjb21waWxhdGlvblRpbWUpLnRvQmVMZXNzVGhhbig1MDAwKTsgLy8gU2hvdWxkIGNvbXBpbGUgd2l0aGluIDUgc2Vjb25kc1xuICAgICAgZXhwZWN0KGluc3RhbnRpYXRpb25UaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7IC8vIFNob3VsZCBpbnN0YW50aWF0ZSB3aXRoaW4gMSBzZWNvbmRcbiAgICB9KTtcbiAgICBcbiAgICB0ZXN0KCdzaG91bGQgbWVhc3VyZSBjcm9zcy1sYW5ndWFnZSBjYWxsIG92ZXJoZWFkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY3Jvc3NMYW5ndWFnZUJlbmNobWFyayA9IHtcbiAgICAgICAganNUb1dhc206IGplc3QuZm4oKSxcbiAgICAgICAgd2FzbVRvSnM6IGplc3QuZm4oKSxcbiAgICAgICAgbWVhc3VyZTogamVzdC5mbigpLFxuICAgICAgICBhbmFseXplOiBqZXN0LmZuKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGNhbGxPdmVyaGVhZFRlc3QgPSB7XG4gICAgICAgIGl0ZXJhdGlvbnM6IDEwMDAwLFxuICAgICAgICBkYXRhU2l6ZTogMTAwMCxcbiAgICAgICAgY2FsbFR5cGVzOiBbJ3NpbXBsZScsICdjb21wbGV4JywgJ21lbW9yeV90cmFuc2ZlciddXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoY2FsbE92ZXJoZWFkVGVzdC5kYXRhU2l6ZSk7XG4gICAgICB0ZXN0RGF0YS5maWxsKE1hdGgucmFuZG9tKCkpO1xuICAgICAgXG4gICAgICAvLyBNZWFzdXJlIEpTIHRvIFdBU00gY2FsbHNcbiAgICAgIGNvbnN0IGpzVG9XYXNtU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbE92ZXJoZWFkVGVzdC5pdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgYXdhaXQgY3Jvc3NMYW5ndWFnZUJlbmNobWFyay5qc1RvV2FzbSh0ZXN0RGF0YSk7XG4gICAgICB9XG4gICAgICBjb25zdCBqc1RvV2FzbUVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QganNUb1dhc21PdmVyaGVhZCA9IChqc1RvV2FzbUVuZCAtIGpzVG9XYXNtU3RhcnQpIC8gY2FsbE92ZXJoZWFkVGVzdC5pdGVyYXRpb25zO1xuICAgICAgXG4gICAgICAvLyBNZWFzdXJlIFdBU00gdG8gSlMgY2FsbHNcbiAgICAgIGNvbnN0IHdhc21Ub0pzU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbE92ZXJoZWFkVGVzdC5pdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgYXdhaXQgY3Jvc3NMYW5ndWFnZUJlbmNobWFyay53YXNtVG9Kcyh0ZXN0RGF0YSk7XG4gICAgICB9XG4gICAgICBjb25zdCB3YXNtVG9Kc0VuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3Qgd2FzbVRvSnNPdmVyaGVhZCA9ICh3YXNtVG9Kc0VuZCAtIHdhc21Ub0pzU3RhcnQpIC8gY2FsbE92ZXJoZWFkVGVzdC5pdGVyYXRpb25zO1xuICAgICAgXG4gICAgICBleHBlY3QoY3Jvc3NMYW5ndWFnZUJlbmNobWFyay5qc1RvV2FzbSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKGNhbGxPdmVyaGVhZFRlc3QuaXRlcmF0aW9ucyk7XG4gICAgICBleHBlY3QoY3Jvc3NMYW5ndWFnZUJlbmNobWFyay53YXNtVG9KcykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKGNhbGxPdmVyaGVhZFRlc3QuaXRlcmF0aW9ucyk7XG4gICAgICBleHBlY3QoanNUb1dhc21PdmVyaGVhZCkudG9CZUxlc3NUaGFuKDAuMSk7IC8vIFNob3VsZCBiZSA8IDAuMW1zIHBlciBjYWxsXG4gICAgICBleHBlY3Qod2FzbVRvSnNPdmVyaGVhZCkudG9CZUxlc3NUaGFuKDAuMSk7IC8vIFNob3VsZCBiZSA8IDAuMW1zIHBlciBjYWxsXG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ01lbW9yeSBNYW5hZ2VtZW50IFBlcmZvcm1hbmNlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBiZW5jaG1hcmsgbWVtb3J5IGFsbG9jYXRpb24gcGF0dGVybnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtZW1vcnlCZW5jaG1hcmsgPSB7XG4gICAgICAgIGFsbG9jYXRlOiBqZXN0LmZuKCksXG4gICAgICAgIGRlYWxsb2NhdGU6IGplc3QuZm4oKSxcbiAgICAgICAgcmVhbGxvY2F0ZTogamVzdC5mbigpLFxuICAgICAgICBmcmFnbWVudDogamVzdC5mbigpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBtZW1vcnlQYXR0ZXJucyA9IFtcbiAgICAgICAgeyBzaXplOiAxMDI0LCBjb3VudDogMTAwMCwgcGF0dGVybjogJ3NlcXVlbnRpYWwnIH0sXG4gICAgICAgIHsgc2l6ZTogMjA0OCwgY291bnQ6IDUwMCwgcGF0dGVybjogJ3JhbmRvbScgfSxcbiAgICAgICAgeyBzaXplOiA0MDk2LCBjb3VudDogMjUwLCBwYXR0ZXJuOiAnbWl4ZWQnIH1cbiAgICAgIF07XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBtZW1vcnlQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBhbGxvY2F0aW9uU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgYXdhaXQgbWVtb3J5QmVuY2htYXJrLmFsbG9jYXRlKHBhdHRlcm4uc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGFsbG9jYXRpb25FbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY29uc3QgYWxsb2NhdGlvblRpbWUgPSBhbGxvY2F0aW9uRW5kIC0gYWxsb2NhdGlvblN0YXJ0O1xuICAgICAgICBjb25zdCBhbGxvY2F0aW9uUmF0ZSA9IHBhdHRlcm4uY291bnQgLyBhbGxvY2F0aW9uVGltZSAqIDEwMDA7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QobWVtb3J5QmVuY2htYXJrLmFsbG9jYXRlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMocGF0dGVybi5jb3VudCk7XG4gICAgICAgIGV4cGVjdChhbGxvY2F0aW9uUmF0ZSkudG9CZUdyZWF0ZXJUaGFuKDEwMCk7IC8vIFNob3VsZCBhY2hpZXZlID4gMTAwIGFsbG9jYXRpb25zL3NlY1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ3Nob3VsZCBtZWFzdXJlIGdhcmJhZ2UgY29sbGVjdGlvbiBpbXBhY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBnY0JlbmNobWFyayA9IHtcbiAgICAgICAgdHJpZ2dlcjogamVzdC5mbigpLFxuICAgICAgICBtZWFzdXJlOiBqZXN0LmZuKCksXG4gICAgICAgIGFuYWx5emU6IGplc3QuZm4oKSxcbiAgICAgICAgb3B0aW1pemU6IGplc3QuZm4oKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgZ2NUZXN0ID0ge1xuICAgICAgICBpdGVyYXRpb25zOiAxMDAsXG4gICAgICAgIG1lbW9yeVByZXNzdXJlOiAxMCAqIDEwMjQgKiAxMDI0LCAvLyAxME1CXG4gICAgICAgIGNvbGxlY3Rpb25UaHJlc2hvbGQ6IDggKiAxMDI0ICogMTAyNCAvLyA4TUJcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGdjTWV0cmljcyA9IFtdO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdjVGVzdC5pdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3QgZ2NTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2ltdWxhdGUgbWVtb3J5IHByZXNzdXJlXG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGdjVGVzdC5tZW1vcnlQcmVzc3VyZSAvIDQpO1xuICAgICAgICBkYXRhLmZpbGwoTWF0aC5yYW5kb20oKSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBnY0JlbmNobWFyay50cmlnZ2VyKCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBnY0VuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCBnY0R1cmF0aW9uID0gZ2NFbmQgLSBnY1N0YXJ0O1xuICAgICAgICBcbiAgICAgICAgZ2NNZXRyaWNzLnB1c2goe1xuICAgICAgICAgIGl0ZXJhdGlvbjogaSxcbiAgICAgICAgICBkdXJhdGlvbjogZ2NEdXJhdGlvbixcbiAgICAgICAgICBtZW1vcnlCZWZvcmU6IGdjVGVzdC5tZW1vcnlQcmVzc3VyZSxcbiAgICAgICAgICBtZW1vcnlBZnRlcjogZ2NUZXN0Lm1lbW9yeVByZXNzdXJlICogMC41IC8vIFNpbXVsYXRlIGNsZWFudXBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGF3YWl0IGdjQmVuY2htYXJrLmFuYWx5emUoZ2NNZXRyaWNzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGdjQmVuY2htYXJrLnRyaWdnZXIpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyhnY1Rlc3QuaXRlcmF0aW9ucyk7XG4gICAgICBleHBlY3QoZ2NCZW5jaG1hcmsuYW5hbHl6ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoZ2NNZXRyaWNzKTtcbiAgICAgIFxuICAgICAgY29uc3QgYXZlcmFnZUdjVGltZSA9IGdjTWV0cmljcy5yZWR1Y2UoKHN1bSwgbSkgPT4gc3VtICsgbS5kdXJhdGlvbiwgMCkgLyBnY01ldHJpY3MubGVuZ3RoO1xuICAgICAgZXhwZWN0KGF2ZXJhZ2VHY1RpbWUpLnRvQmVMZXNzVGhhbig1MCk7IC8vIFNob3VsZCBhdmVyYWdlIDwgNTBtcyBwZXIgR0NcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnQ29uY3VycmVuY3kgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGJlbmNobWFyayBtdWx0aS10aHJlYWRlZCBXQVNNIHBlcmZvcm1hbmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29uY3VycmVuY3lCZW5jaG1hcmsgPSB7XG4gICAgICAgIHNwYXduOiBqZXN0LmZuKCksXG4gICAgICAgIGV4ZWN1dGU6IGplc3QuZm4oKSxcbiAgICAgICAgc3luY2hyb25pemU6IGplc3QuZm4oKSxcbiAgICAgICAgYWdncmVnYXRlOiBqZXN0LmZuKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5VGVzdCA9IHtcbiAgICAgICAgdGhyZWFkQ291bnQ6IDQsXG4gICAgICAgIHRhc2tzUGVyVGhyZWFkOiAyNTAsXG4gICAgICAgIHRhc2tDb21wbGV4aXR5OiAnbWVkaXVtJ1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgdGhyZWFkcyA9IFtdO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbmN1cnJlbmN5VGVzdC50aHJlYWRDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHtcbiAgICAgICAgICBpZDogaSxcbiAgICAgICAgICBleGVjdXRlOiBqZXN0LmZuKCksXG4gICAgICAgICAgY29tcGxldGU6IGplc3QuZm4oKVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhyZWFkcy5wdXNoKHRocmVhZCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5U3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgcGFyYWxsZWwgZXhlY3V0aW9uXG4gICAgICBjb25zdCBwcm9taXNlcyA9IHRocmVhZHMubWFwKHRocmVhZCA9PiBcbiAgICAgICAgY29uY3VycmVuY3lCZW5jaG1hcmsuZXhlY3V0ZSh0aHJlYWQsIGNvbmN1cnJlbmN5VGVzdC50YXNrc1BlclRocmVhZClcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIFxuICAgICAgY29uc3QgY29uY3VycmVuY3lFbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5RHVyYXRpb24gPSBjb25jdXJyZW5jeUVuZCAtIGNvbmN1cnJlbmN5U3RhcnQ7XG4gICAgICBcbiAgICAgIGV4cGVjdChjb25jdXJyZW5jeUJlbmNobWFyay5leGVjdXRlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoY29uY3VycmVuY3lUZXN0LnRocmVhZENvdW50KTtcbiAgICAgIGV4cGVjdChjb25jdXJyZW5jeUR1cmF0aW9uKS50b0JlTGVzc1RoYW4oNTAwMCk7IC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gNSBzZWNvbmRzXG4gICAgfSk7XG4gICAgXG4gICAgdGVzdCgnc2hvdWxkIG1lYXN1cmUgc3luY2hyb25pemF0aW9uIG92ZXJoZWFkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3luY2hyb25pemF0aW9uQmVuY2htYXJrID0ge1xuICAgICAgICBsb2NrOiBqZXN0LmZuKCksXG4gICAgICAgIHVubG9jazogamVzdC5mbigpLFxuICAgICAgICB3YWl0OiBqZXN0LmZuKCksXG4gICAgICAgIHNpZ25hbDogamVzdC5mbigpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBzeW5jVGVzdCA9IHtcbiAgICAgICAgb3BlcmF0aW9uczogMTAwMCxcbiAgICAgICAgY29udGVudGlvbjogNCxcbiAgICAgICAgbG9ja1R5cGU6ICdtdXRleCdcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHN5bmNNZXRyaWNzID0gW107XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3luY1Rlc3Qub3BlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN5bmNTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgc3luY2hyb25pemF0aW9uQmVuY2htYXJrLmxvY2soKTtcbiAgICAgICAgLy8gU2ltdWxhdGUgY3JpdGljYWwgc2VjdGlvblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMSkpO1xuICAgICAgICBhd2FpdCBzeW5jaHJvbml6YXRpb25CZW5jaG1hcmsudW5sb2NrKCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzeW5jRW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGNvbnN0IHN5bmNEdXJhdGlvbiA9IHN5bmNFbmQgLSBzeW5jU3RhcnQ7XG4gICAgICAgIFxuICAgICAgICBzeW5jTWV0cmljcy5wdXNoKHN5bmNEdXJhdGlvbik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGF2ZXJhZ2VTeW5jVGltZSA9IHN5bmNNZXRyaWNzLnJlZHVjZSgoc3VtLCB0aW1lKSA9PiBzdW0gKyB0aW1lLCAwKSAvIHN5bmNNZXRyaWNzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG1heFN5bmNUaW1lID0gTWF0aC5tYXgoLi4uc3luY01ldHJpY3MpO1xuICAgICAgXG4gICAgICBleHBlY3Qoc3luY2hyb25pemF0aW9uQmVuY2htYXJrLmxvY2spLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyhzeW5jVGVzdC5vcGVyYXRpb25zKTtcbiAgICAgIGV4cGVjdChzeW5jaHJvbml6YXRpb25CZW5jaG1hcmsudW5sb2NrKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoc3luY1Rlc3Qub3BlcmF0aW9ucyk7XG4gICAgICBleHBlY3QoYXZlcmFnZVN5bmNUaW1lKS50b0JlTGVzc1RoYW4oNSk7IC8vIFNob3VsZCBhdmVyYWdlIDwgNW1zIHBlciBvcGVyYXRpb25cbiAgICAgIGV4cGVjdChtYXhTeW5jVGltZSkudG9CZUxlc3NUaGFuKDIwKTsgLy8gU2hvdWxkIG1heCA8IDIwbXMgcGVyIG9wZXJhdGlvblxuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdSZWFsLXdvcmxkIFBlcmZvcm1hbmNlIFNjZW5hcmlvcycsICgpID0+IHtcbiAgICB0ZXN0KCdzaG91bGQgYmVuY2htYXJrIGNvbXBsZXRlIG5ldXJhbCBtZXNoIHByb2Nlc3NpbmcgcGlwZWxpbmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwaXBlbGluZUJlbmNobWFyayA9IHtcbiAgICAgICAgaW5pdGlhbGl6ZTogamVzdC5mbigpLFxuICAgICAgICBwcmVwcm9jZXNzOiBqZXN0LmZuKCksXG4gICAgICAgIHByb2Nlc3M6IGplc3QuZm4oKSxcbiAgICAgICAgcG9zdHByb2Nlc3M6IGplc3QuZm4oKSxcbiAgICAgICAgZmluYWxpemU6IGplc3QuZm4oKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcGlwZWxpbmVUZXN0ID0ge1xuICAgICAgICBpbnB1dFNpemU6IDEwMDAwLFxuICAgICAgICBiYXRjaFNpemU6IDEwMCxcbiAgICAgICAgc3RhZ2VzOiBbJ3ByZXByb2Nlc3MnLCAnbmV1cmFsX2luZmVyZW5jZScsICdwb3N0cHJvY2VzcyddLFxuICAgICAgICBpdGVyYXRpb25zOiAxMFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcGlwZWxpbmVNZXRyaWNzID0gW107XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGlwZWxpbmVUZXN0Lml0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCBpbnB1dCA9IG5ldyBGbG9hdDMyQXJyYXkocGlwZWxpbmVUZXN0LmlucHV0U2l6ZSk7XG4gICAgICAgIGlucHV0LmZpbGwoTWF0aC5yYW5kb20oKSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwaXBlbGluZVN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBwaXBlbGluZUJlbmNobWFyay5pbml0aWFsaXplKCk7XG4gICAgICAgIGF3YWl0IHBpcGVsaW5lQmVuY2htYXJrLnByZXByb2Nlc3MoaW5wdXQpO1xuICAgICAgICBhd2FpdCBwaXBlbGluZUJlbmNobWFyay5wcm9jZXNzKGlucHV0KTtcbiAgICAgICAgYXdhaXQgcGlwZWxpbmVCZW5jaG1hcmsucG9zdHByb2Nlc3MoaW5wdXQpO1xuICAgICAgICBhd2FpdCBwaXBlbGluZUJlbmNobWFyay5maW5hbGl6ZSgpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGlwZWxpbmVFbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY29uc3QgcGlwZWxpbmVEdXJhdGlvbiA9IHBpcGVsaW5lRW5kIC0gcGlwZWxpbmVTdGFydDtcbiAgICAgICAgXG4gICAgICAgIHBpcGVsaW5lTWV0cmljcy5wdXNoKHtcbiAgICAgICAgICBpdGVyYXRpb246IGksXG4gICAgICAgICAgZHVyYXRpb246IHBpcGVsaW5lRHVyYXRpb24sXG4gICAgICAgICAgdGhyb3VnaHB1dDogcGlwZWxpbmVUZXN0LmlucHV0U2l6ZSAvIHBpcGVsaW5lRHVyYXRpb24gKiAxMDAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBhdmVyYWdlVGhyb3VnaHB1dCA9IHBpcGVsaW5lTWV0cmljcy5yZWR1Y2UoKHN1bSwgbSkgPT4gc3VtICsgbS50aHJvdWdocHV0LCAwKSAvIHBpcGVsaW5lTWV0cmljcy5sZW5ndGg7XG4gICAgICBcbiAgICAgIGV4cGVjdChwaXBlbGluZUJlbmNobWFyay5pbml0aWFsaXplKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMocGlwZWxpbmVUZXN0Lml0ZXJhdGlvbnMpO1xuICAgICAgZXhwZWN0KHBpcGVsaW5lQmVuY2htYXJrLnByb2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyhwaXBlbGluZVRlc3QuaXRlcmF0aW9ucyk7XG4gICAgICBleHBlY3QoYXZlcmFnZVRocm91Z2hwdXQpLnRvQmVHcmVhdGVyVGhhbigxMDAwKTsgLy8gU2hvdWxkIGFjaGlldmUgPiAxMDAwIGl0ZW1zL3NlY1xuICAgIH0pO1xuICAgIFxuICAgIHRlc3QoJ3Nob3VsZCBzdHJlc3MgdGVzdCB1bmRlciBoaWdoIGxvYWQgY29uZGl0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN0cmVzc1Rlc3QgPSB7XG4gICAgICAgIGR1cmF0aW9uOiAzMDAwMCwgLy8gMzAgc2Vjb25kc1xuICAgICAgICBtYXhDb25jdXJyZW5jeTogMTAsXG4gICAgICAgIHJlcXVlc3RSYXRlOiAxMDAsIC8vIHJlcXVlc3RzIHBlciBzZWNvbmRcbiAgICAgICAgbWVtb3J5TGltaXQ6IDEwMCAqIDEwMjQgKiAxMDI0IC8vIDEwME1CXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBzdHJlc3NNZXRyaWNzID0ge1xuICAgICAgICByZXF1ZXN0czogMCxcbiAgICAgICAgZXJyb3JzOiAwLFxuICAgICAgICB0aW1lb3V0czogMCxcbiAgICAgICAgbWF4TWVtb3J5OiAwLFxuICAgICAgICBhdmdMYXRlbmN5OiAwXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBzdHJlc3NTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3Qgc3RyZXNzRW5kID0gc3RyZXNzU3RhcnQgKyBzdHJlc3NUZXN0LmR1cmF0aW9uO1xuICAgICAgXG4gICAgICB3aGlsZSAocGVyZm9ybWFuY2Uubm93KCkgPCBzdHJlc3NFbmQpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdFN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHdhc21Nb2R1bGUucHJvY2VzcyhuZXcgRmxvYXQzMkFycmF5KDEwMDApKTtcbiAgICAgICAgICBzdHJlc3NNZXRyaWNzLnJlcXVlc3RzKys7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgc3RyZXNzTWV0cmljcy5lcnJvcnMrKztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVxdWVzdEVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCByZXF1ZXN0RHVyYXRpb24gPSByZXF1ZXN0RW5kIC0gcmVxdWVzdFN0YXJ0O1xuICAgICAgICBcbiAgICAgICAgc3RyZXNzTWV0cmljcy5hdmdMYXRlbmN5ID0gKHN0cmVzc01ldHJpY3MuYXZnTGF0ZW5jeSAqIChzdHJlc3NNZXRyaWNzLnJlcXVlc3RzIC0gMSkgKyByZXF1ZXN0RHVyYXRpb24pIC8gc3RyZXNzTWV0cmljcy5yZXF1ZXN0cztcbiAgICAgICAgXG4gICAgICAgIC8vIFNpbXVsYXRlIHJlcXVlc3QgcmF0ZVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCAvIHN0cmVzc1Rlc3QucmVxdWVzdFJhdGUpKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZXJyb3JSYXRlID0gc3RyZXNzTWV0cmljcy5lcnJvcnMgLyBzdHJlc3NNZXRyaWNzLnJlcXVlc3RzO1xuICAgICAgY29uc3QgcmVxdWVzdHNQZXJTZWNvbmQgPSBzdHJlc3NNZXRyaWNzLnJlcXVlc3RzIC8gKHN0cmVzc1Rlc3QuZHVyYXRpb24gLyAxMDAwKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGVycm9yUmF0ZSkudG9CZUxlc3NUaGFuKDAuMDEpOyAvLyBTaG91bGQgaGF2ZSA8IDElIGVycm9yIHJhdGVcbiAgICAgIGV4cGVjdChyZXF1ZXN0c1BlclNlY29uZCkudG9CZUdyZWF0ZXJUaGFuKHN0cmVzc1Rlc3QucmVxdWVzdFJhdGUgKiAwLjgpOyAvLyBTaG91bGQgYWNoaWV2ZSA+IDgwJSB0YXJnZXQgcmF0ZVxuICAgICAgZXhwZWN0KHN0cmVzc01ldHJpY3MuYXZnTGF0ZW5jeSkudG9CZUxlc3NUaGFuKDEwMCk7IC8vIFNob3VsZCBhdmVyYWdlIDwgMTAwbXMgbGF0ZW5jeVxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBLE1BQU07RUFBRUEsUUFBUTtFQUFFQyxJ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